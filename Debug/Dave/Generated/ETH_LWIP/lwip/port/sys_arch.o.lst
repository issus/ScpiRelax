   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "sys_arch.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .text.sys_now,"ax",%progbits
  20              	 .align 2
  21              	 .global sys_now
  22              	 .thumb
  23              	 .thumb_func
  25              	sys_now:
  26              	.LFB133:
  27              	 .file 1 "../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c"
   1:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** /*
   2:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
   3:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * All rights reserved. 
   4:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * 
   5:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * Redistribution and use in source and binary forms, with or without modification, 
   6:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * are permitted provided that the following conditions are met:
   7:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  *
   8:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * 1. Redistributions of source code must retain the above copyright notice,
   9:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  *    this list of conditions and the following disclaimer.
  10:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  11:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  *    this list of conditions and the following disclaimer in the documentation
  12:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  *    and/or other materials provided with the distribution.
  13:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * 3. The name of the author may not be used to endorse or promote products
  14:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  *    derived from this software without specific prior written permission. 
  15:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  *
  16:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
  17:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
  18:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
  19:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
  20:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
  21:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
  22:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
  23:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
  24:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
  25:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * OF SUCH DAMAGE.
  26:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  *
  27:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * This file is part of the lwIP TCP/IP stack.
  28:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * 
  29:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * Author: Adam Dunkels <adam@sics.se>
  30:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  *
  31:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  */
  32:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
  33:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #include "ETH_LWIP/lwip/include/lwip/opt.h"
  34:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
  35:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #if !NO_SYS
  36:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
  37:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #include <string.h>
  38:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #include "CMSIS_RTOS/cmsis_rtos.h"
  39:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
  40:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #include "ETH_LWIP/lwip/include/lwip/sys.h"
  41:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #include "ETH_LWIP/lwip/include/lwip/stats.h"
  42:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #include "ETH_LWIP/lwip/include/lwip/debug.h"
  43:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
  44:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #if defined ( __CC_ARM )
  45:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** int32_t errno;
  46:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif
  47:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
  48:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #if !defined(CMSIS_RTOS_CONFIG_IMPL_FREERTOS)
  49:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #if (CMSIS_RTOS_PRIVCNT < 2)
  50:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #error "ETH_LWIP: requires at least 2 threads with user-provided stack size when running in an OS e
  51:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif
  52:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
  53:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #if (CMSIS_RTOS_PRIVSTKSIZE < ETH_LWIP_MIN_PRIV_STACK_SIZE)
  54:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #error "ETH_LWIP: requires at least ETH_LWIP_MIN_PRIV_STACK_SIZE bytes of stack size for threads wi
  55:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif
  56:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif
  57:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
  58:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #if defined(CMSIS_RTOS_CONFIG_IMPL_RTX)
  59:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** err_t sys_sem_new(sys_sem_t *sem, u8_t count)
  60:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
  61:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   memset(sem, 0, sizeof(sys_sem_t));
  62:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   sem->def.semaphore = sem->cb;
  63:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
  64:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   sem->id = osSemaphoreCreate(&sem->def, count);
  65:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
  66:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (sem->id == NULL)
  67:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
  68:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     SYS_STATS_INC(sem.err);
  69:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return ERR_MEM;
  70:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
  71:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   else
  72:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
  73:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     SYS_STATS_INC_USED(sem);
  74:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return ERR_OK;
  75:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
  76:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
  77:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
  78:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** void sys_sem_free(sys_sem_t *sem)
  79:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
  80:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (sem->id != NULL)
  81:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
  82:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     osSemaphoreDelete(sem->id);
  83:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     SYS_STATS_DEC(sem.used);
  84:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
  85:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
  86:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
  87:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
  88:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
  89:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
  90:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   int32_t  count;
  91:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   uint32_t tick_start;
  92:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   uint32_t tick_stop;
  93:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   uint32_t tick_elapsed;
  94:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
  95:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   tick_start = osKernelSysTick();
  96:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
  97:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (timeout == 0)
  98:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
  99:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     count = osSemaphoreWait(sem->id, osWaitForever);
 100:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 101:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   else
 102:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 103:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     count = osSemaphoreWait(sem->id, timeout);
 104:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 105:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 106:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   tick_stop = osKernelSysTick();
 107:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 108:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (count < 1)
 109:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 110:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return SYS_ARCH_TIMEOUT;
 111:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 112:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 113:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   /* Take care of wrap-around. */
 114:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (tick_stop >= tick_start)
 115:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 116:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     tick_elapsed = tick_stop - tick_start;
 117:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 118:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   else
 119:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 120:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     tick_elapsed = (UINT32_MAX - tick_start) + tick_stop;
 121:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 122:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 123:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   return (u32_t)(1000U * ((float)tick_elapsed / osKernelSysTickFrequency));
 124:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 125:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 126:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** void sys_sem_signal(sys_sem_t *sem)
 127:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 128:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (sem->id != NULL)
 129:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 130:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     osSemaphoreRelease(sem->id);
 131:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 132:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 133:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 134:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** err_t sys_mutex_new(sys_mutex_t *mutex)
 135:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 136:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   memset(mutex, 0, sizeof(sys_mutex_t));
 137:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   mutex->def.mutex = mutex->cb;
 138:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 139:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   mutex->id = osMutexCreate(&mutex->def);
 140:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 141:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (mutex->id == NULL)
 142:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 143:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     SYS_STATS_INC(mutex.err);
 144:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return ERR_MEM;
 145:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 146:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   else
 147:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 148:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     SYS_STATS_INC_USED(mutex);
 149:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return ERR_OK;
 150:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 151:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 152:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 153:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** void sys_mutex_free(sys_mutex_t *mutex)
 154:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 155:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (mutex->id != NULL)
 156:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 157:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     osMutexDelete(mutex->id);
 158:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     SYS_STATS_DEC(mutex.used);    
 159:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 160:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 161:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 162:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** void sys_mutex_lock(sys_mutex_t *mutex)
 163:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 164:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (mutex->id != NULL)
 165:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 166:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     osMutexWait(mutex->id, osWaitForever);
 167:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 168:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 169:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 170:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** void sys_mutex_unlock(sys_mutex_t *mutex)
 171:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 172:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (mutex->id != NULL)
 173:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 174:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     osMutexRelease(mutex->id);
 175:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 176:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 177:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 178:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** err_t sys_mbox_new(sys_mbox_t *mbox, int size)
 179:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 180:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (size > SYS_MBOX_SIZE) {
 181:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return ERR_MEM;
 182:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 183:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 184:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   memset(mbox, 0, sizeof(sys_mbox_t));
 185:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   mbox->def.pool = mbox->q;
 186:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   mbox->def.queue_sz = size;
 187:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 188:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   mbox->id = osMessageCreate(&mbox->def, NULL);
 189:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 190:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (mbox->id == NULL)
 191:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 192:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     SYS_STATS_INC(mbox.err);
 193:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return ERR_MEM;
 194:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 195:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   else
 196:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 197:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     SYS_STATS_INC_USED(mbox);
 198:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return ERR_OK;
 199:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 200:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 201:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 202:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** void sys_mbox_free(sys_mbox_t *mbox)
 203:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 204:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (mbox->id != NULL)
 205:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 206:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     osMessageGet(mbox->id, 0);
 207:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 208:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     mbox->id = NULL;
 209:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     SYS_STATS_DEC(mbox.used);
 210:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }    
 211:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 212:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 213:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** void sys_mbox_post(sys_mbox_t *mbox, void *msg)
 214:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 215:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (mbox->id != NULL)
 216:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 217:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     osMessagePut(mbox->id, (uint32_t)msg, osWaitForever);
 218:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 219:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 220:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 221:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
 222:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 223:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osStatus status;
 224:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 225:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (mbox->id != NULL)
 226:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 227:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     status = osMessagePut(mbox->id, (uint32_t)msg, 0);
 228:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     if (status != osOK)
 229:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     {
 230:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****       return ERR_MEM;
 231:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     }
 232:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return ERR_OK;
 233:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 234:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   else
 235:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 236:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return ERR_ARG;
 237:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 238:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 239:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 240:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
 241:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 242:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osEvent  event;
 243:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   uint32_t tick_start;
 244:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   uint32_t tick_stop;
 245:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   uint32_t tick_elapsed;
 246:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 247:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   tick_start = osKernelSysTick();
 248:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 249:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (timeout == 0)
 250:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 251:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     event = osMessageGet(mbox->id, osWaitForever);
 252:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   } else
 253:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 254:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     event = osMessageGet(mbox->id, timeout);
 255:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 256:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 257:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (event.status != osEventMessage)
 258:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 259:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return SYS_ARCH_TIMEOUT;
 260:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 261:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 262:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (msg != NULL)
 263:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 264:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     *msg = event.value.p;
 265:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 266:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 267:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   tick_stop = osKernelSysTick();
 268:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 269:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   /* Take care of wrap-around. */
 270:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (tick_stop >= tick_start)
 271:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 272:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     tick_elapsed = tick_stop - tick_start;
 273:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 274:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   else
 275:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 276:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     tick_elapsed = (UINT32_MAX - tick_start) + tick_stop;
 277:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 278:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 279:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   return (u32_t)(1000U * ((float)tick_elapsed / osKernelSysTickFrequency));
 280:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 281:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 282:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
 283:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 284:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osEvent event;
 285:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 286:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (mbox->id != NULL)
 287:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 288:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     event = osMessageGet(mbox->id, 0);
 289:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     if (event.status != osEventMessage) 
 290:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     {
 291:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****       return SYS_MBOX_EMPTY;
 292:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     }
 293:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 294:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     if (msg != NULL) 
 295:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     {
 296:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****       *msg = event.value.p;
 297:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     }
 298:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 299:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return ERR_OK;
 300:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 301:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   else
 302:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 303:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return ERR_ARG;
 304:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 305:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 306:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 307:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** sys_thread_t sys_thread_new(const char *name, lwip_thread_fn function, void *arg, int stacksize, in
 308:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 309:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_UNUSED_ARG(name);
 310:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 311:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osThreadId threadId;
 312:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osThreadDef_t threadDef;
 313:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 314:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   threadDef.pthread = (os_pthread)function;
 315:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   threadDef.tpriority = (osPriority)prio;
 316:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   threadDef.instances = 1;
 317:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   threadDef.stacksize = stacksize;
 318:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 319:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   threadId = osThreadCreate(&threadDef, arg);
 320:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_PLATFORM_ASSERT(threadId != NULL);
 321:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 322:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   return threadId;
 323:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 324:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 325:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #if SYS_LIGHTWEIGHT_PROT
 326:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 327:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** static sys_mutex_t lwip_mutex;
 328:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 329:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** sys_prot_t sys_arch_protect(void)
 330:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 331:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (osKernelRunning ())
 332:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   sys_mutex_lock(&lwip_mutex);
 333:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   return 0;
 334:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 335:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 336:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** void sys_arch_unprotect(sys_prot_t pval)
 337:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 338:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_UNUSED_ARG(pval);
 339:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (osKernelRunning ())
 340:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   sys_mutex_unlock(&lwip_mutex);
 341:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 342:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 343:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif /* SYS_LIGHTWEIGHT_PROT */
 344:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 345:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** extern uint32_t os_time; // Time keping in RTOS RTX systick handler
 346:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 347:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** uint32_t sys_now(void)
 348:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 349:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #if CMSIS_RTOS_RTX_TICK == 1000
 350:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   return os_time;
 351:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #else
 352:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   return (os_time * (CMSIS_RTOS_RTX_TICK / 1000));
 353:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif  
 354:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 355:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 356:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** void sys_init(void)
 357:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 358:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #if SYS_LIGHTWEIGHT_PROT
 359:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   sys_mutex_new(&lwip_mutex);
 360:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif
 361:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 362:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #else /* defined(CMSIS_RTOS_CONFIG_IMPL_RTX) */
 363:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 364:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** /** Set this to 1 to use a mutex for SYS_ARCH_PROTECT() critical regions.
 365:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * Default is 0 and locks interrupts/scheduler for SYS_ARCH_PROTECT().
 366:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  */
 367:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #ifndef LWIP_SYS_ARCH_PROTECT_USES_MUTEX
 368:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #define LWIP_SYS_ARCH_PROTECT_USES_MUTEX     0
 369:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif
 370:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 371:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** /** Set this to 1 to include a sanity check that SYS_ARCH_PROTECT() and
 372:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  * SYS_ARCH_UNPROTECT() are called matching.
 373:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****  */
 374:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #ifndef LWIP_SYS_ARCH_PROTECT_SANITY_CHECK
 375:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #define LWIP_SYS_ARCH_PROTECT_SANITY_CHECK   0
 376:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif
 377:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 378:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** /** Set this to 1 to let sys_mbox_free check that queues are empty when freed */
 379:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #ifndef LWIP_CHECK_QUEUE_EMPTY_ON_FREE
 380:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #define LWIP_CHECK_QUEUE_EMPTY_ON_FREE       0
 381:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif
 382:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 383:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 384:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #if SYS_LIGHTWEIGHT_PROT && LWIP_SYS_ARCH_PROTECT_USES_MUTEX
 385:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** static osMutexId_t sys_arch_protect_mutex;
 386:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif
 387:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 388:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #if SYS_LIGHTWEIGHT_PROT && LWIP_SYS_ARCH_PROTECT_SANITY_CHECK
 389:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** static sys_prot_t sys_arch_protect_nesting;
 390:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif
 391:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 392:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** void sys_init(void)
 393:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 394:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #if SYS_LIGHTWEIGHT_PROT && LWIP_SYS_ARCH_PROTECT_USES_MUTEX
 395:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   /* initialize sys_arch_protect global mutex */
 396:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   static const osMutexAttr_t attr = {
 397:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     NULL, osMutexPrioInherit | osMutexRecursive | osMutexRobust, NULL, 0
 398:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   };
 399:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 400:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   sys_arch_protect_mutex = osMutexNew(&attr);
 401:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("failed to create sys_arch_protect mutex", sys_arch_protect_mutex != NULL);
 402:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif /* SYS_LIGHTWEIGHT_PROT && LWIP_FREERTOS_SYS_ARCH_PROTECT_USES_MUTEX */
 403:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 404:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 405:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** u32_t sys_now(void)
 406:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 407:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   return (osKernelGetTickCount() * 1000) / osKernelGetTickFreq();
 408:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 409:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 410:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** u32_t sys_jiffies(void)
 411:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 412:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   return osKernelGetTickCount();
 413:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 414:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 415:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #if SYS_LIGHTWEIGHT_PROT
 416:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 417:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** sys_prot_t sys_arch_protect(void)
 418:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 419:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #if LWIP_SYS_ARCH_PROTECT_USES_MUTEX
 420:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   BaseType_t ret;
 421:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("sys_arch_protect_mutex != NULL", sys_arch_protect_mutex != NULL);
 422:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 423:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   ret = osMutexAcquire(sys_arch_protect_mutex, osWaitForever);
 424:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("sys_arch_protect failed to take the mutex", ret == osOK);
 425:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #else /* LWIP_SYS_ARCH_PROTECT_USES_MUTEX */
 426:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osKernelLock();
 427:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif /* LWIP_FREERTOS_SYS_ARCH_PROTECT_USES_MUTEX */
 428:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #if LWIP_SYS_ARCH_PROTECT_SANITY_CHECK
 429:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 430:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     /* every nested call to sys_arch_protect() returns an increased number */
 431:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     sys_prot_t ret = sys_arch_protect_nesting;
 432:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     sys_arch_protect_nesting++;
 433:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     LWIP_ASSERT("sys_arch_protect overflow", sys_arch_protect_nesting > ret);
 434:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return ret;
 435:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 436:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #else
 437:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   return 1;
 438:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif
 439:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 440:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 441:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** void sys_arch_unprotect(sys_prot_t pval)
 442:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 443:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #if LWIP_SYS_ARCH_PROTECT_USES_MUTEX
 444:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osStatus_t ret;
 445:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif
 446:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #if LWIP_SYS_ARCH_PROTECT_SANITY_CHECK
 447:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("unexpected sys_arch_protect_nesting", sys_arch_protect_nesting > 0);
 448:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   sys_arch_protect_nesting--;
 449:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("unexpected sys_arch_protect_nesting", sys_arch_protect_nesting == pval);
 450:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif
 451:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 452:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #if LWIP_SYS_ARCH_PROTECT_USES_MUTEX
 453:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("sys_arch_protect_mutex != NULL", sys_arch_protect_mutex != NULL);
 454:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 455:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   ret = osMutexRelease(sys_arch_protect_mutex);
 456:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("sys_arch_unprotect failed to give the mutex", ret == osOK);
 457:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #else /* LWIP_SYS_ARCH_PROTECT_USES_MUTEX */
 458:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osKernelUnlock();
 459:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif /* LWIP_SYS_ARCH_PROTECT_USES_MUTEX */
 460:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_UNUSED_ARG(pval);
 461:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 462:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 463:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif /* SYS_LIGHTWEIGHT_PROT */
 464:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 465:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** void sys_arch_msleep(u32_t delay_ms)
 466:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 467:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   uint32_t delay_ticks = delay_ms * (osKernelGetTickFreq() / 1000);
 468:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osDelay(delay_ticks);
 469:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 470:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 471:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 472:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #if !LWIP_COMPAT_MUTEX
 473:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** /* Mutexes */
 474:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** err_t sys_mutex_new(sys_mutex_t *mutex)
 475:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 476:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mutex != NULL", mutex != NULL);
 477:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 478:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   // CMSIS-FreeRTOS  Version 10.2.0 Limitations
 479:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   // Robust mutex objects are not supported (osMutexNew returns NULL when osMutexRobust attribute i
 480:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   // Priority inherit protocol is used as default mutex behavior (osMutexNew creates priority inher
 481:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   static const osMutexAttr_t attr = {
 482:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     NULL, osMutexPrioInherit | osMutexRecursive, NULL, 0
 483:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   };
 484:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 485:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   mutex->mut = osMutexNew(&attr);
 486:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (mutex->mut == NULL) {
 487:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     SYS_STATS_INC(mutex.err);
 488:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return ERR_MEM;
 489:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 490:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   SYS_STATS_INC_USED(mutex);
 491:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   return ERR_OK;
 492:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 493:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 494:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** void sys_mutex_lock(sys_mutex_t *mutex)
 495:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 496:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osStatus_t ret;
 497:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mutex != NULL", mutex != NULL);
 498:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mutex->mut != NULL", mutex->mut != NULL);
 499:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 500:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   ret = osMutexAcquire(mutex->mut, osWaitForever);
 501:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("failed to take the mutex", ret == osOK);
 502:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 503:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 504:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** void sys_mutex_unlock(sys_mutex_t *mutex)
 505:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 506:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osStatus_t ret;
 507:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mutex != NULL", mutex != NULL);
 508:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mutex->mut != NULL", mutex->mut != NULL);
 509:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 510:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   ret = osMutexRelease(mutex->mut);
 511:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("failed to give the mutex", ret == osOK);
 512:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 513:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 514:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** void sys_mutex_free(sys_mutex_t *mutex)
 515:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 516:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mutex != NULL", mutex != NULL);
 517:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mutex->mut != NULL", mutex->mut != NULL);
 518:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 519:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   SYS_STATS_DEC(mutex.used);
 520:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osMutexDelete(mutex->mut);
 521:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   mutex->mut = NULL;
 522:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 523:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 524:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif /* !LWIP_COMPAT_MUTEX */
 525:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 526:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 527:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** /* Semaphores */
 528:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** err_t sys_sem_new(sys_sem_t *sem, u8_t initial_count)
 529:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 530:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("sem != NULL", sem != NULL);
 531:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("initial_count invalid (not 0 or 1)",
 532:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     (initial_count == 0) || (initial_count == 1));
 533:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 534:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   sem->sem = osSemaphoreNew(1, initial_count, NULL);
 535:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if(sem->sem == NULL) {
 536:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     SYS_STATS_INC(sem.err);
 537:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return ERR_MEM;
 538:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 539:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   SYS_STATS_INC_USED(sem);
 540:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 541:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if(initial_count == 1) {
 542:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 	osStatus_t ret = osSemaphoreRelease(sem->sem);
 543:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     LWIP_ASSERT("sys_sem_new: initial give failed", ret == osOK);
 544:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 545:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   return ERR_OK;
 546:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 547:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 548:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** void sys_sem_signal(sys_sem_t *sem)
 549:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 550:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osStatus_t ret;
 551:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("sem != NULL", sem != NULL);
 552:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("sem->sem != NULL", sem->sem != NULL);
 553:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 554:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   ret = osSemaphoreRelease(sem->sem);
 555:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   /* queue full is OK, this is a signal only... */
 556:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("sys_sem_signal: sane return value", (ret == osOK));
 557:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 558:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 559:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout_ms)
 560:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 561:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osStatus_t ret;
 562:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("sem != NULL", sem != NULL);
 563:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("sem->sem != NULL", sem->sem != NULL);
 564:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 565:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if(!timeout_ms) {
 566:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     /* wait infinite */
 567:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     ret = osSemaphoreAcquire(sem->sem, osWaitForever);
 568:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     LWIP_ASSERT("taking semaphore failed", ret == osOK);
 569:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   } else {
 570:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 	uint32_t timeout_ticks = timeout_ms * (osKernelGetTickFreq() / 1000);
 571:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     ret = osSemaphoreAcquire(sem->sem, timeout_ticks);
 572:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     if (ret == osErrorTimeout) {
 573:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****       /* timed out */
 574:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****       return SYS_ARCH_TIMEOUT;
 575:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     }
 576:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     LWIP_ASSERT("taking semaphore failed", ret == osOK);
 577:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 578:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 579:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   /* Old versions of lwIP required us to return the time waited.
 580:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****      This is not the case any more. Just returning != SYS_ARCH_TIMEOUT
 581:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****      here is enough. */
 582:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   return 1;
 583:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 584:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 585:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 586:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** void sys_sem_free(sys_sem_t *sem)
 587:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 588:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("sem != NULL", sem != NULL);
 589:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("sem->sem != NULL", sem->sem != NULL);
 590:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 591:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   SYS_STATS_DEC(sem.used);
 592:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osSemaphoreDelete(sem->sem);
 593:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   sem->sem = NULL;
 594:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 595:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 596:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 597:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** /* Mailbox */
 598:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** err_t sys_mbox_new(sys_mbox_t *mbox, int size)
 599:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 600:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mbox != NULL", mbox != NULL);
 601:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("size > 0", size > 0);
 602:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 603:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   mbox->mbx = osMessageQueueNew((uint32_t)size, sizeof(void *), NULL);
 604:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if(mbox->mbx == NULL) {
 605:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     SYS_STATS_INC(mbox.err);
 606:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return ERR_MEM;
 607:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 608:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   SYS_STATS_INC_USED(mbox);
 609:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   return ERR_OK;
 610:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 611:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 612:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** void sys_mbox_post(sys_mbox_t *mbox, void *msg)
 613:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 614:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osStatus_t ret;
 615:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mbox != NULL", mbox != NULL);
 616:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mbox->mbx != NULL", mbox->mbx != NULL);
 617:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 618:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   ret = osMessageQueuePut(mbox->mbx, &msg, 0, osWaitForever);
 619:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mbox post failed", ret == osOK);
 620:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 621:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 622:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
 623:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 624:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osStatus_t ret;
 625:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mbox != NULL", mbox != NULL);
 626:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mbox->mbx != NULL", mbox->mbx != NULL);
 627:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 628:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   ret = osMessageQueuePut(mbox->mbx, &msg, 0, 0);
 629:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (ret == osOK) {
 630:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return ERR_OK;
 631:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   } else {
 632:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     LWIP_ASSERT("mbox trypost failed", ret == osErrorResource);
 633:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     SYS_STATS_INC(mbox.err);
 634:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return ERR_MEM;
 635:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 636:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 637:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 638:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** err_t sys_mbox_trypost_fromisr(sys_mbox_t *mbox, void *msg)
 639:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 640:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osStatus_t ret;
 641:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mbox != NULL", mbox != NULL);
 642:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mbox->mbx != NULL", mbox->mbx != NULL);
 643:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 644:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   ret = osMessageQueuePut(mbox->mbx, &msg, 0, 0);
 645:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (ret == osOK) {
 646:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return ERR_OK;
 647:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   } else {
 648:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     LWIP_ASSERT("mbox trypost failed", ret == osErrorResource);
 649:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     SYS_STATS_INC(mbox.err);
 650:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return ERR_MEM;
 651:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 652:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 653:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 654:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout_ms)
 655:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 656:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osStatus_t ret;
 657:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   void *msg_dummy;
 658:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mbox != NULL", mbox != NULL);
 659:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mbox->mbx != NULL", mbox->mbx != NULL);
 660:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 661:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (!msg) {
 662:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     msg = &msg_dummy;
 663:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 664:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 665:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (!timeout_ms) {
 666:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     /* wait infinite */
 667:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     ret = osMessageQueueGet(mbox->mbx, &(*msg), 0, osWaitForever);
 668:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     LWIP_ASSERT("mbox fetch failed", ret == osOK);
 669:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   } else {
 670:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     uint32_t timeout_ticks = timeout_ms * (osKernelGetTickFreq() / 1000);
 671:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     ret = osMessageQueueGet(mbox->mbx, &(*msg), 0, timeout_ticks);
 672:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     if (ret == osErrorTimeout) {
 673:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****       /* timed out */
 674:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****       *msg = NULL;
 675:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****       return SYS_ARCH_TIMEOUT;
 676:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     }
 677:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     LWIP_ASSERT("mbox fetch failed", ret == osOK);
 678:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 679:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 680:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   /* Old versions of lwIP required us to return the time waited.
 681:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****      This is not the case any more. Just returning != SYS_ARCH_TIMEOUT
 682:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****      here is enough. */
 683:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   return 1;
 684:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 685:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 686:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
 687:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 688:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osStatus_t ret;
 689:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   void *msg_dummy;
 690:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mbox != NULL", mbox != NULL);
 691:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mbox->mbx != NULL", mbox->mbx != NULL);
 692:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 693:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (!msg) {
 694:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     msg = &msg_dummy;
 695:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 696:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 697:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   ret = osMessageQueueGet(mbox->mbx, &(*msg), 0, 0);
 698:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   if (ret == osErrorResource) {
 699:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     *msg = NULL;
 700:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     return SYS_MBOX_EMPTY;
 701:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 702:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mbox fetch failed", ret == pdTRUE);
 703:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 704:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   /* Old versions of lwIP required us to return the time waited.
 705:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****      This is not the case any more. Just returning != SYS_ARCH_TIMEOUT
 706:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****      here is enough. */
 707:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   return 1;
 708:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 709:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 710:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 711:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** void sys_mbox_free(sys_mbox_t *mbox)
 712:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 713:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mbox != NULL", mbox != NULL);
 714:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("mbox->mbx != NULL", mbox->mbx != NULL);
 715:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 716:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #if LWIP_CHECK_QUEUE_EMPTY_ON_FREE
 717:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   {
 718:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 	uint32_t msgs_waiting = osMessageQueueGetCount(mbox->mbx);
 719:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     LWIP_ASSERT("mbox quence not empty", msgs_waiting == 0);
 720:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 721:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     if (msgs_waiting != 0) {
 722:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****       SYS_STATS_INC(mbox.err);
 723:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****     }
 724:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   }
 725:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif
 726:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 727:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osMessageQueueDelete(mbox->mbx);
 728:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 729:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   SYS_STATS_DEC(mbox.used);
 730:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 731:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 732:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 733:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** sys_thread_t sys_thread_new(const char *name, lwip_thread_fn function, void *arg, int stacksize, in
 734:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
 735:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osThreadAttr_t attr;
 736:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   osThreadId_t   id;
 737:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   sys_thread_t lwip_thread;
 738:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 739:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("invalid stacksize", stacksize > 0);
 740:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 741:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   memset (&attr, 0, sizeof(attr));
 742:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   attr.name       = name;
 743:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   attr.stack_size = (uint32_t)stacksize;
 744:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   attr.priority = prio;
 745:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 746:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   id = osThreadNew(function, arg, &attr);
 747:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   LWIP_ASSERT("task creation failed", id != NULL);
 748:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 749:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   lwip_thread.thread_handle = id;
 750:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   return lwip_thread;
 751:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
 752:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 753:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #endif
 754:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #else /* !NO_SYS */
 755:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 756:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 757:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #include <SYSTIMER/systimer.h>
 758:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #include "include/arch/cc.h"
 759:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** #include "../include/lwip/sys.h"
 760:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 761:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** uint32_t sys_now(void)
 762:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
  28              	 .loc 1 762 0
  29              	 .cfi_startproc
  30              	 
  31              	 
  32 0000 80B5     	 push {r7,lr}
  33              	.LCFI0:
  34              	 .cfi_def_cfa_offset 8
  35              	 .cfi_offset 7,-8
  36              	 .cfi_offset 14,-4
  37 0002 00AF     	 add r7,sp,#0
  38              	.LCFI1:
  39              	 .cfi_def_cfa_register 7
 763:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c ****   return (u32_t)(SYSTIMER_GetTickCount() * SYSTIMER_TICK_PERIOD * 1000);
  40              	 .loc 1 763 0
  41 0004 FFF7FEFF 	 bl SYSTIMER_GetTickCount
  42 0008 07EE900A 	 fmsr s15,r0
  43 000c F8EE677A 	 fuitos s15,s15
  44 0010 9FED067A 	 flds s14,.L3
  45 0014 67EE877A 	 fmuls s15,s15,s14
  46 0018 9FED057A 	 flds s14,.L3+4
  47 001c 67EE877A 	 fmuls s15,s15,s14
  48 0020 FCEEE77A 	 ftouizs s15,s15
  49 0024 17EE903A 	 fmrs r3,s15
 764:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
  50              	 .loc 1 764 0
  51 0028 1846     	 mov r0,r3
  52 002a 80BD     	 pop {r7,pc}
  53              	.L4:
  54              	 .align 2
  55              	.L3:
  56 002c 6F12833A 	 .word 981668463
  57 0030 00007A44 	 .word 1148846080
  58              	 .cfi_endproc
  59              	.LFE133:
  61              	 .section .text.sys_init,"ax",%progbits
  62              	 .align 2
  63              	 .global sys_init
  64              	 .thumb
  65              	 .thumb_func
  67              	sys_init:
  68              	.LFB134:
 765:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** 
 766:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** void sys_init()
 767:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** {
  69              	 .loc 1 767 0
  70              	 .cfi_startproc
  71              	 
  72              	 
  73              	 
  74 0000 80B4     	 push {r7}
  75              	.LCFI2:
  76              	 .cfi_def_cfa_offset 4
  77              	 .cfi_offset 7,-4
  78 0002 00AF     	 add r7,sp,#0
  79              	.LCFI3:
  80              	 .cfi_def_cfa_register 7
 768:../Dave/Generated/ETH_LWIP/lwip/port/sys_arch.c **** }
  81              	 .loc 1 768 0
  82 0004 BD46     	 mov sp,r7
  83              	.LCFI4:
  84              	 .cfi_def_cfa_register 13
  85              	 
  86 0006 5DF8047B 	 ldr r7,[sp],#4
  87              	.LCFI5:
  88              	 .cfi_restore 7
  89              	 .cfi_def_cfa_offset 0
  90 000a 7047     	 bx lr
  91              	 .cfi_endproc
  92              	.LFE134:
  94              	 .text
  95              	.Letext0:
  96              	 .file 2 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
  97              	 .file 3 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
  98              	 .file 4 "C:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/ScpiRelax/Dave/Generated/ETH_LWIP/lwip/include/lwip/arch.h"
  99              	 .file 5 "C:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/ScpiRelax/Libraries/CMSIS/Include/cmsis_gcc.h"
 100              	 .file 6 "C:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/ScpiRelax/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 sys_arch.c
    {standard input}:20     .text.sys_now:00000000 $t
    {standard input}:25     .text.sys_now:00000000 sys_now
    {standard input}:56     .text.sys_now:0000002c $d
    {standard input}:62     .text.sys_init:00000000 $t
    {standard input}:67     .text.sys_init:00000000 sys_init
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
SYSTIMER_GetTickCount
