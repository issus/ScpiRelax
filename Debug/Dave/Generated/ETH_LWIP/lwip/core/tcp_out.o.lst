   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "tcp_out.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .text.tcp_route,"ax",%progbits
  20              	 .align 2
  21              	 .thumb
  22              	 .thumb_func
  24              	tcp_route:
  25              	.LFB133:
  26              	 .file 1 "../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c"
   1:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /**
   2:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @file
   3:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Transmission Control Protocol, outgoing traffic
   4:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
   5:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * The output functions of TCP.
   6:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
   7:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * There are two distinct ways for TCP segments to get sent:
   8:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * - queued data: these are segments transferring data or segments containing
   9:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   SYN or FIN (which both count as one sequence number). They are created as
  10:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   struct @ref pbuf together with a struct tcp_seg and enqueue to the
  11:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   unsent list of the pcb. They are sent by tcp_output:
  12:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   - @ref tcp_write : creates data segments
  13:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   - @ref tcp_split_unsent_seg : splits a data segment
  14:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   - @ref tcp_enqueue_flags : creates SYN-only or FIN-only segments
  15:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   - @ref tcp_output / tcp_output_segment : finalize the tcp header
  16:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *      (e.g. sequence numbers, options, checksum) and output to IP
  17:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   - the various tcp_rexmit functions shuffle around segments between the
  18:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *     unsent an unacked lists to retransmit them
  19:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   - tcp_create_segment and tcp_pbuf_prealloc allocate pbuf and
  20:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *     segment for these functions
  21:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * - direct send: these segments don't contain data but control the connection
  22:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   behaviour. They are created as pbuf only and sent directly without
  23:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   enqueueing them:
  24:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   - @ref tcp_send_empty_ack sends an ACK-only segment
  25:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   - @ref tcp_rst sends a RST segment
  26:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   - @ref tcp_keepalive sends a keepalive segment
  27:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   - @ref tcp_zero_window_probe sends a window probe segment
  28:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   - tcp_output_alloc_header allocates a header-only pbuf for these functions
  29:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
  30:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
  31:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /*
  32:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
  33:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * All rights reserved.
  34:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
  35:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Redistribution and use in source and binary forms, with or without modification,
  36:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * are permitted provided that the following conditions are met:
  37:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
  38:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  39:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *    this list of conditions and the following disclaimer.
  40:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  41:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *    this list of conditions and the following disclaimer in the documentation
  42:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *    and/or other materials provided with the distribution.
  43:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * 3. The name of the author may not be used to endorse or promote products
  44:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *    derived from this software without specific prior written permission.
  45:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
  46:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
  47:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  48:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
  49:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  50:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
  51:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  52:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  53:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
  54:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  55:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * OF SUCH DAMAGE.
  56:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
  57:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * This file is part of the lwIP TCP/IP stack.
  58:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
  59:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Author: Adam Dunkels <adam@sics.se>
  60:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
  61:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
  62:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
  63:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #include "ETH_LWIP/lwip/include/lwip/opt.h"
  64:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
  65:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if LWIP_TCP /* don't build if not configured for use in lwipopts.h */
  66:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
  67:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #include "ETH_LWIP/lwip/include/lwip/priv/tcp_priv.h"
  68:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #include "ETH_LWIP/lwip/include/lwip/def.h"
  69:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #include "ETH_LWIP/lwip/include/lwip/mem.h"
  70:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #include "ETH_LWIP/lwip/include/lwip/memp.h"
  71:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #include "ETH_LWIP/lwip/include/lwip/ip_addr.h"
  72:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #include "ETH_LWIP/lwip/include/lwip/netif.h"
  73:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #include "ETH_LWIP/lwip/include/lwip/inet_chksum.h"
  74:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #include "ETH_LWIP/lwip/include/lwip/stats.h"
  75:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #include "ETH_LWIP/lwip/include/lwip/ip6.h"
  76:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #include "ETH_LWIP/lwip/include/lwip/ip6_addr.h"
  77:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if LWIP_TCP_TIMESTAMPS
  78:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #include "ETH_LWIP/lwip/include/lwip/sys.h"
  79:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
  80:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
  81:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #include <string.h>
  82:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
  83:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #ifdef LWIP_HOOK_FILENAME
  84:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #include LWIP_HOOK_FILENAME
  85:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
  86:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
  87:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /* Allow to add custom TCP header options by defining this hook */
  88:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #ifdef LWIP_HOOK_TCP_OUT_TCPOPT_LENGTH
  89:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #define LWIP_TCP_OPT_LENGTH_SEGMENT(flags, pcb) LWIP_HOOK_TCP_OUT_TCPOPT_LENGTH(pcb, LWIP_TCP_OPT_L
  90:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #else
  91:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #define LWIP_TCP_OPT_LENGTH_SEGMENT(flags, pcb) LWIP_TCP_OPT_LENGTH(flags)
  92:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
  93:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
  94:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /* Define some copy-macros for checksum-on-copy so that the code looks
  95:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    nicer by preventing too many ifdef's. */
  96:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
  97:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #define TCP_DATA_COPY(dst, src, len, seg) do { \
  98:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   tcp_seg_add_chksum(LWIP_CHKSUM_COPY(dst, src, len), \
  99:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                      len, &seg->chksum, &seg->chksum_swapped); \
 100:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->flags |= TF_SEG_DATA_CHECKSUMMED; } while(0)
 101:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #define TCP_DATA_COPY2(dst, src, len, chksum, chksum_swapped)  \
 102:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   tcp_seg_add_chksum(LWIP_CHKSUM_COPY(dst, src, len), len, chksum, chksum_swapped);
 103:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #else /* TCP_CHECKSUM_ON_COPY*/
 104:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #define TCP_DATA_COPY(dst, src, len, seg)                     MEMCPY(dst, src, len)
 105:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #define TCP_DATA_COPY2(dst, src, len, chksum, chksum_swapped) MEMCPY(dst, src, len)
 106:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY*/
 107:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 108:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /** Define this to 1 for an extra check that the output checksum is valid
 109:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * (usefule when the checksum is generated by the application, not the stack) */
 110:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #ifndef TCP_CHECKSUM_ON_COPY_SANITY_CHECK
 111:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #define TCP_CHECKSUM_ON_COPY_SANITY_CHECK   0
 112:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
 113:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /* Allow to override the failure of sanity check from warning to e.g. hard failure */
 114:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
 115:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #ifndef TCP_CHECKSUM_ON_COPY_SANITY_CHECK_FAIL
 116:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #define TCP_CHECKSUM_ON_COPY_SANITY_CHECK_FAIL(msg) LWIP_DEBUGF(TCP_DEBUG | LWIP_DBG_LEVEL_WARNING,
 117:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
 118:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
 119:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 120:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_OVERSIZE
 121:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /** The size of segment pbufs created when TCP_OVERSIZE is enabled */
 122:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #ifndef TCP_OVERSIZE_CALC_LENGTH
 123:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #define TCP_OVERSIZE_CALC_LENGTH(length) ((length) + TCP_OVERSIZE)
 124:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
 125:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
 126:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 127:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /* Forward declarations.*/
 128:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** static err_t tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb, struct netif *netif);
 129:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 130:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /* tcp_route: common code that returns a fixed bound netif or calls ip_route */
 131:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** static struct netif *
 132:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_route(const struct tcp_pcb *pcb, const ip_addr_t *src, const ip_addr_t *dst)
 133:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
  27              	 .loc 1 133 0
  28              	 .cfi_startproc
  29              	 
  30              	 
  31 0000 80B5     	 push {r7,lr}
  32              	.LCFI0:
  33              	 .cfi_def_cfa_offset 8
  34              	 .cfi_offset 7,-8
  35              	 .cfi_offset 14,-4
  36 0002 84B0     	 sub sp,sp,#16
  37              	.LCFI1:
  38              	 .cfi_def_cfa_offset 24
  39 0004 00AF     	 add r7,sp,#0
  40              	.LCFI2:
  41              	 .cfi_def_cfa_register 7
  42 0006 F860     	 str r0,[r7,#12]
  43 0008 B960     	 str r1,[r7,#8]
  44 000a 7A60     	 str r2,[r7,#4]
 134:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_UNUSED_ARG(src); /* in case IPv4-only and source-based routing is disabled */
 135:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 136:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if ((pcb != NULL) && (pcb->netif_idx != NETIF_NO_INDEX)) {
  45              	 .loc 1 136 0
  46 000c FB68     	 ldr r3,[r7,#12]
  47 000e 002B     	 cmp r3,#0
  48 0010 0AD0     	 beq .L2
  49              	 .loc 1 136 0 is_stmt 0 discriminator 1
  50 0012 FB68     	 ldr r3,[r7,#12]
  51 0014 1B7A     	 ldrb r3,[r3,#8]
  52 0016 002B     	 cmp r3,#0
  53 0018 06D0     	 beq .L2
 137:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return netif_get_by_index(pcb->netif_idx);
  54              	 .loc 1 137 0 is_stmt 1
  55 001a FB68     	 ldr r3,[r7,#12]
  56 001c 1B7A     	 ldrb r3,[r3,#8]
  57 001e 1846     	 mov r0,r3
  58 0020 FFF7FEFF 	 bl netif_get_by_index
  59 0024 0346     	 mov r3,r0
  60 0026 03E0     	 b .L3
  61              	.L2:
 138:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   } else {
 139:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return ip_route(src, dst);
  62              	 .loc 1 139 0
  63 0028 7868     	 ldr r0,[r7,#4]
  64 002a FFF7FEFF 	 bl ip4_route
  65 002e 0346     	 mov r3,r0
  66              	.L3:
 140:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 141:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
  67              	 .loc 1 141 0
  68 0030 1846     	 mov r0,r3
  69 0032 1037     	 adds r7,r7,#16
  70              	.LCFI3:
  71              	 .cfi_def_cfa_offset 8
  72 0034 BD46     	 mov sp,r7
  73              	.LCFI4:
  74              	 .cfi_def_cfa_register 13
  75              	 
  76 0036 80BD     	 pop {r7,pc}
  77              	 .cfi_endproc
  78              	.LFE133:
  80              	 .section .text.tcp_create_segment,"ax",%progbits
  81              	 .align 2
  82              	 .thumb
  83              	 .thumb_func
  85              	tcp_create_segment:
  86              	.LFB134:
 142:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 143:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /**
 144:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Create a TCP segment with prefilled header.
 145:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
 146:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Called by @ref tcp_write, @ref tcp_enqueue_flags and @ref tcp_split_unsent_seg
 147:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
 148:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb Protocol control block for the TCP connection.
 149:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param p pbuf that is used to hold the TCP header.
 150:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param hdrflags TCP flags for header.
 151:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param seqno TCP sequence number of this packet
 152:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param optflags options to include in TCP header
 153:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @return a new tcp_seg pointing to p, or NULL.
 154:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * The TCP header is filled in except ackno and wnd.
 155:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * p is freed on failure.
 156:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
 157:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** static struct tcp_seg *
 158:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_create_segment(const struct tcp_pcb *pcb, struct pbuf *p, u8_t hdrflags, u32_t seqno, u8_t optf
 159:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
  87              	 .loc 1 159 0
  88              	 .cfi_startproc
  89              	 
  90              	 
  91 0000 90B5     	 push {r4,r7,lr}
  92              	.LCFI5:
  93              	 .cfi_def_cfa_offset 12
  94              	 .cfi_offset 4,-12
  95              	 .cfi_offset 7,-8
  96              	 .cfi_offset 14,-4
  97 0002 87B0     	 sub sp,sp,#28
  98              	.LCFI6:
  99              	 .cfi_def_cfa_offset 40
 100 0004 00AF     	 add r7,sp,#0
 101              	.LCFI7:
 102              	 .cfi_def_cfa_register 7
 103 0006 F860     	 str r0,[r7,#12]
 104 0008 B960     	 str r1,[r7,#8]
 105 000a 3B60     	 str r3,[r7]
 106 000c 1346     	 mov r3,r2
 107 000e FB71     	 strb r3,[r7,#7]
 160:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct tcp_seg *seg;
 161:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u8_t optlen;
 162:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 163:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_create_segment: invalid pcb", pcb != NULL);
 164:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_create_segment: invalid pbuf", p != NULL);
 165:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 166:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 108              	 .loc 1 166 0
 109 0010 97F82830 	 ldrb r3,[r7,#40]
 110 0014 03F00103 	 and r3,r3,#1
 111 0018 002B     	 cmp r3,#0
 112 001a 01D0     	 beq .L5
 113              	 .loc 1 166 0 is_stmt 0 discriminator 1
 114 001c 0423     	 movs r3,#4
 115 001e 00E0     	 b .L6
 116              	.L5:
 117              	 .loc 1 166 0 discriminator 2
 118 0020 0023     	 movs r3,#0
 119              	.L6:
 120              	 .loc 1 166 0 discriminator 4
 121 0022 FB75     	 strb r3,[r7,#23]
 167:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 168:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 122              	 .loc 1 168 0 is_stmt 1 discriminator 4
 123 0024 0320     	 movs r0,#3
 124 0026 FFF7FEFF 	 bl memp_malloc
 125 002a 3861     	 str r0,[r7,#16]
 126 002c 3B69     	 ldr r3,[r7,#16]
 127 002e 002B     	 cmp r3,#0
 128 0030 04D1     	 bne .L7
 169:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no memory.\n"));
 170:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     pbuf_free(p);
 129              	 .loc 1 170 0
 130 0032 B868     	 ldr r0,[r7,#8]
 131 0034 FFF7FEFF 	 bl pbuf_free
 171:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return NULL;
 132              	 .loc 1 171 0
 133 0038 0023     	 movs r3,#0
 134 003a 55E0     	 b .L8
 135              	.L7:
 172:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 173:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->flags = optflags;
 136              	 .loc 1 173 0
 137 003c 3B69     	 ldr r3,[r7,#16]
 138 003e 97F82820 	 ldrb r2,[r7,#40]
 139 0042 9A72     	 strb r2,[r3,#10]
 174:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->next = NULL;
 140              	 .loc 1 174 0
 141 0044 3B69     	 ldr r3,[r7,#16]
 142 0046 0022     	 movs r2,#0
 143 0048 1A60     	 str r2,[r3]
 175:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->p = p;
 144              	 .loc 1 175 0
 145 004a 3B69     	 ldr r3,[r7,#16]
 146 004c BA68     	 ldr r2,[r7,#8]
 147 004e 5A60     	 str r2,[r3,#4]
 176:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
 177:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->len = p->tot_len - optlen;
 148              	 .loc 1 177 0
 149 0050 BB68     	 ldr r3,[r7,#8]
 150 0052 1A89     	 ldrh r2,[r3,#8]
 151 0054 FB7D     	 ldrb r3,[r7,#23]
 152 0056 9BB2     	 uxth r3,r3
 153 0058 D31A     	 subs r3,r2,r3
 154 005a 9AB2     	 uxth r2,r3
 155 005c 3B69     	 ldr r3,[r7,#16]
 156 005e 1A81     	 strh r2,[r3,#8]
 178:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_OVERSIZE_DBGCHECK
 179:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->oversize_left = 0;
 180:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_OVERSIZE_DBGCHECK */
 181:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 182:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->chksum = 0;
 183:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->chksum_swapped = 0;
 184:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* check optflags */
 185:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
 186:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****               (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
 187:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 188:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 189:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* build TCP header */
 190:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pbuf_add_header(p, TCP_HLEN)) {
 157              	 .loc 1 190 0
 158 0060 B868     	 ldr r0,[r7,#8]
 159 0062 1421     	 movs r1,#20
 160 0064 FFF7FEFF 	 bl pbuf_add_header
 161 0068 0346     	 mov r3,r0
 162 006a 002B     	 cmp r3,#0
 163 006c 04D0     	 beq .L9
 191:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no room for TCP he
 192:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     TCP_STATS_INC(tcp.err);
 193:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcp_seg_free(seg);
 164              	 .loc 1 193 0
 165 006e 3869     	 ldr r0,[r7,#16]
 166 0070 FFF7FEFF 	 bl tcp_seg_free
 194:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return NULL;
 167              	 .loc 1 194 0
 168 0074 0023     	 movs r3,#0
 169 0076 37E0     	 b .L8
 170              	.L9:
 195:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 196:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 171              	 .loc 1 196 0
 172 0078 3B69     	 ldr r3,[r7,#16]
 173 007a 5B68     	 ldr r3,[r3,#4]
 174 007c 5A68     	 ldr r2,[r3,#4]
 175 007e 3B69     	 ldr r3,[r7,#16]
 176 0080 DA60     	 str r2,[r3,#12]
 197:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->tcphdr->src = lwip_htons(pcb->local_port);
 177              	 .loc 1 197 0
 178 0082 3B69     	 ldr r3,[r7,#16]
 179 0084 DC68     	 ldr r4,[r3,#12]
 180 0086 FB68     	 ldr r3,[r7,#12]
 181 0088 DB8A     	 ldrh r3,[r3,#22]
 182 008a 1846     	 mov r0,r3
 183 008c FFF7FEFF 	 bl lwip_htons
 184 0090 0346     	 mov r3,r0
 185 0092 2380     	 strh r3,[r4]
 198:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->tcphdr->dest = lwip_htons(pcb->remote_port);
 186              	 .loc 1 198 0
 187 0094 3B69     	 ldr r3,[r7,#16]
 188 0096 DC68     	 ldr r4,[r3,#12]
 189 0098 FB68     	 ldr r3,[r7,#12]
 190 009a 1B8B     	 ldrh r3,[r3,#24]
 191 009c 1846     	 mov r0,r3
 192 009e FFF7FEFF 	 bl lwip_htons
 193 00a2 0346     	 mov r3,r0
 194 00a4 6380     	 strh r3,[r4,#2]
 199:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->tcphdr->seqno = lwip_htonl(seqno);
 195              	 .loc 1 199 0
 196 00a6 3B69     	 ldr r3,[r7,#16]
 197 00a8 DC68     	 ldr r4,[r3,#12]
 198 00aa 3868     	 ldr r0,[r7]
 199 00ac FFF7FEFF 	 bl lwip_htonl
 200 00b0 0346     	 mov r3,r0
 201 00b2 6360     	 str r3,[r4,#4]
 200:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* ackno is set in tcp_output */
 201:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), hdrflags);
 202              	 .loc 1 201 0
 203 00b4 3B69     	 ldr r3,[r7,#16]
 204 00b6 DC68     	 ldr r4,[r3,#12]
 205 00b8 FB7D     	 ldrb r3,[r7,#23]
 206 00ba 9B08     	 lsrs r3,r3,#2
 207 00bc DBB2     	 uxtb r3,r3
 208 00be 9BB2     	 uxth r3,r3
 209 00c0 0533     	 adds r3,r3,#5
 210 00c2 9BB2     	 uxth r3,r3
 211 00c4 1B03     	 lsls r3,r3,#12
 212 00c6 9AB2     	 uxth r2,r3
 213 00c8 FB79     	 ldrb r3,[r7,#7]
 214 00ca 9BB2     	 uxth r3,r3
 215 00cc 1343     	 orrs r3,r3,r2
 216 00ce 9BB2     	 uxth r3,r3
 217 00d0 1846     	 mov r0,r3
 218 00d2 FFF7FEFF 	 bl lwip_htons
 219 00d6 0346     	 mov r3,r0
 220 00d8 A381     	 strh r3,[r4,#12]
 202:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* wnd and chksum are set in tcp_output */
 203:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->tcphdr->urgp = 0;
 221              	 .loc 1 203 0
 222 00da 3B69     	 ldr r3,[r7,#16]
 223 00dc DB68     	 ldr r3,[r3,#12]
 224 00de 0022     	 movs r2,#0
 225 00e0 9A74     	 strb r2,[r3,#18]
 226 00e2 0022     	 movs r2,#0
 227 00e4 DA74     	 strb r2,[r3,#19]
 204:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   return seg;
 228              	 .loc 1 204 0
 229 00e6 3B69     	 ldr r3,[r7,#16]
 230              	.L8:
 205:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 231              	 .loc 1 205 0
 232 00e8 1846     	 mov r0,r3
 233 00ea 1C37     	 adds r7,r7,#28
 234              	.LCFI8:
 235              	 .cfi_def_cfa_offset 12
 236 00ec BD46     	 mov sp,r7
 237              	.LCFI9:
 238              	 .cfi_def_cfa_register 13
 239              	 
 240 00ee 90BD     	 pop {r4,r7,pc}
 241              	 .cfi_endproc
 242              	.LFE134:
 244              	 .section .text.tcp_pbuf_prealloc,"ax",%progbits
 245              	 .align 2
 246              	 .thumb
 247              	 .thumb_func
 249              	tcp_pbuf_prealloc:
 250              	.LFB135:
 206:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 207:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /**
 208:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Allocate a PBUF_RAM pbuf, perhaps with extra space at the end.
 209:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
 210:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * This function is like pbuf_alloc(layer, length, PBUF_RAM) except
 211:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * there may be extra bytes available at the end.
 212:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
 213:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Called by @ref tcp_write
 214:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
 215:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param layer flag to define header size.
 216:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param length size of the pbuf's payload.
 217:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param max_length maximum usable size of payload+oversize.
 218:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param oversize pointer to a u16_t that will receive the number of usable tail bytes.
 219:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb The TCP connection that will enqueue the pbuf.
 220:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param apiflags API flags given to tcp_write.
 221:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param first_seg true when this pbuf will be used in the first enqueued segment.
 222:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
 223:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_OVERSIZE
 224:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** static struct pbuf *
 225:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
 226:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                   u16_t *oversize, const struct tcp_pcb *pcb, u8_t apiflags,
 227:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                   u8_t first_seg)
 228:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 251              	 .loc 1 228 0
 252              	 .cfi_startproc
 253              	 
 254              	 
 255 0000 80B5     	 push {r7,lr}
 256              	.LCFI10:
 257              	 .cfi_def_cfa_offset 8
 258              	 .cfi_offset 7,-8
 259              	 .cfi_offset 14,-4
 260 0002 86B0     	 sub sp,sp,#24
 261              	.LCFI11:
 262              	 .cfi_def_cfa_offset 32
 263 0004 00AF     	 add r7,sp,#0
 264              	.LCFI12:
 265              	 .cfi_def_cfa_register 7
 266 0006 7B60     	 str r3,[r7,#4]
 267 0008 0346     	 mov r3,r0
 268 000a FB73     	 strb r3,[r7,#15]
 269 000c 0B46     	 mov r3,r1
 270 000e BB81     	 strh r3,[r7,#12]
 271 0010 1346     	 mov r3,r2
 272 0012 7B81     	 strh r3,[r7,#10]
 229:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct pbuf *p;
 230:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u16_t alloc = length;
 273              	 .loc 1 230 0
 274 0014 BB89     	 ldrh r3,[r7,#12]
 275 0016 FB82     	 strh r3,[r7,#22]
 231:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 232:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_pbuf_prealloc: invalid oversize", oversize != NULL);
 233:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_pbuf_prealloc: invalid pcb", pcb != NULL);
 234:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 235:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if LWIP_NETIF_TX_SINGLE_PBUF
 236:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_UNUSED_ARG(max_length);
 237:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_UNUSED_ARG(pcb);
 238:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_UNUSED_ARG(apiflags);
 239:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_UNUSED_ARG(first_seg);
 240:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   alloc = max_length;
 241:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #else /* LWIP_NETIF_TX_SINGLE_PBUF */
 242:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (length < max_length) {
 276              	 .loc 1 242 0
 277 0018 BA89     	 ldrh r2,[r7,#12]
 278 001a 7B89     	 ldrh r3,[r7,#10]
 279 001c 9A42     	 cmp r2,r3
 280 001e 21D2     	 bcs .L11
 243:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* Should we allocate an oversized pbuf, or just the minimum
 244:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * length required? If tcp_write is going to be called again
 245:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * before this segment is transmitted, we want the oversized
 246:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * buffer. If the segment will be transmitted immediately, we can
 247:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * save memory by allocating only length. We use a simple
 248:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * heuristic based on the following information:
 249:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      *
 250:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * Did the user set TCP_WRITE_FLAG_MORE?
 251:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      *
 252:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * Will the Nagle algorithm defer transmission of this segment?
 253:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      */
 254:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 281              	 .loc 1 254 0
 282 0020 97F82430 	 ldrb r3,[r7,#36]
 283 0024 03F00203 	 and r3,r3,#2
 284 0028 002B     	 cmp r3,#0
 285 002a 11D1     	 bne .L12
 255:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         (!(pcb->flags & TF_NODELAY) &&
 286              	 .loc 1 255 0 discriminator 1
 287 002c 3B6A     	 ldr r3,[r7,#32]
 288 002e 5B8B     	 ldrh r3,[r3,#26]
 289 0030 03F04003 	 and r3,r3,#64
 254:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         (!(pcb->flags & TF_NODELAY) &&
 290              	 .loc 1 254 0 discriminator 1
 291 0034 002B     	 cmp r3,#0
 292 0036 15D1     	 bne .L11
 293              	 .loc 1 255 0
 294 0038 97F82830 	 ldrb r3,[r7,#40]
 295 003c 002B     	 cmp r3,#0
 296 003e 07D0     	 beq .L12
 256:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****          (!first_seg ||
 257:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           pcb->unsent != NULL ||
 297              	 .loc 1 257 0
 298 0040 3B6A     	 ldr r3,[r7,#32]
 299 0042 DB6E     	 ldr r3,[r3,#108]
 256:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****          (!first_seg ||
 300              	 .loc 1 256 0
 301 0044 002B     	 cmp r3,#0
 302 0046 03D1     	 bne .L12
 258:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           pcb->unacked != NULL))) {
 303              	 .loc 1 258 0
 304 0048 3B6A     	 ldr r3,[r7,#32]
 305 004a 1B6F     	 ldr r3,[r3,#112]
 257:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           pcb->unacked != NULL))) {
 306              	 .loc 1 257 0
 307 004c 002B     	 cmp r3,#0
 308 004e 09D0     	 beq .L11
 309              	.L12:
 259:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(TCP_OVERSIZE_CALC_LENGTH(length)));
 310              	 .loc 1 259 0
 311 0050 BB89     	 ldrh r3,[r7,#12]
 312 0052 03F21B23 	 addw r3,r3,#539
 313 0056 23F00302 	 bic r2,r3,#3
 314 005a 7B89     	 ldrh r3,[r7,#10]
 315 005c 9342     	 cmp r3,r2
 316 005e 28BF     	 it cs
 317 0060 1346     	 movcs r3,r2
 318 0062 FB82     	 strh r3,[r7,#22]
 319              	.L11:
 260:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
 261:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 262:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
 263:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   p = pbuf_alloc(layer, alloc, PBUF_RAM);
 320              	 .loc 1 263 0
 321 0064 FA7B     	 ldrb r2,[r7,#15]
 322 0066 FB8A     	 ldrh r3,[r7,#22]
 323 0068 1046     	 mov r0,r2
 324 006a 1946     	 mov r1,r3
 325 006c 4FF42072 	 mov r2,#640
 326 0070 FFF7FEFF 	 bl pbuf_alloc
 327 0074 3861     	 str r0,[r7,#16]
 264:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (p == NULL) {
 328              	 .loc 1 264 0
 329 0076 3B69     	 ldr r3,[r7,#16]
 330 0078 002B     	 cmp r3,#0
 331 007a 01D1     	 bne .L13
 265:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return NULL;
 332              	 .loc 1 265 0
 333 007c 0023     	 movs r3,#0
 334 007e 0EE0     	 b .L14
 335              	.L13:
 266:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 267:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("need unchained pbuf", p->next == NULL);
 268:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   *oversize = p->len - length;
 336              	 .loc 1 268 0
 337 0080 3B69     	 ldr r3,[r7,#16]
 338 0082 5A89     	 ldrh r2,[r3,#10]
 339 0084 BB89     	 ldrh r3,[r7,#12]
 340 0086 D31A     	 subs r3,r2,r3
 341 0088 9AB2     	 uxth r2,r3
 342 008a 7B68     	 ldr r3,[r7,#4]
 343 008c 1A80     	 strh r2,[r3]
 269:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* trim p->len to the currently used size */
 270:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   p->len = p->tot_len = length;
 344              	 .loc 1 270 0
 345 008e 3B69     	 ldr r3,[r7,#16]
 346 0090 BA89     	 ldrh r2,[r7,#12]
 347 0092 1A81     	 strh r2,[r3,#8]
 348 0094 3B69     	 ldr r3,[r7,#16]
 349 0096 1A89     	 ldrh r2,[r3,#8]
 350 0098 3B69     	 ldr r3,[r7,#16]
 351 009a 5A81     	 strh r2,[r3,#10]
 271:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   return p;
 352              	 .loc 1 271 0
 353 009c 3B69     	 ldr r3,[r7,#16]
 354              	.L14:
 272:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 355              	 .loc 1 272 0
 356 009e 1846     	 mov r0,r3
 357 00a0 1837     	 adds r7,r7,#24
 358              	.LCFI13:
 359              	 .cfi_def_cfa_offset 8
 360 00a2 BD46     	 mov sp,r7
 361              	.LCFI14:
 362              	 .cfi_def_cfa_register 13
 363              	 
 364 00a4 80BD     	 pop {r7,pc}
 365              	 .cfi_endproc
 366              	.LFE135:
 368 00a6 00BF     	 .section .text.tcp_write_checks,"ax",%progbits
 369              	 .align 2
 370              	 .thumb
 371              	 .thumb_func
 373              	tcp_write_checks:
 374              	.LFB136:
 273:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #else /* TCP_OVERSIZE */
 274:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #define tcp_pbuf_prealloc(layer, length, mx, os, pcb, api, fst) pbuf_alloc((layer), (length), PBUF_
 275:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_OVERSIZE */
 276:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 277:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 278:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /** Add a checksum of newly added data to the segment.
 279:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
 280:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Called by tcp_write and tcp_split_unsent_seg.
 281:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
 282:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** static void
 283:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_seg_add_chksum(u16_t chksum, u16_t len, u16_t *seg_chksum,
 284:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                    u8_t *seg_chksum_swapped)
 285:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 286:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u32_t helper;
 287:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* add chksum to old chksum and fold to u16_t */
 288:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   helper = chksum + *seg_chksum;
 289:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   chksum = FOLD_U32T(helper);
 290:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if ((len & 1) != 0) {
 291:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     *seg_chksum_swapped = 1 - *seg_chksum_swapped;
 292:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     chksum = SWAP_BYTES_IN_WORD(chksum);
 293:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 294:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   *seg_chksum = chksum;
 295:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 296:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 297:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 298:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /** Checks if tcp_write is allowed or not (checks state, snd_buf and snd_queuelen).
 299:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
 300:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb the tcp pcb to check for
 301:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param len length of data to send (checked agains snd_buf)
 302:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
 303:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
 304:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** static err_t
 305:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
 306:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 375              	 .loc 1 306 0
 376              	 .cfi_startproc
 377              	 
 378              	 
 379              	 
 380 0000 80B4     	 push {r7}
 381              	.LCFI15:
 382              	 .cfi_def_cfa_offset 4
 383              	 .cfi_offset 7,-4
 384 0002 83B0     	 sub sp,sp,#12
 385              	.LCFI16:
 386              	 .cfi_def_cfa_offset 16
 387 0004 00AF     	 add r7,sp,#0
 388              	.LCFI17:
 389              	 .cfi_def_cfa_register 7
 390 0006 7860     	 str r0,[r7,#4]
 391 0008 0B46     	 mov r3,r1
 392 000a 7B80     	 strh r3,[r7,#2]
 307:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_write_checks: invalid pcb", pcb != NULL);
 308:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 309:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* connection is in invalid state for data transmission? */
 310:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if ((pcb->state != ESTABLISHED) &&
 393              	 .loc 1 310 0
 394 000c 7B68     	 ldr r3,[r7,#4]
 395 000e 1B7D     	 ldrb r3,[r3,#20]
 396 0010 042B     	 cmp r3,#4
 397 0012 0DD0     	 beq .L16
 311:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       (pcb->state != CLOSE_WAIT) &&
 398              	 .loc 1 311 0 discriminator 1
 399 0014 7B68     	 ldr r3,[r7,#4]
 400 0016 1B7D     	 ldrb r3,[r3,#20]
 310:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       (pcb->state != CLOSE_WAIT) &&
 401              	 .loc 1 310 0 discriminator 1
 402 0018 072B     	 cmp r3,#7
 403 001a 09D0     	 beq .L16
 312:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       (pcb->state != SYN_SENT) &&
 404              	 .loc 1 312 0
 405 001c 7B68     	 ldr r3,[r7,#4]
 406 001e 1B7D     	 ldrb r3,[r3,#20]
 311:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       (pcb->state != CLOSE_WAIT) &&
 407              	 .loc 1 311 0
 408 0020 022B     	 cmp r3,#2
 409 0022 05D0     	 beq .L16
 313:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       (pcb->state != SYN_RCVD)) {
 410              	 .loc 1 313 0
 411 0024 7B68     	 ldr r3,[r7,#4]
 412 0026 1B7D     	 ldrb r3,[r3,#20]
 312:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       (pcb->state != SYN_SENT) &&
 413              	 .loc 1 312 0
 414 0028 032B     	 cmp r3,#3
 415 002a 01D0     	 beq .L16
 314:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in 
 315:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return ERR_CONN;
 416              	 .loc 1 315 0
 417 002c F523     	 movs r3,#245
 418 002e 22E0     	 b .L17
 419              	.L16:
 316:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   } else if (len == 0) {
 420              	 .loc 1 316 0
 421 0030 7B88     	 ldrh r3,[r7,#2]
 422 0032 002B     	 cmp r3,#0
 423 0034 01D1     	 bne .L18
 317:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return ERR_OK;
 424              	 .loc 1 317 0
 425 0036 0023     	 movs r3,#0
 426 0038 1DE0     	 b .L17
 427              	.L18:
 318:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 319:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 320:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* fail on too much data */
 321:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (len > pcb->snd_buf) {
 428              	 .loc 1 321 0
 429 003a 7B68     	 ldr r3,[r7,#4]
 430 003c B3F86430 	 ldrh r3,[r3,#100]
 431 0040 7A88     	 ldrh r2,[r7,#2]
 432 0042 9A42     	 cmp r2,r3
 433 0044 08D9     	 bls .L19
 322:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too much data (len=%"U16_F" 
 323:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 len, pcb->snd_buf));
 324:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcp_set_flags(pcb, TF_NAGLEMEMERR);
 434              	 .loc 1 324 0
 435 0046 7B68     	 ldr r3,[r7,#4]
 436 0048 5B8B     	 ldrh r3,[r3,#26]
 437 004a 43F08003 	 orr r3,r3,#128
 438 004e 9AB2     	 uxth r2,r3
 439 0050 7B68     	 ldr r3,[r7,#4]
 440 0052 5A83     	 strh r2,[r3,#26]
 325:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return ERR_MEM;
 441              	 .loc 1 325 0
 442 0054 FF23     	 movs r3,#255
 443 0056 0EE0     	 b .L17
 444              	.L19:
 326:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 327:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 328:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_qu
 329:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 330:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* If total number of pbufs on the unsent/unacked queues exceeds the
 331:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * configured maximum, return an error */
 332:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* check for configured max queuelen and possible overflow */
 333:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pcb->snd_queuelen >= LWIP_MIN(TCP_SND_QUEUELEN, (TCP_SNDQUEUELEN_OVERFLOW + 1))) {
 445              	 .loc 1 333 0
 446 0058 7B68     	 ldr r3,[r7,#4]
 447 005a B3F86630 	 ldrh r3,[r3,#102]
 448 005e 072B     	 cmp r3,#7
 449 0060 08D9     	 bls .L20
 334:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too long queue %"U16_F" (max
 335:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 pcb->snd_queuelen, (u16_t)TCP_SND_QUEUELEN));
 336:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     TCP_STATS_INC(tcp.memerr);
 337:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcp_set_flags(pcb, TF_NAGLEMEMERR);
 450              	 .loc 1 337 0
 451 0062 7B68     	 ldr r3,[r7,#4]
 452 0064 5B8B     	 ldrh r3,[r3,#26]
 453 0066 43F08003 	 orr r3,r3,#128
 454 006a 9AB2     	 uxth r2,r3
 455 006c 7B68     	 ldr r3,[r7,#4]
 456 006e 5A83     	 strh r2,[r3,#26]
 338:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return ERR_MEM;
 457              	 .loc 1 338 0
 458 0070 FF23     	 movs r3,#255
 459 0072 00E0     	 b .L17
 460              	.L20:
 339:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 340:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pcb->snd_queuelen != 0) {
 341:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 342:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 pcb->unacked != NULL || pcb->unsent != NULL);
 343:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   } else {
 344:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
 345:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 pcb->unacked == NULL && pcb->unsent == NULL);
 346:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 347:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   return ERR_OK;
 461              	 .loc 1 347 0
 462 0074 0023     	 movs r3,#0
 463              	.L17:
 464 0076 5BB2     	 sxtb r3,r3
 348:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 465              	 .loc 1 348 0
 466 0078 1846     	 mov r0,r3
 467 007a 0C37     	 adds r7,r7,#12
 468              	.LCFI18:
 469              	 .cfi_def_cfa_offset 4
 470 007c BD46     	 mov sp,r7
 471              	.LCFI19:
 472              	 .cfi_def_cfa_register 13
 473              	 
 474 007e 5DF8047B 	 ldr r7,[sp],#4
 475              	.LCFI20:
 476              	 .cfi_restore 7
 477              	 .cfi_def_cfa_offset 0
 478 0082 7047     	 bx lr
 479              	 .cfi_endproc
 480              	.LFE136:
 482              	 .section .text.tcp_write,"ax",%progbits
 483              	 .align 2
 484              	 .global tcp_write
 485              	 .thumb
 486              	 .thumb_func
 488              	tcp_write:
 489              	.LFB137:
 349:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 350:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /**
 351:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @ingroup tcp_raw
 352:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Write data for sending (but does not send it immediately).
 353:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
 354:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * It waits in the expectation of more data being sent soon (as
 355:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * it can send them more efficiently by combining them together).
 356:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * To prompt the system to send data now, call tcp_output() after
 357:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * calling tcp_write().
 358:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * 
 359:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * This function enqueues the data pointed to by the argument dataptr. The length of
 360:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * the data is passed as the len parameter. The apiflags can be one or more of:
 361:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * - TCP_WRITE_FLAG_COPY: indicates whether the new memory should be allocated
 362:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   for the data to be copied into. If this flag is not given, no new memory
 363:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   should be allocated and the data should only be referenced by pointer. This
 364:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   also means that the memory behind dataptr must not change until the data is
 365:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   ACKed by the remote host
 366:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * - TCP_WRITE_FLAG_MORE: indicates that more data follows. If this is omitted,
 367:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   the PSH flag is set in the last segment created by this call to tcp_write.
 368:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *   If this flag is given, the PSH flag is not set.
 369:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
 370:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * The tcp_write() function will fail and return ERR_MEM if the length
 371:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * of the data exceeds the current send buffer size or if the length of
 372:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * the queue of outgoing segment is larger than the upper limit defined
 373:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * in lwipopts.h. The number of bytes available in the output queue can
 374:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * be retrieved with the tcp_sndbuf() function.
 375:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
 376:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * The proper way to use this function is to call the function with at
 377:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * most tcp_sndbuf() bytes of data. If the function returns ERR_MEM,
 378:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * the application should wait until some of the currently enqueued
 379:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * data has been successfully received by the other host and try again.
 380:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
 381:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb Protocol control block for the TCP connection to enqueue data for.
 382:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param arg Pointer to the data to be enqueued for sending.
 383:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param len Data length in bytes
 384:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param apiflags combination of following flags :
 385:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * - TCP_WRITE_FLAG_COPY (0x01) data will be copied into memory belonging to the stack
 386:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will not be set on last segment sent,
 387:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @return ERR_OK if enqueued, another err_t on error
 388:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
 389:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** err_t
 390:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
 391:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 490              	 .loc 1 391 0
 491              	 .cfi_startproc
 492              	 
 493              	 
 494 0000 B0B5     	 push {r4,r5,r7,lr}
 495              	.LCFI21:
 496              	 .cfi_def_cfa_offset 16
 497              	 .cfi_offset 4,-16
 498              	 .cfi_offset 5,-12
 499              	 .cfi_offset 7,-8
 500              	 .cfi_offset 14,-4
 501 0002 9AB0     	 sub sp,sp,#104
 502              	.LCFI22:
 503              	 .cfi_def_cfa_offset 120
 504 0004 04AF     	 add r7,sp,#16
 505              	.LCFI23:
 506              	 .cfi_def_cfa 7,104
 507 0006 F860     	 str r0,[r7,#12]
 508 0008 B960     	 str r1,[r7,#8]
 509 000a 1146     	 mov r1,r2
 510 000c 1A46     	 mov r2,r3
 511 000e 0B46     	 mov r3,r1
 512 0010 FB80     	 strh r3,[r7,#6]
 513 0012 1346     	 mov r3,r2
 514 0014 7B71     	 strb r3,[r7,#5]
 392:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct pbuf *concat_p = NULL;
 515              	 .loc 1 392 0
 516 0016 0023     	 movs r3,#0
 517 0018 7B65     	 str r3,[r7,#84]
 393:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 518              	 .loc 1 393 0
 519 001a 0023     	 movs r3,#0
 520 001c 3B65     	 str r3,[r7,#80]
 521 001e 0023     	 movs r3,#0
 522 0020 FB64     	 str r3,[r7,#76]
 523 0022 0023     	 movs r3,#0
 524 0024 BB64     	 str r3,[r7,#72]
 525 0026 0023     	 movs r3,#0
 526 0028 7B64     	 str r3,[r7,#68]
 394:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u16_t pos = 0; /* position in 'arg' data */
 527              	 .loc 1 394 0
 528 002a 0023     	 movs r3,#0
 529 002c A7F84230 	 strh r3,[r7,#66]
 395:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u16_t queuelen;
 396:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u8_t optlen;
 397:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u8_t optflags = 0;
 530              	 .loc 1 397 0
 531 0030 0023     	 movs r3,#0
 532 0032 87F82730 	 strb r3,[r7,#39]
 398:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_OVERSIZE
 399:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u16_t oversize = 0;
 533              	 .loc 1 399 0
 534 0036 0023     	 movs r3,#0
 535 0038 7B82     	 strh r3,[r7,#18]
 400:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u16_t oversize_used = 0;
 536              	 .loc 1 400 0
 537 003a 0023     	 movs r3,#0
 538 003c FB87     	 strh r3,[r7,#62]
 401:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_OVERSIZE_DBGCHECK
 402:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u16_t oversize_add = 0;
 403:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_OVERSIZE_DBGCHECK*/
 404:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_OVERSIZE */
 405:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u16_t extendlen = 0;
 539              	 .loc 1 405 0
 540 003e 0023     	 movs r3,#0
 541 0040 BB87     	 strh r3,[r7,#60]
 406:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 407:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u16_t concat_chksum = 0;
 408:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u8_t concat_chksum_swapped = 0;
 409:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u16_t concat_chksummed = 0;
 410:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 411:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   err_t err;
 412:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u16_t mss_local;
 413:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 414:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ERROR("tcp_write: invalid pcb", pcb != NULL, return ERR_ARG);
 542              	 .loc 1 414 0
 543 0042 FB68     	 ldr r3,[r7,#12]
 544 0044 002B     	 cmp r3,#0
 545 0046 01D1     	 bne .L22
 546              	 .loc 1 414 0 is_stmt 0 discriminator 1
 547 0048 F023     	 movs r3,#240
 548 004a 5CE2     	 b .L67
 549              	.L22:
 415:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 416:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* don't allocate segments bigger than half the maximum window we ever received */
 417:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   mss_local = LWIP_MIN(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max / 2));
 550              	 .loc 1 417 0 is_stmt 1
 551 004c FB68     	 ldr r3,[r7,#12]
 552 004e B3F86230 	 ldrh r3,[r3,#98]
 553 0052 5B08     	 lsrs r3,r3,#1
 554 0054 9AB2     	 uxth r2,r3
 555 0056 FB68     	 ldr r3,[r7,#12]
 556 0058 5B8E     	 ldrh r3,[r3,#50]
 557 005a 9342     	 cmp r3,r2
 558 005c 28BF     	 it cs
 559 005e 1346     	 movcs r3,r2
 560 0060 BB84     	 strh r3,[r7,#36]
 418:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   mss_local = mss_local ? mss_local : pcb->mss;
 561              	 .loc 1 418 0
 562 0062 BB8C     	 ldrh r3,[r7,#36]
 563 0064 002B     	 cmp r3,#0
 564 0066 02D1     	 bne .L24
 565              	 .loc 1 418 0 is_stmt 0 discriminator 1
 566 0068 FB68     	 ldr r3,[r7,#12]
 567 006a 5B8E     	 ldrh r3,[r3,#50]
 568 006c 00E0     	 b .L25
 569              	.L24:
 570              	 .loc 1 418 0 discriminator 2
 571 006e BB8C     	 ldrh r3,[r7,#36]
 572              	.L25:
 573              	 .loc 1 418 0 discriminator 4
 574 0070 BB84     	 strh r3,[r7,#36]
 419:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 420:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT_CORE_LOCKED();
 421:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 422:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if LWIP_NETIF_TX_SINGLE_PBUF
 423:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Always copy to try to create single pbufs for TX */
 424:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   apiflags |= TCP_WRITE_FLAG_COPY;
 425:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
 426:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 427:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
 428:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                                  (void *)pcb, arg, len, (u16_t)apiflags));
 429:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
 575              	 .loc 1 429 0 is_stmt 1 discriminator 4
 576 0072 BB68     	 ldr r3,[r7,#8]
 577 0074 002B     	 cmp r3,#0
 578 0076 01D1     	 bne .L26
 579              	 .loc 1 429 0 is_stmt 0 discriminator 1
 580 0078 F023     	 movs r3,#240
 581 007a 44E2     	 b .L67
 582              	.L26:
 430:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****              arg != NULL, return ERR_ARG;);
 431:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 432:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   err = tcp_write_checks(pcb, len);
 583              	 .loc 1 432 0 is_stmt 1
 584 007c FB88     	 ldrh r3,[r7,#6]
 585 007e F868     	 ldr r0,[r7,#12]
 586 0080 1946     	 mov r1,r3
 587 0082 FFF7FEFF 	 bl tcp_write_checks
 588 0086 0346     	 mov r3,r0
 589 0088 87F82330 	 strb r3,[r7,#35]
 433:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (err != ERR_OK) {
 590              	 .loc 1 433 0
 591 008c 97F92330 	 ldrsb r3,[r7,#35]
 592 0090 002B     	 cmp r3,#0
 593 0092 02D0     	 beq .L27
 434:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return err;
 594              	 .loc 1 434 0
 595 0094 97F82330 	 ldrb r3,[r7,#35]
 596 0098 35E2     	 b .L67
 597              	.L27:
 435:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 436:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   queuelen = pcb->snd_queuelen;
 598              	 .loc 1 436 0
 599 009a FB68     	 ldr r3,[r7,#12]
 600 009c B3F86630 	 ldrh r3,[r3,#102]
 601 00a0 A7F84030 	 strh r3,[r7,#64]
 437:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 438:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if LWIP_TCP_TIMESTAMPS
 439:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if ((pcb->flags & TF_TIMESTAMP)) {
 440:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* Make sure the timestamp option is only included in data segments if we
 441:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****        agreed about it with the remote host. */
 442:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     optflags = TF_SEG_OPTS_TS;
 443:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(TF_SEG_OPTS_TS, pcb);
 444:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* ensure that segments can hold at least one data byte... */
 445:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     mss_local = LWIP_MAX(mss_local, LWIP_TCP_OPT_LEN_TS + 1);
 446:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   } else
 447:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* LWIP_TCP_TIMESTAMPS */
 448:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   {
 449:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 602              	 .loc 1 449 0
 603 00a4 0023     	 movs r3,#0
 604 00a6 87F82230 	 strb r3,[r7,#34]
 450:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 451:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 452:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 453:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /*
 454:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * TCP segmentation is done in three phases with increasing complexity:
 455:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    *
 456:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * 1. Copy data directly into an oversized pbuf.
 457:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * 2. Chain a new pbuf to the end of pcb->unsent.
 458:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * 3. Create new segments.
 459:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    *
 460:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * We may run out of memory at any point. In that case we must
 461:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * return ERR_MEM and not change anything in pcb. Therefore, all
 462:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * changes are recorded in local variables and committed at the end
 463:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * of the function. Some pcb fields are maintained in local copies:
 464:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    *
 465:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * queuelen = pcb->snd_queuelen
 466:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * oversize = pcb->unsent_oversize
 467:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    *
 468:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * These variables are set consistently by the phases:
 469:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    *
 470:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * seg points to the last segment tampered with.
 471:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    *
 472:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * pos records progress as data is segmented.
 473:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    */
 474:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 475:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Find the tail of the unsent queue. */
 476:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pcb->unsent != NULL) {
 605              	 .loc 1 476 0
 606 00aa FB68     	 ldr r3,[r7,#12]
 607 00ac DB6E     	 ldr r3,[r3,#108]
 608 00ae 002B     	 cmp r3,#0
 609 00b0 00F0C480 	 beq .L28
 610              	.LBB2:
 477:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     u16_t space;
 478:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     u16_t unsent_optlen;
 479:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 480:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* @todo: this could be sped up by keeping last_unsent in the pcb */
 481:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 611              	 .loc 1 481 0
 612 00b4 FB68     	 ldr r3,[r7,#12]
 613 00b6 DB6E     	 ldr r3,[r3,#108]
 614 00b8 3B65     	 str r3,[r7,#80]
 615 00ba 02E0     	 b .L29
 616              	.L30:
 482:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****          last_unsent = last_unsent->next);
 617              	 .loc 1 482 0
 618 00bc 3B6D     	 ldr r3,[r7,#80]
 619 00be 1B68     	 ldr r3,[r3]
 620 00c0 3B65     	 str r3,[r7,#80]
 621              	.L29:
 481:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****          last_unsent = last_unsent->next);
 622              	 .loc 1 481 0 discriminator 1
 623 00c2 3B6D     	 ldr r3,[r7,#80]
 624 00c4 1B68     	 ldr r3,[r3]
 625 00c6 002B     	 cmp r3,#0
 626 00c8 F8D1     	 bne .L30
 483:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 484:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* Usable space at the end of the last unsent segment */
 485:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     unsent_optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(last_unsent->flags, pcb);
 627              	 .loc 1 485 0
 628 00ca 3B6D     	 ldr r3,[r7,#80]
 629 00cc 9B7A     	 ldrb r3,[r3,#10]
 630 00ce 03F00103 	 and r3,r3,#1
 631 00d2 002B     	 cmp r3,#0
 632 00d4 01D0     	 beq .L31
 633              	 .loc 1 485 0 is_stmt 0 discriminator 1
 634 00d6 0423     	 movs r3,#4
 635 00d8 00E0     	 b .L32
 636              	.L31:
 637              	 .loc 1 485 0 discriminator 2
 638 00da 0023     	 movs r3,#0
 639              	.L32:
 640              	 .loc 1 485 0 discriminator 4
 641 00dc 3B84     	 strh r3,[r7,#32]
 486:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
 487:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     space = mss_local - (last_unsent->len + unsent_optlen);
 642              	 .loc 1 487 0 is_stmt 1 discriminator 4
 643 00de 3B6D     	 ldr r3,[r7,#80]
 644 00e0 1A89     	 ldrh r2,[r3,#8]
 645 00e2 3B8C     	 ldrh r3,[r7,#32]
 646 00e4 1344     	 add r3,r3,r2
 647 00e6 9BB2     	 uxth r3,r3
 648 00e8 BA8C     	 ldrh r2,[r7,#36]
 649 00ea D31A     	 subs r3,r2,r3
 650 00ec 7B87     	 strh r3,[r7,#58]
 488:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 489:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /*
 490:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * Phase 1: Copy data directly into an oversized pbuf.
 491:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      *
 492:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * The number of bytes copied is recorded in the oversize_used
 493:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * variable. The actual copying is done at the bottom of the
 494:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * function.
 495:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      */
 496:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_OVERSIZE
 497:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_OVERSIZE_DBGCHECK
 498:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* check that pcb->unsent_oversize matches last_unsent->oversize_left */
 499:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
 500:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 pcb->unsent_oversize == last_unsent->oversize_left);
 501:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_OVERSIZE_DBGCHECK */
 502:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     oversize = pcb->unsent_oversize;
 651              	 .loc 1 502 0 discriminator 4
 652 00ee FB68     	 ldr r3,[r7,#12]
 653 00f0 B3F86830 	 ldrh r3,[r3,#104]
 654 00f4 7B82     	 strh r3,[r7,#18]
 503:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if (oversize > 0) {
 655              	 .loc 1 503 0 discriminator 4
 656 00f6 7B8A     	 ldrh r3,[r7,#18]
 657 00f8 002B     	 cmp r3,#0
 658 00fa 1BD0     	 beq .L33
 504:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       LWIP_ASSERT("inconsistent oversize vs. space", oversize <= space);
 505:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       seg = last_unsent;
 659              	 .loc 1 505 0
 660 00fc 3B6D     	 ldr r3,[r7,#80]
 661 00fe FB64     	 str r3,[r7,#76]
 506:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       oversize_used = LWIP_MIN(space, LWIP_MIN(oversize, len));
 662              	 .loc 1 506 0
 663 0100 7B8A     	 ldrh r3,[r7,#18]
 664 0102 FA88     	 ldrh r2,[r7,#6]
 665 0104 9342     	 cmp r3,r2
 666 0106 28BF     	 it cs
 667 0108 1346     	 movcs r3,r2
 668 010a 9AB2     	 uxth r2,r3
 669 010c 7B8F     	 ldrh r3,[r7,#58]
 670 010e 9342     	 cmp r3,r2
 671 0110 28BF     	 it cs
 672 0112 1346     	 movcs r3,r2
 673 0114 FB87     	 strh r3,[r7,#62]
 507:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       pos += oversize_used;
 674              	 .loc 1 507 0
 675 0116 B7F84220 	 ldrh r2,[r7,#66]
 676 011a FB8F     	 ldrh r3,[r7,#62]
 677 011c 1344     	 add r3,r3,r2
 678 011e A7F84230 	 strh r3,[r7,#66]
 508:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       oversize -= oversize_used;
 679              	 .loc 1 508 0
 680 0122 7A8A     	 ldrh r2,[r7,#18]
 681 0124 FB8F     	 ldrh r3,[r7,#62]
 682 0126 D31A     	 subs r3,r2,r3
 683 0128 9BB2     	 uxth r3,r3
 684 012a 7B82     	 strh r3,[r7,#18]
 509:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       space -= oversize_used;
 685              	 .loc 1 509 0
 686 012c 7A8F     	 ldrh r2,[r7,#58]
 687 012e FB8F     	 ldrh r3,[r7,#62]
 688 0130 D31A     	 subs r3,r2,r3
 689 0132 7B87     	 strh r3,[r7,#58]
 690              	.L33:
 510:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
 511:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* now we are either finished or oversize is zero */
 512:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_ASSERT("inconsistent oversize vs. len", (oversize == 0) || (pos == len));
 513:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_OVERSIZE */
 514:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 515:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if !LWIP_NETIF_TX_SINGLE_PBUF
 516:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /*
 517:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * Phase 2: Chain a new pbuf to the end of pcb->unsent.
 518:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      *
 519:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * As an exception when NOT copying the data, if the given data buffer
 520:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * directly follows the last unsent data buffer in memory, extend the last
 521:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * ROM pbuf reference to the buffer, thus saving a ROM pbuf allocation.
 522:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      *
 523:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * We don't extend segments containing SYN/FIN flags or options
 524:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
 525:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * the end.
 526:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      *
 527:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * This phase is skipped for LWIP_NETIF_TX_SINGLE_PBUF as we could only execute
 528:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * it after rexmit puts a segment from unacked to unsent and at this point,
 529:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * oversize info is lost.
 530:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      */
 531:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 691              	 .loc 1 531 0
 692 0134 B7F84220 	 ldrh r2,[r7,#66]
 693 0138 FB88     	 ldrh r3,[r7,#6]
 694 013a 9A42     	 cmp r2,r3
 695 013c 7ED2     	 bcs .L34
 696              	 .loc 1 531 0 is_stmt 0 discriminator 1
 697 013e 7B8F     	 ldrh r3,[r7,#58]
 698 0140 002B     	 cmp r3,#0
 699 0142 7BD0     	 beq .L34
 700              	 .loc 1 531 0 discriminator 2
 701 0144 3B6D     	 ldr r3,[r7,#80]
 702 0146 1B89     	 ldrh r3,[r3,#8]
 703 0148 002B     	 cmp r3,#0
 704 014a 77D0     	 beq .L34
 705              	.LBB3:
 532:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       u16_t seglen = LWIP_MIN(space, len - pos);
 706              	 .loc 1 532 0 is_stmt 1
 707 014c FA88     	 ldrh r2,[r7,#6]
 708 014e B7F84230 	 ldrh r3,[r7,#66]
 709 0152 D21A     	 subs r2,r2,r3
 710 0154 7B8F     	 ldrh r3,[r7,#58]
 711 0156 9342     	 cmp r3,r2
 712 0158 A8BF     	 it ge
 713 015a 1346     	 movge r3,r2
 714 015c FB83     	 strh r3,[r7,#30]
 533:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       seg = last_unsent;
 715              	 .loc 1 533 0
 716 015e 3B6D     	 ldr r3,[r7,#80]
 717 0160 FB64     	 str r3,[r7,#76]
 534:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 535:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       /* Create a pbuf with a copy or reference to seglen bytes. We
 536:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****        * can use PBUF_RAW here since the data appears in the middle of
 537:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****        * a segment. A header will never be prepended. */
 538:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       if (apiflags & TCP_WRITE_FLAG_COPY) {
 718              	 .loc 1 538 0
 719 0162 7B79     	 ldrb r3,[r7,#5]
 720 0164 03F00103 	 and r3,r3,#1
 721 0168 002B     	 cmp r3,#0
 722 016a 29D0     	 beq .L35
 539:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         /* Data is copied */
 540:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) ==
 723              	 .loc 1 540 0
 724 016c F98B     	 ldrh r1,[r7,#30]
 725 016e 7A8F     	 ldrh r2,[r7,#58]
 726 0170 07F11204 	 add r4,r7,#18
 727 0174 FB68     	 ldr r3,[r7,#12]
 728 0176 0093     	 str r3,[sp]
 729 0178 7B79     	 ldrb r3,[r7,#5]
 730 017a 0193     	 str r3,[sp,#4]
 731 017c 0123     	 movs r3,#1
 732 017e 0293     	 str r3,[sp,#8]
 733 0180 0020     	 movs r0,#0
 734 0182 2346     	 mov r3,r4
 735 0184 FFF7FEFF 	 bl tcp_pbuf_prealloc
 736 0188 7865     	 str r0,[r7,#84]
 737 018a 7B6D     	 ldr r3,[r7,#84]
 738 018c 002B     	 cmp r3,#0
 739 018e 00D1     	 bne .L36
 541:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
 542:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                       ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
 543:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                        seglen));
 544:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           goto memerr;
 740              	 .loc 1 544 0
 741 0190 A5E1     	 b .L37
 742              	.L36:
 545:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         }
 546:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_OVERSIZE_DBGCHECK
 547:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         oversize_add = oversize;
 548:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_OVERSIZE_DBGCHECK */
 549:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         TCP_DATA_COPY2(concat_p->payload, (const u8_t *)arg + pos, seglen, &concat_chksum, &concat_
 743              	 .loc 1 549 0
 744 0192 7B6D     	 ldr r3,[r7,#84]
 745 0194 5968     	 ldr r1,[r3,#4]
 746 0196 B7F84230 	 ldrh r3,[r7,#66]
 747 019a BA68     	 ldr r2,[r7,#8]
 748 019c 1A44     	 add r2,r2,r3
 749 019e FB8B     	 ldrh r3,[r7,#30]
 750 01a0 0846     	 mov r0,r1
 751 01a2 1146     	 mov r1,r2
 752 01a4 1A46     	 mov r2,r3
 753 01a6 FFF7FEFF 	 bl memcpy
 550:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 551:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         concat_chksummed += seglen;
 552:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 553:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         queuelen += pbuf_clen(concat_p);
 754              	 .loc 1 553 0
 755 01aa 786D     	 ldr r0,[r7,#84]
 756 01ac FFF7FEFF 	 bl pbuf_clen
 757 01b0 0346     	 mov r3,r0
 758 01b2 1A46     	 mov r2,r3
 759 01b4 B7F84030 	 ldrh r3,[r7,#64]
 760 01b8 1344     	 add r3,r3,r2
 761 01ba A7F84030 	 strh r3,[r7,#64]
 762 01be 36E0     	 b .L38
 763              	.L35:
 764              	.LBB4:
 554:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       } else {
 555:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         /* Data is not copied */
 556:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         /* If the last unsent pbuf is of type PBUF_ROM, try to extend it. */
 557:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         struct pbuf *p;
 558:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         for (p = last_unsent->p; p->next != NULL; p = p->next);
 765              	 .loc 1 558 0
 766 01c0 3B6D     	 ldr r3,[r7,#80]
 767 01c2 5B68     	 ldr r3,[r3,#4]
 768 01c4 7B63     	 str r3,[r7,#52]
 769 01c6 02E0     	 b .L39
 770              	.L40:
 771              	 .loc 1 558 0 is_stmt 0 discriminator 3
 772 01c8 7B6B     	 ldr r3,[r7,#52]
 773 01ca 1B68     	 ldr r3,[r3]
 774 01cc 7B63     	 str r3,[r7,#52]
 775              	.L39:
 776              	 .loc 1 558 0 discriminator 1
 777 01ce 7B6B     	 ldr r3,[r7,#52]
 778 01d0 1B68     	 ldr r3,[r3]
 779 01d2 002B     	 cmp r3,#0
 780 01d4 F8D1     	 bne .L40
 559:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         if (((p->type_internal & (PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_DATA_VOLAT
 781              	 .loc 1 559 0 is_stmt 1
 782 01d6 7B6B     	 ldr r3,[r7,#52]
 783 01d8 1B7B     	 ldrb r3,[r3,#12]
 784 01da 03F0C003 	 and r3,r3,#192
 785 01de 002B     	 cmp r3,#0
 786 01e0 0AD1     	 bne .L41
 560:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****             (const u8_t *)p->payload + p->len == (const u8_t *)arg) {
 787              	 .loc 1 560 0 discriminator 1
 788 01e2 7B6B     	 ldr r3,[r7,#52]
 789 01e4 5B68     	 ldr r3,[r3,#4]
 790 01e6 7A6B     	 ldr r2,[r7,#52]
 791 01e8 5289     	 ldrh r2,[r2,#10]
 792 01ea 1A44     	 add r2,r2,r3
 559:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         if (((p->type_internal & (PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_DATA_VOLAT
 793              	 .loc 1 559 0 discriminator 1
 794 01ec BB68     	 ldr r3,[r7,#8]
 795 01ee 9A42     	 cmp r2,r3
 796 01f0 02D1     	 bne .L41
 561:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           LWIP_ASSERT("tcp_write: ROM pbufs cannot be oversized", pos == 0);
 562:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           extendlen = seglen;
 797              	 .loc 1 562 0
 798 01f2 FB8B     	 ldrh r3,[r7,#30]
 799 01f4 BB87     	 strh r3,[r7,#60]
 800 01f6 1AE0     	 b .L38
 801              	.L41:
 563:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         } else {
 564:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
 802              	 .loc 1 564 0
 803 01f8 FB8B     	 ldrh r3,[r7,#30]
 804 01fa 0020     	 movs r0,#0
 805 01fc 1946     	 mov r1,r3
 806 01fe 0122     	 movs r2,#1
 807 0200 FFF7FEFF 	 bl pbuf_alloc
 808 0204 7865     	 str r0,[r7,#84]
 809 0206 7B6D     	 ldr r3,[r7,#84]
 810 0208 002B     	 cmp r3,#0
 811 020a 00D1     	 bne .L42
 565:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****             LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
 566:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                         ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
 567:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****             goto memerr;
 812              	 .loc 1 567 0
 813 020c 67E1     	 b .L37
 814              	.L42:
 568:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           }
 569:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           /* reference the non-volatile payload data */
 570:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           ((struct pbuf_rom *)concat_p)->payload = (const u8_t *)arg + pos;
 815              	 .loc 1 570 0
 816 020e B7F84230 	 ldrh r3,[r7,#66]
 817 0212 BA68     	 ldr r2,[r7,#8]
 818 0214 1A44     	 add r2,r2,r3
 819 0216 7B6D     	 ldr r3,[r7,#84]
 820 0218 5A60     	 str r2,[r3,#4]
 571:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           queuelen += pbuf_clen(concat_p);
 821              	 .loc 1 571 0
 822 021a 786D     	 ldr r0,[r7,#84]
 823 021c FFF7FEFF 	 bl pbuf_clen
 824 0220 0346     	 mov r3,r0
 825 0222 1A46     	 mov r2,r3
 826 0224 B7F84030 	 ldrh r3,[r7,#64]
 827 0228 1344     	 add r3,r3,r2
 828 022a A7F84030 	 strh r3,[r7,#64]
 829              	.L38:
 830              	.LBE4:
 572:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         }
 573:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 574:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         /* calculate the checksum of nocopy-data */
 575:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         tcp_seg_add_chksum(~inet_chksum((const u8_t *)arg + pos, seglen), seglen,
 576:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                            &concat_chksum, &concat_chksum_swapped);
 577:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         concat_chksummed += seglen;
 578:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 579:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       }
 580:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 581:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       pos += seglen;
 831              	 .loc 1 581 0
 832 022e B7F84220 	 ldrh r2,[r7,#66]
 833 0232 FB8B     	 ldrh r3,[r7,#30]
 834 0234 1344     	 add r3,r3,r2
 835 0236 A7F84230 	 strh r3,[r7,#66]
 836              	.LBE3:
 837              	.LBE2:
 838 023a FFE7     	 b .L28
 839              	.L34:
 840              	.L28:
 582:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
 583:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* !LWIP_NETIF_TX_SINGLE_PBUF */
 584:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   } else {
 585:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_OVERSIZE
 586:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
 587:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 pcb->unsent_oversize == 0);
 588:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_OVERSIZE */
 589:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 590:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 591:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /*
 592:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * Phase 3: Create new segments.
 593:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    *
 594:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * The new segments are chained together in the local 'queue'
 595:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * variable, ready to be appended to pcb->unsent.
 596:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    */
 597:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   while (pos < len) {
 841              	 .loc 1 597 0 discriminator 1
 842 023c 9FE0     	 b .L43
 843              	.L53:
 844              	.LBB5:
 598:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     struct pbuf *p;
 599:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     u16_t left = len - pos;
 845              	 .loc 1 599 0
 846 023e FA88     	 ldrh r2,[r7,#6]
 847 0240 B7F84230 	 ldrh r3,[r7,#66]
 848 0244 D31A     	 subs r3,r2,r3
 849 0246 BB83     	 strh r3,[r7,#28]
 600:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     u16_t max_len = mss_local - optlen;
 850              	 .loc 1 600 0
 851 0248 97F82230 	 ldrb r3,[r7,#34]
 852 024c 9BB2     	 uxth r3,r3
 853 024e BA8C     	 ldrh r2,[r7,#36]
 854 0250 D31A     	 subs r3,r2,r3
 855 0252 7B83     	 strh r3,[r7,#26]
 601:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     u16_t seglen = LWIP_MIN(left, max_len);
 856              	 .loc 1 601 0
 857 0254 7A8B     	 ldrh r2,[r7,#26]
 858 0256 BB8B     	 ldrh r3,[r7,#28]
 859 0258 9342     	 cmp r3,r2
 860 025a 28BF     	 it cs
 861 025c 1346     	 movcs r3,r2
 862 025e 3B83     	 strh r3,[r7,#24]
 602:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 603:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     u16_t chksum = 0;
 604:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     u8_t chksum_swapped = 0;
 605:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 606:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 607:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if (apiflags & TCP_WRITE_FLAG_COPY) {
 863              	 .loc 1 607 0
 864 0260 7B79     	 ldrb r3,[r7,#5]
 865 0262 03F00103 	 and r3,r3,#1
 866 0266 002B     	 cmp r3,#0
 867 0268 2DD0     	 beq .L44
 608:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       /* If copy is set, memory should be allocated and data copied
 609:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****        * into pbuf */
 610:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apifla
 868              	 .loc 1 610 0
 869 026a 97F82230 	 ldrb r3,[r7,#34]
 870 026e 9AB2     	 uxth r2,r3
 871 0270 3B8B     	 ldrh r3,[r7,#24]
 872 0272 1344     	 add r3,r3,r2
 873 0274 99B2     	 uxth r1,r3
 874 0276 7B6C     	 ldr r3,[r7,#68]
 875 0278 002B     	 cmp r3,#0
 876 027a 0CBF     	 ite eq
 877 027c 0123     	 moveq r3,#1
 878 027e 0023     	 movne r3,#0
 879 0280 DBB2     	 uxtb r3,r3
 880 0282 1846     	 mov r0,r3
 881 0284 BA8C     	 ldrh r2,[r7,#36]
 882 0286 07F11204 	 add r4,r7,#18
 883 028a FB68     	 ldr r3,[r7,#12]
 884 028c 0093     	 str r3,[sp]
 885 028e 7B79     	 ldrb r3,[r7,#5]
 886 0290 0193     	 str r3,[sp,#4]
 887 0292 0290     	 str r0,[sp,#8]
 888 0294 3820     	 movs r0,#56
 889 0296 2346     	 mov r3,r4
 890 0298 FFF7FEFF 	 bl tcp_pbuf_prealloc
 891 029c 3863     	 str r0,[r7,#48]
 892 029e 3B6B     	 ldr r3,[r7,#48]
 893 02a0 002B     	 cmp r3,#0
 894 02a2 00D1     	 bne .L45
 611:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write : could not allocate mem
 612:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         goto memerr;
 895              	 .loc 1 612 0
 896 02a4 1BE1     	 b .L37
 897              	.L45:
 613:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       }
 614:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
 615:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                   (p->len >= seglen));
 616:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       TCP_DATA_COPY2((char *)p->payload + optlen, (const u8_t *)arg + pos, seglen, &chksum, &chksum
 898              	 .loc 1 616 0
 899 02a6 3B6B     	 ldr r3,[r7,#48]
 900 02a8 5A68     	 ldr r2,[r3,#4]
 901 02aa 97F82230 	 ldrb r3,[r7,#34]
 902 02ae D118     	 adds r1,r2,r3
 903 02b0 B7F84230 	 ldrh r3,[r7,#66]
 904 02b4 BA68     	 ldr r2,[r7,#8]
 905 02b6 1A44     	 add r2,r2,r3
 906 02b8 3B8B     	 ldrh r3,[r7,#24]
 907 02ba 0846     	 mov r0,r1
 908 02bc 1146     	 mov r1,r2
 909 02be 1A46     	 mov r2,r3
 910 02c0 FFF7FEFF 	 bl memcpy
 911 02c4 25E0     	 b .L46
 912              	.L44:
 913              	.LBB6:
 617:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     } else {
 618:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       /* Copy is not set: First allocate a pbuf for holding the data.
 619:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****        * Since the referenced data is available at least until it is
 620:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****        * sent out on the link (as it has to be ACKed by the remote
 621:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****        * party) we can safely use PBUF_ROM instead of PBUF_REF here.
 622:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****        */
 623:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       struct pbuf *p2;
 624:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_OVERSIZE
 625:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       LWIP_ASSERT("oversize == 0", oversize == 0);
 626:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_OVERSIZE */
 627:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
 914              	 .loc 1 627 0
 915 02c6 3B8B     	 ldrh r3,[r7,#24]
 916 02c8 3820     	 movs r0,#56
 917 02ca 1946     	 mov r1,r3
 918 02cc 0122     	 movs r2,#1
 919 02ce FFF7FEFF 	 bl pbuf_alloc
 920 02d2 7861     	 str r0,[r7,#20]
 921 02d4 7B69     	 ldr r3,[r7,#20]
 922 02d6 002B     	 cmp r3,#0
 923 02d8 00D1     	 bne .L47
 628:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: could not allocate memo
 629:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         goto memerr;
 924              	 .loc 1 629 0
 925 02da 00E1     	 b .L37
 926              	.L47:
 630:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       }
 631:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 632:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       /* calculate the checksum of nocopy-data */
 633:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       chksum = ~inet_chksum((const u8_t *)arg + pos, seglen);
 634:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       if (seglen & 1) {
 635:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         chksum_swapped = 1;
 636:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         chksum = SWAP_BYTES_IN_WORD(chksum);
 637:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       }
 638:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 639:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       /* reference the non-volatile payload data */
 640:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       ((struct pbuf_rom *)p2)->payload = (const u8_t *)arg + pos;
 927              	 .loc 1 640 0
 928 02dc B7F84230 	 ldrh r3,[r7,#66]
 929 02e0 BA68     	 ldr r2,[r7,#8]
 930 02e2 1A44     	 add r2,r2,r3
 931 02e4 7B69     	 ldr r3,[r7,#20]
 932 02e6 5A60     	 str r2,[r3,#4]
 641:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 642:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       /* Second, allocate a pbuf for the headers. */
 643:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 933              	 .loc 1 643 0
 934 02e8 97F82230 	 ldrb r3,[r7,#34]
 935 02ec 9BB2     	 uxth r3,r3
 936 02ee 3820     	 movs r0,#56
 937 02f0 1946     	 mov r1,r3
 938 02f2 4FF42072 	 mov r2,#640
 939 02f6 FFF7FEFF 	 bl pbuf_alloc
 940 02fa 3863     	 str r0,[r7,#48]
 941 02fc 3B6B     	 ldr r3,[r7,#48]
 942 02fe 002B     	 cmp r3,#0
 943 0300 03D1     	 bne .L48
 644:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         /* If allocation fails, we have to deallocate the data pbuf as
 645:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****          * well. */
 646:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         pbuf_free(p2);
 944              	 .loc 1 646 0
 945 0302 7869     	 ldr r0,[r7,#20]
 946 0304 FFF7FEFF 	 bl pbuf_free
 647:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: could not allocate memo
 648:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         goto memerr;
 947              	 .loc 1 648 0
 948 0308 E9E0     	 b .L37
 949              	.L48:
 649:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       }
 650:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       /* Concatenate the headers and data pbufs together. */
 651:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       pbuf_cat(p/*header*/, p2/*data*/);
 950              	 .loc 1 651 0
 951 030a 386B     	 ldr r0,[r7,#48]
 952 030c 7969     	 ldr r1,[r7,#20]
 953 030e FFF7FEFF 	 bl pbuf_cat
 954              	.L46:
 955              	.LBE6:
 652:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
 653:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 654:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     queuelen += pbuf_clen(p);
 956              	 .loc 1 654 0
 957 0312 386B     	 ldr r0,[r7,#48]
 958 0314 FFF7FEFF 	 bl pbuf_clen
 959 0318 0346     	 mov r3,r0
 960 031a 1A46     	 mov r2,r3
 961 031c B7F84030 	 ldrh r3,[r7,#64]
 962 0320 1344     	 add r3,r3,r2
 963 0322 A7F84030 	 strh r3,[r7,#64]
 655:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 656:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* Now that there are more segments queued, we check again if the
 657:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * length of the queue exceeds the configured maximum or
 658:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * overflows. */
 659:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if (queuelen > LWIP_MIN(TCP_SND_QUEUELEN, TCP_SNDQUEUELEN_OVERFLOW)) {
 964              	 .loc 1 659 0
 965 0326 B7F84030 	 ldrh r3,[r7,#64]
 966 032a 082B     	 cmp r3,#8
 967 032c 03D9     	 bls .L49
 660:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: queue too long %"U16_F" (
 661:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                   queuelen, (int)TCP_SND_QUEUELEN));
 662:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       pbuf_free(p);
 968              	 .loc 1 662 0
 969 032e 386B     	 ldr r0,[r7,#48]
 970 0330 FFF7FEFF 	 bl pbuf_free
 663:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       goto memerr;
 971              	 .loc 1 663 0
 972 0334 D3E0     	 b .L37
 973              	.L49:
 664:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
 665:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 666:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
 974              	 .loc 1 666 0
 975 0336 FB68     	 ldr r3,[r7,#12]
 976 0338 DA6D     	 ldr r2,[r3,#92]
 977 033a B7F84230 	 ldrh r3,[r7,#66]
 978 033e D418     	 adds r4,r2,r3
 979 0340 97F82730 	 ldrb r3,[r7,#39]
 980 0344 0093     	 str r3,[sp]
 981 0346 F868     	 ldr r0,[r7,#12]
 982 0348 396B     	 ldr r1,[r7,#48]
 983 034a 0022     	 movs r2,#0
 984 034c 2346     	 mov r3,r4
 985 034e FFF7FEFF 	 bl tcp_create_segment
 986 0352 F864     	 str r0,[r7,#76]
 987 0354 FB6C     	 ldr r3,[r7,#76]
 988 0356 002B     	 cmp r3,#0
 989 0358 00D1     	 bne .L50
 667:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       goto memerr;
 990              	 .loc 1 667 0
 991 035a C0E0     	 b .L37
 992              	.L50:
 668:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
 669:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_OVERSIZE_DBGCHECK
 670:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     seg->oversize_left = oversize;
 671:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_OVERSIZE_DBGCHECK */
 672:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 673:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     seg->chksum = chksum;
 674:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     seg->chksum_swapped = chksum_swapped;
 675:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     seg->flags |= TF_SEG_DATA_CHECKSUMMED;
 676:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 677:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 678:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* first segment of to-be-queued data? */
 679:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if (queue == NULL) {
 993              	 .loc 1 679 0
 994 035c 7B6C     	 ldr r3,[r7,#68]
 995 035e 002B     	 cmp r3,#0
 996 0360 02D1     	 bne .L51
 680:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       queue = seg;
 997              	 .loc 1 680 0
 998 0362 FB6C     	 ldr r3,[r7,#76]
 999 0364 7B64     	 str r3,[r7,#68]
 1000 0366 02E0     	 b .L52
 1001              	.L51:
 681:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     } else {
 682:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       /* Attach the segment to the end of the queued segments */
 683:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
 684:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       prev_seg->next = seg;
 1002              	 .loc 1 684 0
 1003 0368 BB6C     	 ldr r3,[r7,#72]
 1004 036a FA6C     	 ldr r2,[r7,#76]
 1005 036c 1A60     	 str r2,[r3]
 1006              	.L52:
 685:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
 686:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* remember last segment of to-be-queued data for next iteration */
 687:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     prev_seg = seg;
 1007              	 .loc 1 687 0
 1008 036e FB6C     	 ldr r3,[r7,#76]
 1009 0370 BB64     	 str r3,[r7,#72]
 688:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 689:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
 690:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 lwip_ntohl(seg->tcphdr->seqno),
 691:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));
 692:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 693:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     pos += seglen;
 1010              	 .loc 1 693 0
 1011 0372 B7F84220 	 ldrh r2,[r7,#66]
 1012 0376 3B8B     	 ldrh r3,[r7,#24]
 1013 0378 1344     	 add r3,r3,r2
 1014 037a A7F84230 	 strh r3,[r7,#66]
 1015              	.L43:
 1016              	.LBE5:
 597:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     struct pbuf *p;
 1017              	 .loc 1 597 0
 1018 037e B7F84220 	 ldrh r2,[r7,#66]
 1019 0382 FB88     	 ldrh r3,[r7,#6]
 1020 0384 9A42     	 cmp r2,r3
 1021 0386 FFF45AAF 	 bcc .L53
 694:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 695:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 696:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /*
 697:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * All three segmentation phases were successful. We can commit the
 698:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * transaction.
 699:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    */
 700:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_OVERSIZE_DBGCHECK
 701:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if ((last_unsent != NULL) && (oversize_add != 0)) {
 702:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     last_unsent->oversize_left += oversize_add;
 703:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 704:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_OVERSIZE_DBGCHECK */
 705:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 706:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /*
 707:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * Phase 1: If data has been added to the preallocated tail of
 708:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * last_unsent, we update the length fields of the pbuf chain.
 709:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    */
 710:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_OVERSIZE
 711:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (oversize_used > 0) {
 1022              	 .loc 1 711 0
 1023 038a FB8F     	 ldrh r3,[r7,#62]
 1024 038c 002B     	 cmp r3,#0
 1025 038e 2DD0     	 beq .L54
 1026              	.LBB7:
 712:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     struct pbuf *p;
 713:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* Bump tot_len of whole chain, len of tail */
 714:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     for (p = last_unsent->p; p; p = p->next) {
 1027              	 .loc 1 714 0
 1028 0390 3B6D     	 ldr r3,[r7,#80]
 1029 0392 5B68     	 ldr r3,[r3,#4]
 1030 0394 FB62     	 str r3,[r7,#44]
 1031 0396 1FE0     	 b .L55
 1032              	.L57:
 715:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       p->tot_len += oversize_used;
 1033              	 .loc 1 715 0
 1034 0398 FB6A     	 ldr r3,[r7,#44]
 1035 039a 1A89     	 ldrh r2,[r3,#8]
 1036 039c FB8F     	 ldrh r3,[r7,#62]
 1037 039e 1344     	 add r3,r3,r2
 1038 03a0 9AB2     	 uxth r2,r3
 1039 03a2 FB6A     	 ldr r3,[r7,#44]
 1040 03a4 1A81     	 strh r2,[r3,#8]
 716:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       if (p->next == NULL) {
 1041              	 .loc 1 716 0
 1042 03a6 FB6A     	 ldr r3,[r7,#44]
 1043 03a8 1B68     	 ldr r3,[r3]
 1044 03aa 002B     	 cmp r3,#0
 1045 03ac 11D1     	 bne .L56
 717:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
 1046              	 .loc 1 717 0
 1047 03ae FB6A     	 ldr r3,[r7,#44]
 1048 03b0 5B68     	 ldr r3,[r3,#4]
 1049 03b2 FA6A     	 ldr r2,[r7,#44]
 1050 03b4 5289     	 ldrh r2,[r2,#10]
 1051 03b6 1A44     	 add r2,r2,r3
 1052 03b8 FB8F     	 ldrh r3,[r7,#62]
 1053 03ba 1046     	 mov r0,r2
 1054 03bc B968     	 ldr r1,[r7,#8]
 1055 03be 1A46     	 mov r2,r3
 1056 03c0 FFF7FEFF 	 bl memcpy
 718:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         p->len += oversize_used;
 1057              	 .loc 1 718 0
 1058 03c4 FB6A     	 ldr r3,[r7,#44]
 1059 03c6 5A89     	 ldrh r2,[r3,#10]
 1060 03c8 FB8F     	 ldrh r3,[r7,#62]
 1061 03ca 1344     	 add r3,r3,r2
 1062 03cc 9AB2     	 uxth r2,r3
 1063 03ce FB6A     	 ldr r3,[r7,#44]
 1064 03d0 5A81     	 strh r2,[r3,#10]
 1065              	.L56:
 714:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       p->tot_len += oversize_used;
 1066              	 .loc 1 714 0 discriminator 2
 1067 03d2 FB6A     	 ldr r3,[r7,#44]
 1068 03d4 1B68     	 ldr r3,[r3]
 1069 03d6 FB62     	 str r3,[r7,#44]
 1070              	.L55:
 714:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       p->tot_len += oversize_used;
 1071              	 .loc 1 714 0 is_stmt 0 discriminator 1
 1072 03d8 FB6A     	 ldr r3,[r7,#44]
 1073 03da 002B     	 cmp r3,#0
 1074 03dc DCD1     	 bne .L57
 719:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       }
 720:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
 721:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     last_unsent->len += oversize_used;
 1075              	 .loc 1 721 0 is_stmt 1
 1076 03de 3B6D     	 ldr r3,[r7,#80]
 1077 03e0 1A89     	 ldrh r2,[r3,#8]
 1078 03e2 FB8F     	 ldrh r3,[r7,#62]
 1079 03e4 1344     	 add r3,r3,r2
 1080 03e6 9AB2     	 uxth r2,r3
 1081 03e8 3B6D     	 ldr r3,[r7,#80]
 1082 03ea 1A81     	 strh r2,[r3,#8]
 1083              	.L54:
 1084              	.LBE7:
 722:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_OVERSIZE_DBGCHECK
 723:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
 724:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 last_unsent->oversize_left >= oversize_used);
 725:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     last_unsent->oversize_left -= oversize_used;
 726:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_OVERSIZE_DBGCHECK */
 727:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 728:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   pcb->unsent_oversize = oversize;
 1085              	 .loc 1 728 0
 1086 03ec 7A8A     	 ldrh r2,[r7,#18]
 1087 03ee FB68     	 ldr r3,[r7,#12]
 1088 03f0 A3F86820 	 strh r2,[r3,#104]
 729:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_OVERSIZE */
 730:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 731:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /*
 732:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * Phase 2: concat_p can be concatenated onto last_unsent->p, unless we
 733:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * determined that the last ROM pbuf can be extended to include the new data.
 734:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    */
 735:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (concat_p != NULL) {
 1089              	 .loc 1 735 0
 1090 03f4 7B6D     	 ldr r3,[r7,#84]
 1091 03f6 002B     	 cmp r3,#0
 1092 03f8 0ED0     	 beq .L58
 736:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
 737:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 (last_unsent != NULL));
 738:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     pbuf_cat(last_unsent->p, concat_p);
 1093              	 .loc 1 738 0
 1094 03fa 3B6D     	 ldr r3,[r7,#80]
 1095 03fc 5B68     	 ldr r3,[r3,#4]
 1096 03fe 1846     	 mov r0,r3
 1097 0400 796D     	 ldr r1,[r7,#84]
 1098 0402 FFF7FEFF 	 bl pbuf_cat
 739:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     last_unsent->len += concat_p->tot_len;
 1099              	 .loc 1 739 0
 1100 0406 3B6D     	 ldr r3,[r7,#80]
 1101 0408 1A89     	 ldrh r2,[r3,#8]
 1102 040a 7B6D     	 ldr r3,[r7,#84]
 1103 040c 1B89     	 ldrh r3,[r3,#8]
 1104 040e 1344     	 add r3,r3,r2
 1105 0410 9AB2     	 uxth r2,r3
 1106 0412 3B6D     	 ldr r3,[r7,#80]
 1107 0414 1A81     	 strh r2,[r3,#8]
 1108 0416 29E0     	 b .L59
 1109              	.L58:
 740:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   } else if (extendlen > 0) {
 1110              	 .loc 1 740 0
 1111 0418 BB8F     	 ldrh r3,[r7,#60]
 1112 041a 002B     	 cmp r3,#0
 1113 041c 26D0     	 beq .L59
 1114              	.LBB8:
 741:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     struct pbuf *p;
 742:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_ASSERT("tcp_write: extension of reference requires reference",
 743:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 last_unsent != NULL && last_unsent->p != NULL);
 744:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     for (p = last_unsent->p; p->next != NULL; p = p->next) {
 1115              	 .loc 1 744 0
 1116 041e 3B6D     	 ldr r3,[r7,#80]
 1117 0420 5B68     	 ldr r3,[r3,#4]
 1118 0422 BB62     	 str r3,[r7,#40]
 1119 0424 09E0     	 b .L60
 1120              	.L61:
 745:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       p->tot_len += extendlen;
 1121              	 .loc 1 745 0 discriminator 3
 1122 0426 BB6A     	 ldr r3,[r7,#40]
 1123 0428 1A89     	 ldrh r2,[r3,#8]
 1124 042a BB8F     	 ldrh r3,[r7,#60]
 1125 042c 1344     	 add r3,r3,r2
 1126 042e 9AB2     	 uxth r2,r3
 1127 0430 BB6A     	 ldr r3,[r7,#40]
 1128 0432 1A81     	 strh r2,[r3,#8]
 744:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       p->tot_len += extendlen;
 1129              	 .loc 1 744 0 discriminator 3
 1130 0434 BB6A     	 ldr r3,[r7,#40]
 1131 0436 1B68     	 ldr r3,[r3]
 1132 0438 BB62     	 str r3,[r7,#40]
 1133              	.L60:
 744:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       p->tot_len += extendlen;
 1134              	 .loc 1 744 0 is_stmt 0 discriminator 1
 1135 043a BB6A     	 ldr r3,[r7,#40]
 1136 043c 1B68     	 ldr r3,[r3]
 1137 043e 002B     	 cmp r3,#0
 1138 0440 F1D1     	 bne .L61
 746:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
 747:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     p->tot_len += extendlen;
 1139              	 .loc 1 747 0 is_stmt 1
 1140 0442 BB6A     	 ldr r3,[r7,#40]
 1141 0444 1A89     	 ldrh r2,[r3,#8]
 1142 0446 BB8F     	 ldrh r3,[r7,#60]
 1143 0448 1344     	 add r3,r3,r2
 1144 044a 9AB2     	 uxth r2,r3
 1145 044c BB6A     	 ldr r3,[r7,#40]
 1146 044e 1A81     	 strh r2,[r3,#8]
 748:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     p->len += extendlen;
 1147              	 .loc 1 748 0
 1148 0450 BB6A     	 ldr r3,[r7,#40]
 1149 0452 5A89     	 ldrh r2,[r3,#10]
 1150 0454 BB8F     	 ldrh r3,[r7,#60]
 1151 0456 1344     	 add r3,r3,r2
 1152 0458 9AB2     	 uxth r2,r3
 1153 045a BB6A     	 ldr r3,[r7,#40]
 1154 045c 5A81     	 strh r2,[r3,#10]
 749:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     last_unsent->len += extendlen;
 1155              	 .loc 1 749 0
 1156 045e 3B6D     	 ldr r3,[r7,#80]
 1157 0460 1A89     	 ldrh r2,[r3,#8]
 1158 0462 BB8F     	 ldrh r3,[r7,#60]
 1159 0464 1344     	 add r3,r3,r2
 1160 0466 9AB2     	 uxth r2,r3
 1161 0468 3B6D     	 ldr r3,[r7,#80]
 1162 046a 1A81     	 strh r2,[r3,#8]
 1163              	.L59:
 1164              	.LBE8:
 750:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 751:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 752:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 753:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (concat_chksummed) {
 754:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_ASSERT("tcp_write: concat checksum needs concatenated data",
 755:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 concat_p != NULL || extendlen > 0);
 756:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /*if concat checksumm swapped - swap it back */
 757:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if (concat_chksum_swapped) {
 758:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       concat_chksum = SWAP_BYTES_IN_WORD(concat_chksum);
 759:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
 760:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
 761:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                        &last_unsent->chksum_swapped);
 762:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
 763:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 764:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 765:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 766:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /*
 767:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
 768:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * is harmless
 769:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    */
 770:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (last_unsent == NULL) {
 1165              	 .loc 1 770 0
 1166 046c 3B6D     	 ldr r3,[r7,#80]
 1167 046e 002B     	 cmp r3,#0
 1168 0470 03D1     	 bne .L62
 771:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     pcb->unsent = queue;
 1169              	 .loc 1 771 0
 1170 0472 FB68     	 ldr r3,[r7,#12]
 1171 0474 7A6C     	 ldr r2,[r7,#68]
 1172 0476 DA66     	 str r2,[r3,#108]
 1173 0478 02E0     	 b .L63
 1174              	.L62:
 772:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   } else {
 773:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     last_unsent->next = queue;
 1175              	 .loc 1 773 0
 1176 047a 3B6D     	 ldr r3,[r7,#80]
 1177 047c 7A6C     	 ldr r2,[r7,#68]
 1178 047e 1A60     	 str r2,[r3]
 1179              	.L63:
 774:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 775:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 776:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /*
 777:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * Finally update the pcb state.
 778:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    */
 779:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   pcb->snd_lbb += len;
 1180              	 .loc 1 779 0
 1181 0480 FB68     	 ldr r3,[r7,#12]
 1182 0482 DA6D     	 ldr r2,[r3,#92]
 1183 0484 FB88     	 ldrh r3,[r7,#6]
 1184 0486 1A44     	 add r2,r2,r3
 1185 0488 FB68     	 ldr r3,[r7,#12]
 1186 048a DA65     	 str r2,[r3,#92]
 780:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   pcb->snd_buf -= len;
 1187              	 .loc 1 780 0
 1188 048c FB68     	 ldr r3,[r7,#12]
 1189 048e B3F86420 	 ldrh r2,[r3,#100]
 1190 0492 FB88     	 ldrh r3,[r7,#6]
 1191 0494 D31A     	 subs r3,r2,r3
 1192 0496 9AB2     	 uxth r2,r3
 1193 0498 FB68     	 ldr r3,[r7,#12]
 1194 049a A3F86420 	 strh r2,[r3,#100]
 781:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   pcb->snd_queuelen = queuelen;
 1195              	 .loc 1 781 0
 1196 049e FB68     	 ldr r3,[r7,#12]
 1197 04a0 B7F84020 	 ldrh r2,[r7,#64]
 1198 04a4 A3F86620 	 strh r2,[r3,#102]
 782:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 783:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
 784:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                                pcb->snd_queuelen));
 785:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pcb->snd_queuelen != 0) {
 786:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_ASSERT("tcp_write: valid queue length",
 787:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 pcb->unacked != NULL || pcb->unsent != NULL);
 788:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 789:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 790:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Set the PSH flag in the last segment that we enqueued. */
 791:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE) == 0)) {
 1199              	 .loc 1 791 0
 1200 04a8 FB6C     	 ldr r3,[r7,#76]
 1201 04aa 002B     	 cmp r3,#0
 1202 04ac 15D0     	 beq .L64
 1203              	 .loc 1 791 0 is_stmt 0 discriminator 1
 1204 04ae FB6C     	 ldr r3,[r7,#76]
 1205 04b0 DB68     	 ldr r3,[r3,#12]
 1206 04b2 002B     	 cmp r3,#0
 1207 04b4 11D0     	 beq .L64
 1208              	 .loc 1 791 0 discriminator 2
 1209 04b6 7B79     	 ldrb r3,[r7,#5]
 1210 04b8 03F00203 	 and r3,r3,#2
 1211 04bc 002B     	 cmp r3,#0
 1212 04be 0CD1     	 bne .L64
 792:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
 1213              	 .loc 1 792 0 is_stmt 1
 1214 04c0 FB6C     	 ldr r3,[r7,#76]
 1215 04c2 DC68     	 ldr r4,[r3,#12]
 1216 04c4 FB6C     	 ldr r3,[r7,#76]
 1217 04c6 DB68     	 ldr r3,[r3,#12]
 1218 04c8 9B89     	 ldrh r3,[r3,#12]
 1219 04ca 9DB2     	 uxth r5,r3
 1220 04cc 0820     	 movs r0,#8
 1221 04ce FFF7FEFF 	 bl lwip_htons
 1222 04d2 0346     	 mov r3,r0
 1223 04d4 2B43     	 orrs r3,r3,r5
 1224 04d6 9BB2     	 uxth r3,r3
 1225 04d8 A381     	 strh r3,[r4,#12]
 1226              	.L64:
 793:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 794:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 795:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   return ERR_OK;
 1227              	 .loc 1 795 0
 1228 04da 0023     	 movs r3,#0
 1229 04dc 13E0     	 b .L67
 1230              	.L37:
 796:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** memerr:
 797:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   tcp_set_flags(pcb, TF_NAGLEMEMERR);
 1231              	 .loc 1 797 0
 1232 04de FB68     	 ldr r3,[r7,#12]
 1233 04e0 5B8B     	 ldrh r3,[r3,#26]
 1234 04e2 43F08003 	 orr r3,r3,#128
 1235 04e6 9AB2     	 uxth r2,r3
 1236 04e8 FB68     	 ldr r3,[r7,#12]
 1237 04ea 5A83     	 strh r2,[r3,#26]
 798:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   TCP_STATS_INC(tcp.memerr);
 799:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 800:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (concat_p != NULL) {
 1238              	 .loc 1 800 0
 1239 04ec 7B6D     	 ldr r3,[r7,#84]
 1240 04ee 002B     	 cmp r3,#0
 1241 04f0 02D0     	 beq .L65
 801:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     pbuf_free(concat_p);
 1242              	 .loc 1 801 0
 1243 04f2 786D     	 ldr r0,[r7,#84]
 1244 04f4 FFF7FEFF 	 bl pbuf_free
 1245              	.L65:
 802:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 803:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (queue != NULL) {
 1246              	 .loc 1 803 0
 1247 04f8 7B6C     	 ldr r3,[r7,#68]
 1248 04fa 002B     	 cmp r3,#0
 1249 04fc 02D0     	 beq .L66
 804:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcp_segs_free(queue);
 1250              	 .loc 1 804 0
 1251 04fe 786C     	 ldr r0,[r7,#68]
 1252 0500 FFF7FEFF 	 bl tcp_segs_free
 1253              	.L66:
 805:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 806:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pcb->snd_queuelen != 0) {
 807:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
 808:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 pcb->unsent != NULL);
 809:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 810:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_qu
 811:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   return ERR_MEM;
 1254              	 .loc 1 811 0
 1255 0504 FF23     	 movs r3,#255
 1256              	.L67:
 1257 0506 5BB2     	 sxtb r3,r3
 812:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 1258              	 .loc 1 812 0 discriminator 2
 1259 0508 1846     	 mov r0,r3
 1260 050a 5837     	 adds r7,r7,#88
 1261              	.LCFI24:
 1262              	 .cfi_def_cfa_offset 16
 1263 050c BD46     	 mov sp,r7
 1264              	.LCFI25:
 1265              	 .cfi_def_cfa_register 13
 1266              	 
 1267 050e B0BD     	 pop {r4,r5,r7,pc}
 1268              	 .cfi_endproc
 1269              	.LFE137:
 1271              	 .section .text.tcp_split_unsent_seg,"ax",%progbits
 1272              	 .align 2
 1273              	 .global tcp_split_unsent_seg
 1274              	 .thumb
 1275              	 .thumb_func
 1277              	tcp_split_unsent_seg:
 1278              	.LFB138:
 813:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 814:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /**
 815:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Split segment on the head of the unsent queue.  If return is not
 816:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * ERR_OK, existing head remains intact
 817:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
 818:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * The split is accomplished by creating a new TCP segment and pbuf
 819:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * which holds the remainder payload after the split.  The original
 820:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * pbuf is trimmed to new length.  This allows splitting of read-only
 821:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * pbufs
 822:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
 823:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb the tcp_pcb for which to split the unsent head
 824:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param split the amount of payload to remain in the head
 825:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
 826:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** err_t
 827:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_split_unsent_seg(struct tcp_pcb *pcb, u16_t split)
 828:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 1279              	 .loc 1 828 0
 1280              	 .cfi_startproc
 1281              	 
 1282              	 
 1283 0000 B0B5     	 push {r4,r5,r7,lr}
 1284              	.LCFI26:
 1285              	 .cfi_def_cfa_offset 16
 1286              	 .cfi_offset 4,-16
 1287              	 .cfi_offset 5,-12
 1288              	 .cfi_offset 7,-8
 1289              	 .cfi_offset 14,-4
 1290 0002 8AB0     	 sub sp,sp,#40
 1291              	.LCFI27:
 1292              	 .cfi_def_cfa_offset 56
 1293 0004 02AF     	 add r7,sp,#8
 1294              	.LCFI28:
 1295              	 .cfi_def_cfa 7,48
 1296 0006 7860     	 str r0,[r7,#4]
 1297 0008 0B46     	 mov r3,r1
 1298 000a 7B80     	 strh r3,[r7,#2]
 829:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct tcp_seg *seg = NULL, *useg = NULL;
 1299              	 .loc 1 829 0
 1300 000c 0023     	 movs r3,#0
 1301 000e BB61     	 str r3,[r7,#24]
 1302 0010 0023     	 movs r3,#0
 1303 0012 7B61     	 str r3,[r7,#20]
 830:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct pbuf *p = NULL;
 1304              	 .loc 1 830 0
 1305 0014 0023     	 movs r3,#0
 1306 0016 3B61     	 str r3,[r7,#16]
 831:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u8_t optlen;
 832:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u8_t optflags;
 833:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u8_t split_flags;
 834:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u8_t remainder_flags;
 835:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u16_t remainder;
 836:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u16_t offset;
 837:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 838:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u16_t chksum = 0;
 839:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u8_t chksum_swapped = 0;
 840:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct pbuf *q;
 841:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 842:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 843:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_split_unsent_seg: invalid pcb", pcb != NULL);
 844:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 845:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   useg = pcb->unsent;
 1307              	 .loc 1 845 0
 1308 0018 7B68     	 ldr r3,[r7,#4]
 1309 001a DB6E     	 ldr r3,[r3,#108]
 1310 001c 7B61     	 str r3,[r7,#20]
 846:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (useg == NULL) {
 1311              	 .loc 1 846 0
 1312 001e 7B69     	 ldr r3,[r7,#20]
 1313 0020 002B     	 cmp r3,#0
 1314 0022 01D1     	 bne .L69
 847:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return ERR_MEM;
 1315              	 .loc 1 847 0
 1316 0024 FF23     	 movs r3,#255
 1317 0026 EBE0     	 b .L70
 1318              	.L69:
 848:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 849:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 850:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (split == 0) {
 1319              	 .loc 1 850 0
 1320 0028 7B88     	 ldrh r3,[r7,#2]
 1321 002a 002B     	 cmp r3,#0
 1322 002c 01D1     	 bne .L71
 851:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_ASSERT("Can't split segment into length 0", 0);
 852:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return ERR_VAL;
 1323              	 .loc 1 852 0
 1324 002e FA23     	 movs r3,#250
 1325 0030 E6E0     	 b .L70
 1326              	.L71:
 853:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 854:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 855:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (useg->len <= split) {
 1327              	 .loc 1 855 0
 1328 0032 7B69     	 ldr r3,[r7,#20]
 1329 0034 1B89     	 ldrh r3,[r3,#8]
 1330 0036 7A88     	 ldrh r2,[r7,#2]
 1331 0038 9A42     	 cmp r2,r3
 1332 003a 01D3     	 bcc .L72
 856:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return ERR_OK;
 1333              	 .loc 1 856 0
 1334 003c 0023     	 movs r3,#0
 1335 003e DFE0     	 b .L70
 1336              	.L72:
 857:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 858:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 859:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("split <= mss", split <= pcb->mss);
 860:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("useg->len > 0", useg->len > 0);
 861:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 862:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* We should check that we don't exceed TCP_SND_QUEUELEN but we need
 863:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * to split this packet so we may actually exceed the max value by
 864:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * one!
 865:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    */
 866:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: split_unsent_seg: %u\n", (unsigned int)pcb->snd_queuel
 867:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 868:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   optflags = useg->flags;
 1337              	 .loc 1 868 0
 1338 0040 7B69     	 ldr r3,[r7,#20]
 1339 0042 9B7A     	 ldrb r3,[r3,#10]
 1340 0044 FB73     	 strb r3,[r7,#15]
 869:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 870:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Remove since checksum is not stored until after tcp_create_segment() */
 871:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   optflags &= ~TF_SEG_DATA_CHECKSUMMED;
 872:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 873:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   optlen = LWIP_TCP_OPT_LENGTH(optflags);
 1341              	 .loc 1 873 0
 1342 0046 FB7B     	 ldrb r3,[r7,#15]
 1343 0048 03F00103 	 and r3,r3,#1
 1344 004c 002B     	 cmp r3,#0
 1345 004e 01D0     	 beq .L73
 1346              	 .loc 1 873 0 is_stmt 0 discriminator 1
 1347 0050 0423     	 movs r3,#4
 1348 0052 00E0     	 b .L74
 1349              	.L73:
 1350              	 .loc 1 873 0 discriminator 2
 1351 0054 0023     	 movs r3,#0
 1352              	.L74:
 1353              	 .loc 1 873 0 discriminator 4
 1354 0056 BB73     	 strb r3,[r7,#14]
 874:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   remainder = useg->len - split;
 1355              	 .loc 1 874 0 is_stmt 1 discriminator 4
 1356 0058 7B69     	 ldr r3,[r7,#20]
 1357 005a 1A89     	 ldrh r2,[r3,#8]
 1358 005c 7B88     	 ldrh r3,[r7,#2]
 1359 005e D31A     	 subs r3,r2,r3
 1360 0060 BB81     	 strh r3,[r7,#12]
 875:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 876:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Create new pbuf for the remainder of the split */
 877:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   p = pbuf_alloc(PBUF_TRANSPORT, remainder + optlen, PBUF_RAM);
 1361              	 .loc 1 877 0 discriminator 4
 1362 0062 BB7B     	 ldrb r3,[r7,#14]
 1363 0064 9AB2     	 uxth r2,r3
 1364 0066 BB89     	 ldrh r3,[r7,#12]
 1365 0068 1344     	 add r3,r3,r2
 1366 006a 9BB2     	 uxth r3,r3
 1367 006c 3820     	 movs r0,#56
 1368 006e 1946     	 mov r1,r3
 1369 0070 4FF42072 	 mov r2,#640
 1370 0074 FFF7FEFF 	 bl pbuf_alloc
 1371 0078 3861     	 str r0,[r7,#16]
 878:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (p == NULL) {
 1372              	 .loc 1 878 0 discriminator 4
 1373 007a 3B69     	 ldr r3,[r7,#16]
 1374 007c 002B     	 cmp r3,#0
 1375 007e 00D1     	 bne .L75
 879:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
 880:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 ("tcp_split_unsent_seg: could not allocate memory for pbuf remainder %u\n", remaind
 881:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     goto memerr;
 1376              	 .loc 1 881 0
 1377 0080 B7E0     	 b .L76
 1378              	.L75:
 882:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 883:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 884:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Offset into the original pbuf is past TCP/IP headers, options, and split amount */
 885:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   offset = useg->p->tot_len - useg->len + split;
 1379              	 .loc 1 885 0
 1380 0082 7B69     	 ldr r3,[r7,#20]
 1381 0084 5B68     	 ldr r3,[r3,#4]
 1382 0086 1A89     	 ldrh r2,[r3,#8]
 1383 0088 7B69     	 ldr r3,[r7,#20]
 1384 008a 1B89     	 ldrh r3,[r3,#8]
 1385 008c D31A     	 subs r3,r2,r3
 1386 008e 9AB2     	 uxth r2,r3
 1387 0090 7B88     	 ldrh r3,[r7,#2]
 1388 0092 1344     	 add r3,r3,r2
 1389 0094 7B81     	 strh r3,[r7,#10]
 886:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Copy remainder into new pbuf, headers and options will not be filled out */
 887:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pbuf_copy_partial(useg->p, (u8_t *)p->payload + optlen, remainder, offset ) != remainder) {
 1390              	 .loc 1 887 0
 1391 0096 7B69     	 ldr r3,[r7,#20]
 1392 0098 5868     	 ldr r0,[r3,#4]
 1393 009a 3B69     	 ldr r3,[r7,#16]
 1394 009c 5A68     	 ldr r2,[r3,#4]
 1395 009e BB7B     	 ldrb r3,[r7,#14]
 1396 00a0 D118     	 adds r1,r2,r3
 1397 00a2 BA89     	 ldrh r2,[r7,#12]
 1398 00a4 7B89     	 ldrh r3,[r7,#10]
 1399 00a6 FFF7FEFF 	 bl pbuf_copy_partial
 1400 00aa 0346     	 mov r3,r0
 1401 00ac 1A46     	 mov r2,r3
 1402 00ae BB89     	 ldrh r3,[r7,#12]
 1403 00b0 9342     	 cmp r3,r2
 1404 00b2 00D0     	 beq .L77
 888:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
 889:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 ("tcp_split_unsent_seg: could not copy pbuf remainder %u\n", remainder));
 890:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     goto memerr;
 1405              	 .loc 1 890 0
 1406 00b4 9DE0     	 b .L76
 1407              	.L77:
 891:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 892:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 893:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* calculate the checksum on remainder data */
 894:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   tcp_seg_add_chksum(~inet_chksum((const u8_t *)p->payload + optlen, remainder), remainder,
 895:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                      &chksum, &chksum_swapped);
 896:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 897:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 898:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Options are created when calling tcp_output() */
 899:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 900:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Migrate flags from original segment */
 901:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   split_flags = TCPH_FLAGS(useg->tcphdr);
 1408              	 .loc 1 901 0
 1409 00b6 7B69     	 ldr r3,[r7,#20]
 1410 00b8 DB68     	 ldr r3,[r3,#12]
 1411 00ba 9B89     	 ldrh r3,[r3,#12]
 1412 00bc 9BB2     	 uxth r3,r3
 1413 00be 1846     	 mov r0,r3
 1414 00c0 FFF7FEFF 	 bl lwip_htons
 1415 00c4 0346     	 mov r3,r0
 1416 00c6 DBB2     	 uxtb r3,r3
 1417 00c8 03F03F03 	 and r3,r3,#63
 1418 00cc FB77     	 strb r3,[r7,#31]
 902:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   remainder_flags = 0; /* ACK added in tcp_output() */
 1419              	 .loc 1 902 0
 1420 00ce 0023     	 movs r3,#0
 1421 00d0 BB77     	 strb r3,[r7,#30]
 903:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 904:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (split_flags & TCP_PSH) {
 1422              	 .loc 1 904 0
 1423 00d2 FB7F     	 ldrb r3,[r7,#31]
 1424 00d4 03F00803 	 and r3,r3,#8
 1425 00d8 002B     	 cmp r3,#0
 1426 00da 07D0     	 beq .L78
 905:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     split_flags &= ~TCP_PSH;
 1427              	 .loc 1 905 0
 1428 00dc FB7F     	 ldrb r3,[r7,#31]
 1429 00de 23F00803 	 bic r3,r3,#8
 1430 00e2 FB77     	 strb r3,[r7,#31]
 906:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     remainder_flags |= TCP_PSH;
 1431              	 .loc 1 906 0
 1432 00e4 BB7F     	 ldrb r3,[r7,#30]
 1433 00e6 43F00803 	 orr r3,r3,#8
 1434 00ea BB77     	 strb r3,[r7,#30]
 1435              	.L78:
 907:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 908:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (split_flags & TCP_FIN) {
 1436              	 .loc 1 908 0
 1437 00ec FB7F     	 ldrb r3,[r7,#31]
 1438 00ee 03F00103 	 and r3,r3,#1
 1439 00f2 002B     	 cmp r3,#0
 1440 00f4 07D0     	 beq .L79
 909:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     split_flags &= ~TCP_FIN;
 1441              	 .loc 1 909 0
 1442 00f6 FB7F     	 ldrb r3,[r7,#31]
 1443 00f8 23F00103 	 bic r3,r3,#1
 1444 00fc FB77     	 strb r3,[r7,#31]
 910:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     remainder_flags |= TCP_FIN;
 1445              	 .loc 1 910 0
 1446 00fe BB7F     	 ldrb r3,[r7,#30]
 1447 0100 43F00103 	 orr r3,r3,#1
 1448 0104 BB77     	 strb r3,[r7,#30]
 1449              	.L79:
 911:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 912:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* SYN should be left on split, RST should not be present with data */
 913:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 914:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg = tcp_create_segment(pcb, p, remainder_flags, lwip_ntohl(useg->tcphdr->seqno) + split, optfla
 1450              	 .loc 1 914 0
 1451 0106 7B69     	 ldr r3,[r7,#20]
 1452 0108 DB68     	 ldr r3,[r3,#12]
 1453 010a 5B68     	 ldr r3,[r3,#4]
 1454 010c 1846     	 mov r0,r3
 1455 010e FFF7FEFF 	 bl lwip_htonl
 1456 0112 0246     	 mov r2,r0
 1457 0114 7B88     	 ldrh r3,[r7,#2]
 1458 0116 D418     	 adds r4,r2,r3
 1459 0118 BA7F     	 ldrb r2,[r7,#30]
 1460 011a FB7B     	 ldrb r3,[r7,#15]
 1461 011c 0093     	 str r3,[sp]
 1462 011e 7868     	 ldr r0,[r7,#4]
 1463 0120 3969     	 ldr r1,[r7,#16]
 1464 0122 2346     	 mov r3,r4
 1465 0124 FFF7FEFF 	 bl tcp_create_segment
 1466 0128 B861     	 str r0,[r7,#24]
 915:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (seg == NULL) {
 1467              	 .loc 1 915 0
 1468 012a BB69     	 ldr r3,[r7,#24]
 1469 012c 002B     	 cmp r3,#0
 1470 012e 00D1     	 bne .L80
 916:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
 917:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 ("tcp_split_unsent_seg: could not create new TCP segment\n"));
 918:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     goto memerr;
 1471              	 .loc 1 918 0
 1472 0130 5FE0     	 b .L76
 1473              	.L80:
 919:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 920:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 921:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 922:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->chksum = chksum;
 923:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->chksum_swapped = chksum_swapped;
 924:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->flags |= TF_SEG_DATA_CHECKSUMMED;
 925:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 926:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 927:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Remove this segment from the queue since trimming it may free pbufs */
 928:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   pcb->snd_queuelen -= pbuf_clen(useg->p);
 1474              	 .loc 1 928 0
 1475 0132 7B69     	 ldr r3,[r7,#20]
 1476 0134 5B68     	 ldr r3,[r3,#4]
 1477 0136 1846     	 mov r0,r3
 1478 0138 FFF7FEFF 	 bl pbuf_clen
 1479 013c 0346     	 mov r3,r0
 1480 013e 1A46     	 mov r2,r3
 1481 0140 7B68     	 ldr r3,[r7,#4]
 1482 0142 B3F86630 	 ldrh r3,[r3,#102]
 1483 0146 9B1A     	 subs r3,r3,r2
 1484 0148 9AB2     	 uxth r2,r3
 1485 014a 7B68     	 ldr r3,[r7,#4]
 1486 014c A3F86620 	 strh r2,[r3,#102]
 929:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 930:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Trim the original pbuf into our split size.  At this point our remainder segment must be setup
 931:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   successfully because we are modifying the original segment */
 932:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   pbuf_realloc(useg->p, useg->p->tot_len - remainder);
 1487              	 .loc 1 932 0
 1488 0150 7B69     	 ldr r3,[r7,#20]
 1489 0152 5968     	 ldr r1,[r3,#4]
 1490 0154 7B69     	 ldr r3,[r7,#20]
 1491 0156 5B68     	 ldr r3,[r3,#4]
 1492 0158 1A89     	 ldrh r2,[r3,#8]
 1493 015a BB89     	 ldrh r3,[r7,#12]
 1494 015c D31A     	 subs r3,r2,r3
 1495 015e 9BB2     	 uxth r3,r3
 1496 0160 0846     	 mov r0,r1
 1497 0162 1946     	 mov r1,r3
 1498 0164 FFF7FEFF 	 bl pbuf_realloc
 933:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   useg->len -= remainder;
 1499              	 .loc 1 933 0
 1500 0168 7B69     	 ldr r3,[r7,#20]
 1501 016a 1A89     	 ldrh r2,[r3,#8]
 1502 016c BB89     	 ldrh r3,[r7,#12]
 1503 016e D31A     	 subs r3,r2,r3
 1504 0170 9AB2     	 uxth r2,r3
 1505 0172 7B69     	 ldr r3,[r7,#20]
 1506 0174 1A81     	 strh r2,[r3,#8]
 934:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   TCPH_SET_FLAG(useg->tcphdr, split_flags);
 1507              	 .loc 1 934 0
 1508 0176 7B69     	 ldr r3,[r7,#20]
 1509 0178 DC68     	 ldr r4,[r3,#12]
 1510 017a 7B69     	 ldr r3,[r7,#20]
 1511 017c DB68     	 ldr r3,[r3,#12]
 1512 017e 9B89     	 ldrh r3,[r3,#12]
 1513 0180 9DB2     	 uxth r5,r3
 1514 0182 FB7F     	 ldrb r3,[r7,#31]
 1515 0184 9BB2     	 uxth r3,r3
 1516 0186 1846     	 mov r0,r3
 1517 0188 FFF7FEFF 	 bl lwip_htons
 1518 018c 0346     	 mov r3,r0
 1519 018e 2B43     	 orrs r3,r3,r5
 1520 0190 9BB2     	 uxth r3,r3
 1521 0192 A381     	 strh r3,[r4,#12]
 935:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_OVERSIZE_DBGCHECK
 936:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* By trimming, realloc may have actually shrunk the pbuf, so clear oversize_left */
 937:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   useg->oversize_left = 0;
 938:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_OVERSIZE_DBGCHECK */
 939:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 940:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Add back to the queue with new trimmed pbuf */
 941:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   pcb->snd_queuelen += pbuf_clen(useg->p);
 1522              	 .loc 1 941 0
 1523 0194 7B69     	 ldr r3,[r7,#20]
 1524 0196 5B68     	 ldr r3,[r3,#4]
 1525 0198 1846     	 mov r0,r3
 1526 019a FFF7FEFF 	 bl pbuf_clen
 1527 019e 0346     	 mov r3,r0
 1528 01a0 1A46     	 mov r2,r3
 1529 01a2 7B68     	 ldr r3,[r7,#4]
 1530 01a4 B3F86630 	 ldrh r3,[r3,#102]
 1531 01a8 1344     	 add r3,r3,r2
 1532 01aa 9AB2     	 uxth r2,r3
 1533 01ac 7B68     	 ldr r3,[r7,#4]
 1534 01ae A3F86620 	 strh r2,[r3,#102]
 942:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 943:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
 944:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* The checksum on the split segment is now incorrect. We need to re-run it over the split */
 945:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   useg->chksum = 0;
 946:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   useg->chksum_swapped = 0;
 947:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   q = useg->p;
 948:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   offset = q->tot_len - useg->len; /* Offset due to exposed headers */
 949:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 950:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Advance to the pbuf where the offset ends */
 951:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   while (q != NULL && offset > q->len) {
 952:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     offset -= q->len;
 953:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     q = q->next;
 954:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 955:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("Found start of payload pbuf", q != NULL);
 956:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Checksum the first payload pbuf accounting for offset, then other pbufs are all payload */
 957:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   for (; q != NULL; offset = 0, q = q->next) {
 958:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcp_seg_add_chksum(~inet_chksum((const u8_t *)q->payload + offset, q->len - offset), q->len - o
 959:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                        &useg->chksum, &useg->chksum_swapped);
 960:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 961:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
 962:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 963:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Update number of segments on the queues. Note that length now may
 964:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * exceed TCP_SND_QUEUELEN! We don't have to touch pcb->snd_buf
 965:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * because the total amount of data is constant when packet is split */
 966:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   pcb->snd_queuelen += pbuf_clen(seg->p);
 1535              	 .loc 1 966 0
 1536 01b2 BB69     	 ldr r3,[r7,#24]
 1537 01b4 5B68     	 ldr r3,[r3,#4]
 1538 01b6 1846     	 mov r0,r3
 1539 01b8 FFF7FEFF 	 bl pbuf_clen
 1540 01bc 0346     	 mov r3,r0
 1541 01be 1A46     	 mov r2,r3
 1542 01c0 7B68     	 ldr r3,[r7,#4]
 1543 01c2 B3F86630 	 ldrh r3,[r3,#102]
 1544 01c6 1344     	 add r3,r3,r2
 1545 01c8 9AB2     	 uxth r2,r3
 1546 01ca 7B68     	 ldr r3,[r7,#4]
 1547 01cc A3F86620 	 strh r2,[r3,#102]
 967:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 968:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Finally insert remainder into queue after split (which stays head) */
 969:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->next = useg->next;
 1548              	 .loc 1 969 0
 1549 01d0 7B69     	 ldr r3,[r7,#20]
 1550 01d2 1A68     	 ldr r2,[r3]
 1551 01d4 BB69     	 ldr r3,[r7,#24]
 1552 01d6 1A60     	 str r2,[r3]
 970:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   useg->next = seg;
 1553              	 .loc 1 970 0
 1554 01d8 7B69     	 ldr r3,[r7,#20]
 1555 01da BA69     	 ldr r2,[r7,#24]
 1556 01dc 1A60     	 str r2,[r3]
 971:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 972:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_OVERSIZE
 973:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* If remainder is last segment on the unsent, ensure we clear the oversize amount
 974:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    * because the remainder is always sized to the exact remaining amount */
 975:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (seg->next == NULL) {
 1557              	 .loc 1 975 0
 1558 01de BB69     	 ldr r3,[r7,#24]
 1559 01e0 1B68     	 ldr r3,[r3]
 1560 01e2 002B     	 cmp r3,#0
 1561 01e4 03D1     	 bne .L81
 976:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     pcb->unsent_oversize = 0;
 1562              	 .loc 1 976 0
 1563 01e6 7B68     	 ldr r3,[r7,#4]
 1564 01e8 0022     	 movs r2,#0
 1565 01ea A3F86820 	 strh r2,[r3,#104]
 1566              	.L81:
 977:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 978:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_OVERSIZE */
 979:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 980:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   return ERR_OK;
 1567              	 .loc 1 980 0
 1568 01ee 0023     	 movs r3,#0
 1569 01f0 06E0     	 b .L70
 1570              	.L76:
 981:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** memerr:
 982:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   TCP_STATS_INC(tcp.memerr);
 983:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 984:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("seg == NULL", seg == NULL);
 985:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (p != NULL) {
 1571              	 .loc 1 985 0
 1572 01f2 3B69     	 ldr r3,[r7,#16]
 1573 01f4 002B     	 cmp r3,#0
 1574 01f6 02D0     	 beq .L82
 986:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     pbuf_free(p);
 1575              	 .loc 1 986 0
 1576 01f8 3869     	 ldr r0,[r7,#16]
 1577 01fa FFF7FEFF 	 bl pbuf_free
 1578              	.L82:
 987:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
 988:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 989:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   return ERR_MEM;
 1579              	 .loc 1 989 0
 1580 01fe FF23     	 movs r3,#255
 1581              	.L70:
 1582 0200 5BB2     	 sxtb r3,r3
 990:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 1583              	 .loc 1 990 0
 1584 0202 1846     	 mov r0,r3
 1585 0204 2037     	 adds r7,r7,#32
 1586              	.LCFI29:
 1587              	 .cfi_def_cfa_offset 16
 1588 0206 BD46     	 mov sp,r7
 1589              	.LCFI30:
 1590              	 .cfi_def_cfa_register 13
 1591              	 
 1592 0208 B0BD     	 pop {r4,r5,r7,pc}
 1593              	 .cfi_endproc
 1594              	.LFE138:
 1596 020a 00BF     	 .section .text.tcp_send_fin,"ax",%progbits
 1597              	 .align 2
 1598              	 .global tcp_send_fin
 1599              	 .thumb
 1600              	 .thumb_func
 1602              	tcp_send_fin:
 1603              	.LFB139:
 991:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
 992:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /**
 993:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Called by tcp_close() to send a segment including FIN flag but not data.
 994:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * This FIN may be added to an existing segment or a new, otherwise empty
 995:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * segment is enqueued.
 996:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
 997:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb the tcp_pcb over which to send a segment
 998:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @return ERR_OK if sent, another err_t otherwise
 999:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
1000:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** err_t
1001:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_send_fin(struct tcp_pcb *pcb)
1002:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 1604              	 .loc 1 1002 0
 1605              	 .cfi_startproc
 1606              	 
 1607              	 
 1608 0000 B0B5     	 push {r4,r5,r7,lr}
 1609              	.LCFI31:
 1610              	 .cfi_def_cfa_offset 16
 1611              	 .cfi_offset 4,-16
 1612              	 .cfi_offset 5,-12
 1613              	 .cfi_offset 7,-8
 1614              	 .cfi_offset 14,-4
 1615 0002 84B0     	 sub sp,sp,#16
 1616              	.LCFI32:
 1617              	 .cfi_def_cfa_offset 32
 1618 0004 00AF     	 add r7,sp,#0
 1619              	.LCFI33:
 1620              	 .cfi_def_cfa_register 7
 1621 0006 7860     	 str r0,[r7,#4]
1003:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_send_fin: invalid pcb", pcb != NULL);
1004:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1005:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* first, try to add the fin to the last unsent segment */
1006:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pcb->unsent != NULL) {
 1622              	 .loc 1 1006 0
 1623 0008 7B68     	 ldr r3,[r7,#4]
 1624 000a DB6E     	 ldr r3,[r3,#108]
 1625 000c 002B     	 cmp r3,#0
 1626 000e 2DD0     	 beq .L84
 1627              	.LBB9:
1007:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     struct tcp_seg *last_unsent;
1008:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 1628              	 .loc 1 1008 0
 1629 0010 7B68     	 ldr r3,[r7,#4]
 1630 0012 DB6E     	 ldr r3,[r3,#108]
 1631 0014 FB60     	 str r3,[r7,#12]
 1632 0016 02E0     	 b .L85
 1633              	.L86:
1009:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****          last_unsent = last_unsent->next);
 1634              	 .loc 1 1009 0
 1635 0018 FB68     	 ldr r3,[r7,#12]
 1636 001a 1B68     	 ldr r3,[r3]
 1637 001c FB60     	 str r3,[r7,#12]
 1638              	.L85:
1008:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****          last_unsent = last_unsent->next);
 1639              	 .loc 1 1008 0 discriminator 1
 1640 001e FB68     	 ldr r3,[r7,#12]
 1641 0020 1B68     	 ldr r3,[r3]
 1642 0022 002B     	 cmp r3,#0
 1643 0024 F8D1     	 bne .L86
1010:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1011:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
 1644              	 .loc 1 1011 0
 1645 0026 FB68     	 ldr r3,[r7,#12]
 1646 0028 DB68     	 ldr r3,[r3,#12]
 1647 002a 9B89     	 ldrh r3,[r3,#12]
 1648 002c 9BB2     	 uxth r3,r3
 1649 002e 1846     	 mov r0,r3
 1650 0030 FFF7FEFF 	 bl lwip_htons
 1651 0034 0346     	 mov r3,r0
 1652 0036 DBB2     	 uxtb r3,r3
 1653 0038 03F00703 	 and r3,r3,#7
 1654 003c 002B     	 cmp r3,#0
 1655 003e 15D1     	 bne .L84
1012:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
1013:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
 1656              	 .loc 1 1013 0
 1657 0040 FB68     	 ldr r3,[r7,#12]
 1658 0042 DC68     	 ldr r4,[r3,#12]
 1659 0044 FB68     	 ldr r3,[r7,#12]
 1660 0046 DB68     	 ldr r3,[r3,#12]
 1661 0048 9B89     	 ldrh r3,[r3,#12]
 1662 004a 9DB2     	 uxth r5,r3
 1663 004c 0120     	 movs r0,#1
 1664 004e FFF7FEFF 	 bl lwip_htons
 1665 0052 0346     	 mov r3,r0
 1666 0054 2B43     	 orrs r3,r3,r5
 1667 0056 9BB2     	 uxth r3,r3
 1668 0058 A381     	 strh r3,[r4,#12]
1014:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       tcp_set_flags(pcb, TF_FIN);
 1669              	 .loc 1 1014 0
 1670 005a 7B68     	 ldr r3,[r7,#4]
 1671 005c 5B8B     	 ldrh r3,[r3,#26]
 1672 005e 43F02003 	 orr r3,r3,#32
 1673 0062 9AB2     	 uxth r2,r3
 1674 0064 7B68     	 ldr r3,[r7,#4]
 1675 0066 5A83     	 strh r2,[r3,#26]
1015:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       return ERR_OK;
 1676              	 .loc 1 1015 0
 1677 0068 0023     	 movs r3,#0
 1678 006a 04E0     	 b .L87
 1679              	.L84:
 1680              	.LBE9:
1016:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
1017:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1018:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* no data, no length, flags, copy=1, no optdata */
1019:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   return tcp_enqueue_flags(pcb, TCP_FIN);
 1681              	 .loc 1 1019 0
 1682 006c 7868     	 ldr r0,[r7,#4]
 1683 006e 0121     	 movs r1,#1
 1684 0070 FFF7FEFF 	 bl tcp_enqueue_flags
 1685 0074 0346     	 mov r3,r0
 1686              	.L87:
 1687 0076 5BB2     	 sxtb r3,r3
1020:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 1688              	 .loc 1 1020 0
 1689 0078 1846     	 mov r0,r3
 1690 007a 1037     	 adds r7,r7,#16
 1691              	.LCFI34:
 1692              	 .cfi_def_cfa_offset 16
 1693 007c BD46     	 mov sp,r7
 1694              	.LCFI35:
 1695              	 .cfi_def_cfa_register 13
 1696              	 
 1697 007e B0BD     	 pop {r4,r5,r7,pc}
 1698              	 .cfi_endproc
 1699              	.LFE139:
 1701              	 .section .text.tcp_enqueue_flags,"ax",%progbits
 1702              	 .align 2
 1703              	 .global tcp_enqueue_flags
 1704              	 .thumb
 1705              	 .thumb_func
 1707              	tcp_enqueue_flags:
 1708              	.LFB140:
1021:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1022:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /**
1023:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Enqueue SYN or FIN for transmission.
1024:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1025:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Called by @ref tcp_connect, tcp_listen_input, and @ref tcp_close
1026:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * (via @ref tcp_send_fin)
1027:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1028:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb Protocol control block for the TCP connection.
1029:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param flags TCP header flags to set in the outgoing segment.
1030:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
1031:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** err_t
1032:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
1033:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 1709              	 .loc 1 1033 0
 1710              	 .cfi_startproc
 1711              	 
 1712              	 
 1713 0000 90B5     	 push {r4,r7,lr}
 1714              	.LCFI36:
 1715              	 .cfi_def_cfa_offset 12
 1716              	 .cfi_offset 4,-12
 1717              	 .cfi_offset 7,-8
 1718              	 .cfi_offset 14,-4
 1719 0002 8BB0     	 sub sp,sp,#44
 1720              	.LCFI37:
 1721              	 .cfi_def_cfa_offset 56
 1722 0004 02AF     	 add r7,sp,#8
 1723              	.LCFI38:
 1724              	 .cfi_def_cfa 7,48
 1725 0006 7860     	 str r0,[r7,#4]
 1726 0008 0B46     	 mov r3,r1
 1727 000a FB70     	 strb r3,[r7,#3]
1034:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct pbuf *p;
1035:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct tcp_seg *seg;
1036:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u8_t optflags = 0;
 1728              	 .loc 1 1036 0
 1729 000c 0023     	 movs r3,#0
 1730 000e FB77     	 strb r3,[r7,#31]
1037:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u8_t optlen = 0;
 1731              	 .loc 1 1037 0
 1732 0010 0023     	 movs r3,#0
 1733 0012 FB75     	 strb r3,[r7,#23]
1038:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1039:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen)
1040:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1041:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)
1042:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****               (flags & (TCP_SYN | TCP_FIN)) != 0);
1043:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_enqueue_flags: invalid pcb", pcb != NULL);
1044:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1045:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* No need to check pcb->snd_queuelen if only SYN or FIN are allowed! */
1046:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1047:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Get options for this segment. This is a special case since this is the
1048:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      only place where a SYN can be sent. */
1049:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (flags & TCP_SYN) {
 1734              	 .loc 1 1049 0
 1735 0014 FB78     	 ldrb r3,[r7,#3]
 1736 0016 03F00203 	 and r3,r3,#2
 1737 001a 002B     	 cmp r3,#0
 1738 001c 01D0     	 beq .L89
1050:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     optflags = TF_SEG_OPTS_MSS;
 1739              	 .loc 1 1050 0
 1740 001e 0123     	 movs r3,#1
 1741 0020 FB77     	 strb r3,[r7,#31]
 1742              	.L89:
1051:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if LWIP_WND_SCALE
1052:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if ((pcb->state != SYN_RCVD) || (pcb->flags & TF_WND_SCALE)) {
1053:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       /* In a <SYN,ACK> (sent in state SYN_RCVD), the window scale option may only
1054:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****          be sent if we received a window scale option from the remote host. */
1055:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       optflags |= TF_SEG_OPTS_WND_SCALE;
1056:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
1057:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* LWIP_WND_SCALE */
1058:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if LWIP_TCP_SACK_OUT
1059:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if ((pcb->state != SYN_RCVD) || (pcb->flags & TF_SACK)) {
1060:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       /* In a <SYN,ACK> (sent in state SYN_RCVD), the SACK_PERM option may only
1061:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****          be sent if we received a SACK_PERM option from the remote host. */
1062:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       optflags |= TF_SEG_OPTS_SACK_PERM;
1063:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
1064:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* LWIP_TCP_SACK_OUT */
1065:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1066:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if LWIP_TCP_TIMESTAMPS
1067:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if ((pcb->flags & TF_TIMESTAMP) || ((flags & TCP_SYN) && (pcb->state != SYN_RCVD))) {
1068:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* Make sure the timestamp option is only included in data segments if we
1069:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****        agreed about it with the remote host (and in active open SYN segments). */
1070:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     optflags |= TF_SEG_OPTS_TS;
1071:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1072:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* LWIP_TCP_TIMESTAMPS */
1073:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 1743              	 .loc 1 1073 0
 1744 0022 FB7F     	 ldrb r3,[r7,#31]
 1745 0024 03F00103 	 and r3,r3,#1
 1746 0028 002B     	 cmp r3,#0
 1747 002a 01D0     	 beq .L90
 1748              	 .loc 1 1073 0 is_stmt 0 discriminator 1
 1749 002c 0423     	 movs r3,#4
 1750 002e 00E0     	 b .L91
 1751              	.L90:
 1752              	 .loc 1 1073 0 discriminator 2
 1753 0030 0023     	 movs r3,#0
 1754              	.L91:
 1755              	 .loc 1 1073 0 discriminator 4
 1756 0032 FB75     	 strb r3,[r7,#23]
1074:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1075:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Allocate pbuf with room for TCP header + options */
1076:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 1757              	 .loc 1 1076 0 is_stmt 1 discriminator 4
 1758 0034 FB7D     	 ldrb r3,[r7,#23]
 1759 0036 9BB2     	 uxth r3,r3
 1760 0038 3820     	 movs r0,#56
 1761 003a 1946     	 mov r1,r3
 1762 003c 4FF42072 	 mov r2,#640
 1763 0040 FFF7FEFF 	 bl pbuf_alloc
 1764 0044 3861     	 str r0,[r7,#16]
 1765 0046 3B69     	 ldr r3,[r7,#16]
 1766 0048 002B     	 cmp r3,#0
 1767 004a 08D1     	 bne .L92
1077:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcp_set_flags(pcb, TF_NAGLEMEMERR);
 1768              	 .loc 1 1077 0
 1769 004c 7B68     	 ldr r3,[r7,#4]
 1770 004e 5B8B     	 ldrh r3,[r3,#26]
 1771 0050 43F08003 	 orr r3,r3,#128
 1772 0054 9AB2     	 uxth r2,r3
 1773 0056 7B68     	 ldr r3,[r7,#4]
 1774 0058 5A83     	 strh r2,[r3,#26]
1078:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     TCP_STATS_INC(tcp.memerr);
1079:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return ERR_MEM;
 1775              	 .loc 1 1079 0
 1776 005a FF23     	 movs r3,#255
 1777 005c 5BE0     	 b .L93
 1778              	.L92:
1080:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1081:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
1082:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****               (p->len >= optlen));
1083:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1084:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Allocate memory for tcp_seg, and fill in fields. */
1085:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 1779              	 .loc 1 1085 0
 1780 005e 7B68     	 ldr r3,[r7,#4]
 1781 0060 DC6D     	 ldr r4,[r3,#92]
 1782 0062 FA78     	 ldrb r2,[r7,#3]
 1783 0064 FB7F     	 ldrb r3,[r7,#31]
 1784 0066 0093     	 str r3,[sp]
 1785 0068 7868     	 ldr r0,[r7,#4]
 1786 006a 3969     	 ldr r1,[r7,#16]
 1787 006c 2346     	 mov r3,r4
 1788 006e FFF7FEFF 	 bl tcp_create_segment
 1789 0072 F860     	 str r0,[r7,#12]
 1790 0074 FB68     	 ldr r3,[r7,#12]
 1791 0076 002B     	 cmp r3,#0
 1792 0078 08D1     	 bne .L94
1086:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcp_set_flags(pcb, TF_NAGLEMEMERR);
 1793              	 .loc 1 1086 0
 1794 007a 7B68     	 ldr r3,[r7,#4]
 1795 007c 5B8B     	 ldrh r3,[r3,#26]
 1796 007e 43F08003 	 orr r3,r3,#128
 1797 0082 9AB2     	 uxth r2,r3
 1798 0084 7B68     	 ldr r3,[r7,#4]
 1799 0086 5A83     	 strh r2,[r3,#26]
1087:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     TCP_STATS_INC(tcp.memerr);
1088:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return ERR_MEM;
 1800              	 .loc 1 1088 0
 1801 0088 FF23     	 movs r3,#255
 1802 008a 44E0     	 b .L93
 1803              	.L94:
1089:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1090:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) == 0
1091:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
1092:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1093:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE,
1094:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****               ("tcp_enqueue_flags: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
1095:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                lwip_ntohl(seg->tcphdr->seqno),
1096:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
1097:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                (u16_t)flags));
1098:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1099:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Now append seg to pcb->unsent queue */
1100:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pcb->unsent == NULL) {
 1804              	 .loc 1 1100 0
 1805 008c 7B68     	 ldr r3,[r7,#4]
 1806 008e DB6E     	 ldr r3,[r3,#108]
 1807 0090 002B     	 cmp r3,#0
 1808 0092 03D1     	 bne .L95
1101:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     pcb->unsent = seg;
 1809              	 .loc 1 1101 0
 1810 0094 7B68     	 ldr r3,[r7,#4]
 1811 0096 FA68     	 ldr r2,[r7,#12]
 1812 0098 DA66     	 str r2,[r3,#108]
 1813 009a 0DE0     	 b .L96
 1814              	.L95:
 1815              	.LBB10:
1102:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   } else {
1103:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     struct tcp_seg *useg;
1104:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 1816              	 .loc 1 1104 0
 1817 009c 7B68     	 ldr r3,[r7,#4]
 1818 009e DB6E     	 ldr r3,[r3,#108]
 1819 00a0 BB61     	 str r3,[r7,#24]
 1820 00a2 02E0     	 b .L97
 1821              	.L98:
 1822              	 .loc 1 1104 0 is_stmt 0 discriminator 3
 1823 00a4 BB69     	 ldr r3,[r7,#24]
 1824 00a6 1B68     	 ldr r3,[r3]
 1825 00a8 BB61     	 str r3,[r7,#24]
 1826              	.L97:
 1827              	 .loc 1 1104 0 discriminator 1
 1828 00aa BB69     	 ldr r3,[r7,#24]
 1829 00ac 1B68     	 ldr r3,[r3]
 1830 00ae 002B     	 cmp r3,#0
 1831 00b0 F8D1     	 bne .L98
1105:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     useg->next = seg;
 1832              	 .loc 1 1105 0 is_stmt 1
 1833 00b2 BB69     	 ldr r3,[r7,#24]
 1834 00b4 FA68     	 ldr r2,[r7,#12]
 1835 00b6 1A60     	 str r2,[r3]
 1836              	.L96:
 1837              	.LBE10:
1106:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1107:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_OVERSIZE
1108:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* The new unsent tail has no space */
1109:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   pcb->unsent_oversize = 0;
 1838              	 .loc 1 1109 0
 1839 00b8 7B68     	 ldr r3,[r7,#4]
 1840 00ba 0022     	 movs r2,#0
 1841 00bc A3F86820 	 strh r2,[r3,#104]
1110:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_OVERSIZE */
1111:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1112:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* SYN and FIN bump the sequence number */
1113:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 1842              	 .loc 1 1113 0
 1843 00c0 FB78     	 ldrb r3,[r7,#3]
 1844 00c2 03F00203 	 and r3,r3,#2
 1845 00c6 002B     	 cmp r3,#0
 1846 00c8 04D1     	 bne .L99
 1847              	 .loc 1 1113 0 is_stmt 0 discriminator 1
 1848 00ca FB78     	 ldrb r3,[r7,#3]
 1849 00cc 03F00103 	 and r3,r3,#1
 1850 00d0 002B     	 cmp r3,#0
 1851 00d2 04D0     	 beq .L100
 1852              	.L99:
1114:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     pcb->snd_lbb++;
 1853              	 .loc 1 1114 0 is_stmt 1
 1854 00d4 7B68     	 ldr r3,[r7,#4]
 1855 00d6 DB6D     	 ldr r3,[r3,#92]
 1856 00d8 5A1C     	 adds r2,r3,#1
 1857 00da 7B68     	 ldr r3,[r7,#4]
 1858 00dc DA65     	 str r2,[r3,#92]
 1859              	.L100:
1115:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* optlen does not influence snd_buf */
1116:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1117:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (flags & TCP_FIN) {
 1860              	 .loc 1 1117 0
 1861 00de FB78     	 ldrb r3,[r7,#3]
 1862 00e0 03F00103 	 and r3,r3,#1
 1863 00e4 002B     	 cmp r3,#0
 1864 00e6 06D0     	 beq .L101
1118:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcp_set_flags(pcb, TF_FIN);
 1865              	 .loc 1 1118 0
 1866 00e8 7B68     	 ldr r3,[r7,#4]
 1867 00ea 5B8B     	 ldrh r3,[r3,#26]
 1868 00ec 43F02003 	 orr r3,r3,#32
 1869 00f0 9AB2     	 uxth r2,r3
 1870 00f2 7B68     	 ldr r3,[r7,#4]
 1871 00f4 5A83     	 strh r2,[r3,#26]
 1872              	.L101:
1119:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1120:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1121:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* update number of segments on the queues */
1122:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   pcb->snd_queuelen += pbuf_clen(seg->p);
 1873              	 .loc 1 1122 0
 1874 00f6 FB68     	 ldr r3,[r7,#12]
 1875 00f8 5B68     	 ldr r3,[r3,#4]
 1876 00fa 1846     	 mov r0,r3
 1877 00fc FFF7FEFF 	 bl pbuf_clen
 1878 0100 0346     	 mov r3,r0
 1879 0102 1A46     	 mov r2,r3
 1880 0104 7B68     	 ldr r3,[r7,#4]
 1881 0106 B3F86630 	 ldrh r3,[r3,#102]
 1882 010a 1344     	 add r3,r3,r2
 1883 010c 9AB2     	 uxth r2,r3
 1884 010e 7B68     	 ldr r3,[r7,#4]
 1885 0110 A3F86620 	 strh r2,[r3,#102]
1123:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen)
1124:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pcb->snd_queuelen != 0) {
1125:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
1126:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 pcb->unacked != NULL || pcb->unsent != NULL);
1127:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1128:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1129:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   return ERR_OK;
 1886              	 .loc 1 1129 0
 1887 0114 0023     	 movs r3,#0
 1888              	.L93:
 1889 0116 5BB2     	 sxtb r3,r3
1130:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 1890              	 .loc 1 1130 0
 1891 0118 1846     	 mov r0,r3
 1892 011a 2437     	 adds r7,r7,#36
 1893              	.LCFI39:
 1894              	 .cfi_def_cfa_offset 12
 1895 011c BD46     	 mov sp,r7
 1896              	.LCFI40:
 1897              	 .cfi_def_cfa_register 13
 1898              	 
 1899 011e 90BD     	 pop {r4,r7,pc}
 1900              	 .cfi_endproc
 1901              	.LFE140:
 1903              	 .section .text.tcp_output,"ax",%progbits
 1904              	 .align 2
 1905              	 .global tcp_output
 1906              	 .thumb
 1907              	 .thumb_func
 1909              	tcp_output:
 1910              	.LFB141:
1131:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1132:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if LWIP_TCP_TIMESTAMPS
1133:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /* Build a timestamp option (12 bytes long) at the specified options pointer)
1134:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1135:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb tcp_pcb
1136:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param opts option pointer where to store the timestamp option
1137:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
1138:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** static void
1139:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_build_timestamp_option(const struct tcp_pcb *pcb, u32_t *opts)
1140:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
1141:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_build_timestamp_option: invalid pcb", pcb != NULL);
1142:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1143:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Pad with two NOP options to make everything nicely aligned */
1144:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   opts[0] = PP_HTONL(0x0101080A);
1145:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   opts[1] = lwip_htonl(sys_now());
1146:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   opts[2] = lwip_htonl(pcb->ts_recent);
1147:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
1148:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
1149:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1150:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if LWIP_TCP_SACK_OUT
1151:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /**
1152:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Calculates the number of SACK entries that should be generated.
1153:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * It takes into account whether TF_SACK flag is set,
1154:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * the number of SACK entries in tcp_pcb that are valid,
1155:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * as well as the available options size.
1156:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1157:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb tcp_pcb
1158:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param optlen the length of other TCP options (in bytes)
1159:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @return the number of SACK ranges that can be used
1160:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
1161:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** static u8_t
1162:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_get_num_sacks(const struct tcp_pcb *pcb, u8_t optlen)
1163:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
1164:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u8_t num_sacks = 0;
1165:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1166:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_get_num_sacks: invalid pcb", pcb != NULL);
1167:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1168:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pcb->flags & TF_SACK) {
1169:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     u8_t i;
1170:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1171:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* The first SACK takes up 12 bytes (it includes SACK header and two NOP options),
1172:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****        each additional one - 8 bytes. */
1173:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     optlen += 12;
1174:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1175:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* Max options size = 40, number of SACK array entries = LWIP_TCP_MAX_SACK_NUM */
1176:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     for (i = 0; (i < LWIP_TCP_MAX_SACK_NUM) && (optlen <= TCP_MAX_OPTION_BYTES) &&
1177:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****          LWIP_TCP_SACK_VALID(pcb, i); ++i) {
1178:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       ++num_sacks;
1179:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       optlen += 8;
1180:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
1181:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1182:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1183:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   return num_sacks;
1184:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
1185:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1186:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /** Build a SACK option (12 or more bytes long) at the specified options pointer)
1187:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1188:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb tcp_pcb
1189:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param opts option pointer where to store the SACK option
1190:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param num_sacks the number of SACKs to store
1191:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
1192:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** static void
1193:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_build_sack_option(const struct tcp_pcb *pcb, u32_t *opts, u8_t num_sacks)
1194:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
1195:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u8_t i;
1196:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1197:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_build_sack_option: invalid pcb", pcb != NULL);
1198:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_build_sack_option: invalid opts", opts != NULL);
1199:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1200:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Pad with two NOP options to make everything nicely aligned.
1201:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      We add the length (of just the SACK option, not the NOPs in front of it),
1202:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      which is 2B of header, plus 8B for each SACK. */
1203:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   *(opts++) = PP_HTONL(0x01010500 + 2 + num_sacks * 8);
1204:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1205:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   for (i = 0; i < num_sacks; ++i) {
1206:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     *(opts++) = lwip_htonl(pcb->rcv_sacks[i].left);
1207:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     *(opts++) = lwip_htonl(pcb->rcv_sacks[i].right);
1208:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1209:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
1210:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1211:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
1212:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1213:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if LWIP_WND_SCALE
1214:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /** Build a window scale option (3 bytes long) at the specified options pointer)
1215:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1216:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param opts option pointer where to store the window scale option
1217:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
1218:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** static void
1219:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_build_wnd_scale_option(u32_t *opts)
1220:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
1221:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_build_wnd_scale_option: invalid opts", opts != NULL);
1222:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1223:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Pad with one NOP option to make everything nicely aligned */
1224:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   opts[0] = PP_HTONL(0x01030300 | TCP_RCV_SCALE);
1225:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
1226:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
1227:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1228:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /**
1229:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @ingroup tcp_raw
1230:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Find out what we can send and send it
1231:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1232:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb Protocol control block for the TCP connection to send data
1233:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @return ERR_OK if data has been sent or nothing to send
1234:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *         another err_t on error
1235:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
1236:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** err_t
1237:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_output(struct tcp_pcb *pcb)
1238:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 1911              	 .loc 1 1238 0
 1912              	 .cfi_startproc
 1913              	 
 1914              	 
 1915 0000 B0B5     	 push {r4,r5,r7,lr}
 1916              	.LCFI41:
 1917              	 .cfi_def_cfa_offset 16
 1918              	 .cfi_offset 4,-16
 1919              	 .cfi_offset 5,-12
 1920              	 .cfi_offset 7,-8
 1921              	 .cfi_offset 14,-4
 1922 0002 8AB0     	 sub sp,sp,#40
 1923              	.LCFI42:
 1924              	 .cfi_def_cfa_offset 56
 1925 0004 00AF     	 add r7,sp,#0
 1926              	.LCFI43:
 1927              	 .cfi_def_cfa_register 7
 1928 0006 7860     	 str r0,[r7,#4]
1239:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct tcp_seg *seg, *useg;
1240:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u32_t wnd, snd_nxt;
1241:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   err_t err;
1242:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct netif *netif;
1243:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CWND_DEBUG
1244:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   s16_t i = 0;
1245:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_CWND_DEBUG */
1246:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1247:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT_CORE_LOCKED();
1248:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1249:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_output: invalid pcb", pcb != NULL);
1250:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* pcb->state LISTEN not allowed here */
1251:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("don't call tcp_output for listen-pcbs",
1252:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****               pcb->state != LISTEN);
1253:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1254:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* First, check if we are invoked by the TCP input processing
1255:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      code. If so, we do not output anything. Instead, we rely on the
1256:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      input processing code to call us when input processing is done
1257:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      with. */
1258:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (tcp_input_pcb == pcb) {
 1929              	 .loc 1 1258 0
 1930 0008 A04B     	 ldr r3,.L144
 1931 000a 1A68     	 ldr r2,[r3]
 1932 000c 7B68     	 ldr r3,[r7,#4]
 1933 000e 9A42     	 cmp r2,r3
 1934 0010 01D1     	 bne .L103
1259:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return ERR_OK;
 1935              	 .loc 1 1259 0
 1936 0012 0023     	 movs r3,#0
 1937 0014 A3E1     	 b .L104
 1938              	.L103:
1260:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1261:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1262:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 1939              	 .loc 1 1262 0
 1940 0016 7B68     	 ldr r3,[r7,#4]
 1941 0018 B3F84820 	 ldrh r2,[r3,#72]
 1942 001c 7B68     	 ldr r3,[r7,#4]
 1943 001e B3F86030 	 ldrh r3,[r3,#96]
 1944 0022 9342     	 cmp r3,r2
 1945 0024 28BF     	 it cs
 1946 0026 1346     	 movcs r3,r2
 1947 0028 9BB2     	 uxth r3,r3
 1948 002a BB61     	 str r3,[r7,#24]
1263:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1264:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg = pcb->unsent;
 1949              	 .loc 1 1264 0
 1950 002c 7B68     	 ldr r3,[r7,#4]
 1951 002e DB6E     	 ldr r3,[r3,#108]
 1952 0030 7B62     	 str r3,[r7,#36]
1265:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1266:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (seg == NULL) {
 1953              	 .loc 1 1266 0
 1954 0032 7B6A     	 ldr r3,[r7,#36]
 1955 0034 002B     	 cmp r3,#0
 1956 0036 0BD1     	 bne .L105
1267:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: nothing to send (%p)\n",
1268:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                                    (void *)pcb->unsent));
1269:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"TCPWNDSIZE_F
1270:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                                  ", cwnd %"TCPWNDSIZE_F", wnd %"U32_F
1271:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                                  ", seg == NULL, ack %"U32_F"\n",
1272:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                                  pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));
1273:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1274:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* If the TF_ACK_NOW flag is set and the ->unsent queue is empty, construct
1275:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * an empty ACK segment and send it. */
1276:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if (pcb->flags & TF_ACK_NOW) {
 1957              	 .loc 1 1276 0
 1958 0038 7B68     	 ldr r3,[r7,#4]
 1959 003a 5B8B     	 ldrh r3,[r3,#26]
 1960 003c 03F00203 	 and r3,r3,#2
 1961 0040 002B     	 cmp r3,#0
 1962 0042 04D0     	 beq .L106
1277:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       return tcp_send_empty_ack(pcb);
 1963              	 .loc 1 1277 0
 1964 0044 7868     	 ldr r0,[r7,#4]
 1965 0046 FFF7FEFF 	 bl tcp_send_empty_ack
 1966 004a 0346     	 mov r3,r0
 1967 004c 87E1     	 b .L104
 1968              	.L106:
1278:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
1279:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* nothing to send: shortcut out of here */
1280:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     goto output_done;
 1969              	 .loc 1 1280 0
 1970 004e 7EE1     	 b .L107
 1971              	.L105:
1281:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   } else {
1282:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_CWND_DEBUG,
1283:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 ("tcp_output: snd_wnd %"TCPWNDSIZE_F", cwnd %"TCPWNDSIZE_F", wnd %"U32_F
1284:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                  ", effwnd %"U32_F", seq %"U32_F", ack %"U32_F"\n",
1285:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                  pcb->snd_wnd, pcb->cwnd, wnd,
1286:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                  lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
1287:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                  lwip_ntohl(seg->tcphdr->seqno), pcb->lastack));
1288:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1289:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1290:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   netif = tcp_route(pcb, &pcb->local_ip, &pcb->remote_ip);
 1972              	 .loc 1 1290 0
 1973 0050 7A68     	 ldr r2,[r7,#4]
 1974 0052 7B68     	 ldr r3,[r7,#4]
 1975 0054 0433     	 adds r3,r3,#4
 1976 0056 7868     	 ldr r0,[r7,#4]
 1977 0058 1146     	 mov r1,r2
 1978 005a 1A46     	 mov r2,r3
 1979 005c FFF7FEFF 	 bl tcp_route
 1980 0060 7861     	 str r0,[r7,#20]
1291:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (netif == NULL) {
 1981              	 .loc 1 1291 0
 1982 0062 7B69     	 ldr r3,[r7,#20]
 1983 0064 002B     	 cmp r3,#0
 1984 0066 01D1     	 bne .L108
1292:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return ERR_RTE;
 1985              	 .loc 1 1292 0
 1986 0068 FC23     	 movs r3,#252
 1987 006a 78E1     	 b .L104
 1988              	.L108:
1293:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1294:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1295:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* If we don't have a local IP address, we get one from netif */
1296:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (ip_addr_isany(&pcb->local_ip)) {
 1989              	 .loc 1 1296 0
 1990 006c 7B68     	 ldr r3,[r7,#4]
 1991 006e 002B     	 cmp r3,#0
 1992 0070 03D0     	 beq .L109
 1993              	 .loc 1 1296 0 is_stmt 0 discriminator 1
 1994 0072 7B68     	 ldr r3,[r7,#4]
 1995 0074 1B68     	 ldr r3,[r3]
 1996 0076 002B     	 cmp r3,#0
 1997 0078 10D1     	 bne .L110
 1998              	.L109:
 1999              	.LBB11:
1297:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     const ip_addr_t *local_ip = ip_netif_get_local_ip(netif, &pcb->remote_ip);
 2000              	 .loc 1 1297 0 is_stmt 1
 2001 007a 7B69     	 ldr r3,[r7,#20]
 2002 007c 002B     	 cmp r3,#0
 2003 007e 02D0     	 beq .L111
 2004              	 .loc 1 1297 0 is_stmt 0 discriminator 1
 2005 0080 7B69     	 ldr r3,[r7,#20]
 2006 0082 0433     	 adds r3,r3,#4
 2007 0084 00E0     	 b .L112
 2008              	.L111:
 2009              	 .loc 1 1297 0 discriminator 2
 2010 0086 0023     	 movs r3,#0
 2011              	.L112:
 2012              	 .loc 1 1297 0 discriminator 4
 2013 0088 3B61     	 str r3,[r7,#16]
1298:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if (local_ip == NULL) {
 2014              	 .loc 1 1298 0 is_stmt 1 discriminator 4
 2015 008a 3B69     	 ldr r3,[r7,#16]
 2016 008c 002B     	 cmp r3,#0
 2017 008e 01D1     	 bne .L113
1299:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       return ERR_RTE;
 2018              	 .loc 1 1299 0
 2019 0090 FC23     	 movs r3,#252
 2020 0092 64E1     	 b .L104
 2021              	.L113:
1300:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
1301:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     ip_addr_copy(pcb->local_ip, *local_ip);
 2022              	 .loc 1 1301 0
 2023 0094 3B69     	 ldr r3,[r7,#16]
 2024 0096 1A68     	 ldr r2,[r3]
 2025 0098 7B68     	 ldr r3,[r7,#4]
 2026 009a 1A60     	 str r2,[r3]
 2027              	.L110:
 2028              	.LBE11:
1302:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1303:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1304:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Handle the current segment not fitting within the window */
1305:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd) {
 2029              	 .loc 1 1305 0
 2030 009c 7B6A     	 ldr r3,[r7,#36]
 2031 009e DB68     	 ldr r3,[r3,#12]
 2032 00a0 5B68     	 ldr r3,[r3,#4]
 2033 00a2 1846     	 mov r0,r3
 2034 00a4 FFF7FEFF 	 bl lwip_htonl
 2035 00a8 0246     	 mov r2,r0
 2036 00aa 7B68     	 ldr r3,[r7,#4]
 2037 00ac 5B6C     	 ldr r3,[r3,#68]
 2038 00ae D31A     	 subs r3,r2,r3
 2039 00b0 7A6A     	 ldr r2,[r7,#36]
 2040 00b2 1289     	 ldrh r2,[r2,#8]
 2041 00b4 1A44     	 add r2,r2,r3
 2042 00b6 BB69     	 ldr r3,[r7,#24]
 2043 00b8 9A42     	 cmp r2,r3
 2044 00ba 27D9     	 bls .L114
1306:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* We need to start the persistent timer when the next unsent segment does not fit
1307:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * within the remaining (could be 0) send window and RTO timer is not running (we
1308:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * have no in-flight data). If window is still too small after persist timer fires,
1309:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * then we split the segment. We don't consider the congestion window since a cwnd
1310:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * smaller than 1 SMSS implies in-flight data
1311:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      */
1312:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if (wnd == pcb->snd_wnd && pcb->unacked == NULL && pcb->persist_backoff == 0) {
 2045              	 .loc 1 1312 0
 2046 00bc 7B68     	 ldr r3,[r7,#4]
 2047 00be B3F86030 	 ldrh r3,[r3,#96]
 2048 00c2 1A46     	 mov r2,r3
 2049 00c4 BB69     	 ldr r3,[r7,#24]
 2050 00c6 9A42     	 cmp r2,r3
 2051 00c8 14D1     	 bne .L115
 2052              	 .loc 1 1312 0 is_stmt 0 discriminator 1
 2053 00ca 7B68     	 ldr r3,[r7,#4]
 2054 00cc 1B6F     	 ldr r3,[r3,#112]
 2055 00ce 002B     	 cmp r3,#0
 2056 00d0 10D1     	 bne .L115
 2057              	 .loc 1 1312 0 discriminator 2
 2058 00d2 7B68     	 ldr r3,[r7,#4]
 2059 00d4 93F89930 	 ldrb r3,[r3,#153]
 2060 00d8 002B     	 cmp r3,#0
 2061 00da 0BD1     	 bne .L115
1313:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       pcb->persist_cnt = 0;
 2062              	 .loc 1 1313 0 is_stmt 1
 2063 00dc 7B68     	 ldr r3,[r7,#4]
 2064 00de 0022     	 movs r2,#0
 2065 00e0 83F89820 	 strb r2,[r3,#152]
1314:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       pcb->persist_backoff = 1;
 2066              	 .loc 1 1314 0
 2067 00e4 7B68     	 ldr r3,[r7,#4]
 2068 00e6 0122     	 movs r2,#1
 2069 00e8 83F89920 	 strb r2,[r3,#153]
1315:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       pcb->persist_probe = 0;
 2070              	 .loc 1 1315 0
 2071 00ec 7B68     	 ldr r3,[r7,#4]
 2072 00ee 0022     	 movs r2,#0
 2073 00f0 83F89A20 	 strb r2,[r3,#154]
 2074              	.L115:
1316:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
1317:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* We need an ACK, but can't send data now, so send an empty ACK */
1318:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if (pcb->flags & TF_ACK_NOW) {
 2075              	 .loc 1 1318 0
 2076 00f4 7B68     	 ldr r3,[r7,#4]
 2077 00f6 5B8B     	 ldrh r3,[r3,#26]
 2078 00f8 03F00203 	 and r3,r3,#2
 2079 00fc 002B     	 cmp r3,#0
 2080 00fe 04D0     	 beq .L116
1319:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       return tcp_send_empty_ack(pcb);
 2081              	 .loc 1 1319 0
 2082 0100 7868     	 ldr r0,[r7,#4]
 2083 0102 FFF7FEFF 	 bl tcp_send_empty_ack
 2084 0106 0346     	 mov r3,r0
 2085 0108 29E1     	 b .L104
 2086              	.L116:
1320:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
1321:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     goto output_done;
 2087              	 .loc 1 1321 0
 2088 010a 20E1     	 b .L107
 2089              	.L114:
1322:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1323:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Stop persist timer, above conditions are not active */
1324:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   pcb->persist_backoff = 0;
 2090              	 .loc 1 1324 0
 2091 010c 7B68     	 ldr r3,[r7,#4]
 2092 010e 0022     	 movs r2,#0
 2093 0110 83F89920 	 strb r2,[r3,#153]
1325:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1326:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* useg should point to last segment on unacked queue */
1327:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   useg = pcb->unacked;
 2094              	 .loc 1 1327 0
 2095 0114 7B68     	 ldr r3,[r7,#4]
 2096 0116 1B6F     	 ldr r3,[r3,#112]
 2097 0118 3B62     	 str r3,[r7,#32]
1328:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (useg != NULL) {
 2098              	 .loc 1 1328 0
 2099 011a 3B6A     	 ldr r3,[r7,#32]
 2100 011c 002B     	 cmp r3,#0
 2101 011e 07D0     	 beq .L117
1329:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     for (; useg->next != NULL; useg = useg->next);
 2102              	 .loc 1 1329 0
 2103 0120 02E0     	 b .L118
 2104              	.L119:
 2105              	 .loc 1 1329 0 is_stmt 0 discriminator 2
 2106 0122 3B6A     	 ldr r3,[r7,#32]
 2107 0124 1B68     	 ldr r3,[r3]
 2108 0126 3B62     	 str r3,[r7,#32]
 2109              	.L118:
 2110              	 .loc 1 1329 0 discriminator 1
 2111 0128 3B6A     	 ldr r3,[r7,#32]
 2112 012a 1B68     	 ldr r3,[r3]
 2113 012c 002B     	 cmp r3,#0
 2114 012e F8D1     	 bne .L119
 2115              	.L117:
1330:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1331:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* data available and window allows it to be sent? */
1332:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   while (seg != NULL &&
 2116              	 .loc 1 1332 0 is_stmt 1
 2117 0130 F1E0     	 b .L120
 2118              	.L143:
1333:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****          lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
1334:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_ASSERT("RST not expected here!",
1335:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 (TCPH_FLAGS(seg->tcphdr) & TCP_RST) == 0);
1336:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* Stop sending if the nagle algorithm would prevent it
1337:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * Don't stop:
1338:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
1339:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
1340:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      *   either seg->next != NULL or pcb->unacked == NULL;
1341:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      *   RST is no sent using tcp_write/tcp_output.
1342:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      */
1343:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if ((tcp_do_output_nagle(pcb) == 0) &&
 2119              	 .loc 1 1343 0
 2120 0132 7B68     	 ldr r3,[r7,#4]
 2121 0134 1B6F     	 ldr r3,[r3,#112]
 2122 0136 002B     	 cmp r3,#0
 2123 0138 1FD0     	 beq .L121
 2124              	 .loc 1 1343 0 is_stmt 0 discriminator 2
 2125 013a 7B68     	 ldr r3,[r7,#4]
 2126 013c 5B8B     	 ldrh r3,[r3,#26]
 2127 013e 03F04403 	 and r3,r3,#68
 2128 0142 002B     	 cmp r3,#0
 2129 0144 19D1     	 bne .L121
 2130              	 .loc 1 1343 0 discriminator 4
 2131 0146 7B68     	 ldr r3,[r7,#4]
 2132 0148 DB6E     	 ldr r3,[r3,#108]
 2133 014a 002B     	 cmp r3,#0
 2134 014c 0BD0     	 beq .L122
 2135              	 .loc 1 1343 0 discriminator 5
 2136 014e 7B68     	 ldr r3,[r7,#4]
 2137 0150 DB6E     	 ldr r3,[r3,#108]
 2138 0152 1B68     	 ldr r3,[r3]
 2139 0154 002B     	 cmp r3,#0
 2140 0156 10D1     	 bne .L121
 2141              	 .loc 1 1343 0 discriminator 8
 2142 0158 7B68     	 ldr r3,[r7,#4]
 2143 015a DB6E     	 ldr r3,[r3,#108]
 2144 015c 1A89     	 ldrh r2,[r3,#8]
 2145 015e 7B68     	 ldr r3,[r7,#4]
 2146 0160 5B8E     	 ldrh r3,[r3,#50]
 2147 0162 9A42     	 cmp r2,r3
 2148 0164 09D2     	 bcs .L121
 2149              	.L122:
 2150              	 .loc 1 1343 0 discriminator 10
 2151 0166 7B68     	 ldr r3,[r7,#4]
 2152 0168 B3F86430 	 ldrh r3,[r3,#100]
 2153 016c 002B     	 cmp r3,#0
 2154 016e 04D0     	 beq .L121
 2155              	 .loc 1 1343 0 discriminator 12
 2156 0170 7B68     	 ldr r3,[r7,#4]
 2157 0172 B3F86630 	 ldrh r3,[r3,#102]
 2158 0176 072B     	 cmp r3,#7
 2159 0178 01D9     	 bls .L123
 2160              	.L121:
 2161              	 .loc 1 1343 0 discriminator 13
 2162 017a 0123     	 movs r3,#1
 2163 017c 00E0     	 b .L124
 2164              	.L123:
 2165              	 .loc 1 1343 0 discriminator 14
 2166 017e 0023     	 movs r3,#0
 2167              	.L124:
 2168              	 .loc 1 1343 0 discriminator 16
 2169 0180 002B     	 cmp r3,#0
 2170 0182 06D1     	 bne .L125
1344:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
 2171              	 .loc 1 1344 0 is_stmt 1 discriminator 17
 2172 0184 7B68     	 ldr r3,[r7,#4]
 2173 0186 5B8B     	 ldrh r3,[r3,#26]
 2174 0188 03F0A003 	 and r3,r3,#160
1343:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
 2175              	 .loc 1 1343 0 discriminator 17
 2176 018c 002B     	 cmp r3,#0
 2177 018e 00D1     	 bne .L125
1345:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       break;
 2178              	 .loc 1 1345 0
 2179 0190 D5E0     	 b .L126
 2180              	.L125:
1346:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
1347:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CWND_DEBUG
1348:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"TCPWNDSIZE_F", cwnd %"TCPWNDSIZE_F", wnd %"
1349:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                                  pcb->snd_wnd, pcb->cwnd, wnd,
1350:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                                  lwip_ntohl(seg->tcphdr->seqno) + seg->len -
1351:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                                  pcb->lastack,
1352:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                                  lwip_ntohl(seg->tcphdr->seqno), pcb->lastack, i));
1353:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     ++i;
1354:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_CWND_DEBUG */
1355:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1356:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if (pcb->state != SYN_SENT) {
 2181              	 .loc 1 1356 0
 2182 0192 7B68     	 ldr r3,[r7,#4]
 2183 0194 1B7D     	 ldrb r3,[r3,#20]
 2184 0196 022B     	 cmp r3,#2
 2185 0198 0CD0     	 beq .L127
1357:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 2186              	 .loc 1 1357 0
 2187 019a 7B6A     	 ldr r3,[r7,#36]
 2188 019c DC68     	 ldr r4,[r3,#12]
 2189 019e 7B6A     	 ldr r3,[r7,#36]
 2190 01a0 DB68     	 ldr r3,[r3,#12]
 2191 01a2 9B89     	 ldrh r3,[r3,#12]
 2192 01a4 9DB2     	 uxth r5,r3
 2193 01a6 1020     	 movs r0,#16
 2194 01a8 FFF7FEFF 	 bl lwip_htons
 2195 01ac 0346     	 mov r3,r0
 2196 01ae 2B43     	 orrs r3,r3,r5
 2197 01b0 9BB2     	 uxth r3,r3
 2198 01b2 A381     	 strh r3,[r4,#12]
 2199              	.L127:
1358:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
1359:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1360:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     err = tcp_output_segment(seg, pcb, netif);
 2200              	 .loc 1 1360 0
 2201 01b4 786A     	 ldr r0,[r7,#36]
 2202 01b6 7968     	 ldr r1,[r7,#4]
 2203 01b8 7A69     	 ldr r2,[r7,#20]
 2204 01ba FFF7FEFF 	 bl tcp_output_segment
 2205 01be 0346     	 mov r3,r0
 2206 01c0 FB73     	 strb r3,[r7,#15]
1361:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if (err != ERR_OK) {
 2207              	 .loc 1 1361 0
 2208 01c2 97F90F30 	 ldrsb r3,[r7,#15]
 2209 01c6 002B     	 cmp r3,#0
 2210 01c8 08D0     	 beq .L128
1362:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       /* segment could not be sent, for whatever reason */
1363:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       tcp_set_flags(pcb, TF_NAGLEMEMERR);
 2211              	 .loc 1 1363 0
 2212 01ca 7B68     	 ldr r3,[r7,#4]
 2213 01cc 5B8B     	 ldrh r3,[r3,#26]
 2214 01ce 43F08003 	 orr r3,r3,#128
 2215 01d2 9AB2     	 uxth r2,r3
 2216 01d4 7B68     	 ldr r3,[r7,#4]
 2217 01d6 5A83     	 strh r2,[r3,#26]
1364:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       return err;
 2218              	 .loc 1 1364 0
 2219 01d8 FB7B     	 ldrb r3,[r7,#15]
 2220 01da C0E0     	 b .L104
 2221              	.L128:
1365:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
1366:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_OVERSIZE_DBGCHECK
1367:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     seg->oversize_left = 0;
1368:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_OVERSIZE_DBGCHECK */
1369:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     pcb->unsent = seg->next;
 2222              	 .loc 1 1369 0
 2223 01dc 7B6A     	 ldr r3,[r7,#36]
 2224 01de 1A68     	 ldr r2,[r3]
 2225 01e0 7B68     	 ldr r3,[r7,#4]
 2226 01e2 DA66     	 str r2,[r3,#108]
1370:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if (pcb->state != SYN_SENT) {
 2227              	 .loc 1 1370 0
 2228 01e4 7B68     	 ldr r3,[r7,#4]
 2229 01e6 1B7D     	 ldrb r3,[r3,#20]
 2230 01e8 022B     	 cmp r3,#2
 2231 01ea 06D0     	 beq .L129
1371:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 2232              	 .loc 1 1371 0
 2233 01ec 7B68     	 ldr r3,[r7,#4]
 2234 01ee 5B8B     	 ldrh r3,[r3,#26]
 2235 01f0 23F00303 	 bic r3,r3,#3
 2236 01f4 9AB2     	 uxth r2,r3
 2237 01f6 7B68     	 ldr r3,[r7,#4]
 2238 01f8 5A83     	 strh r2,[r3,#26]
 2239              	.L129:
1372:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
1373:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 2240              	 .loc 1 1373 0
 2241 01fa 7B6A     	 ldr r3,[r7,#36]
 2242 01fc DB68     	 ldr r3,[r3,#12]
 2243 01fe 5B68     	 ldr r3,[r3,#4]
 2244 0200 1846     	 mov r0,r3
 2245 0202 FFF7FEFF 	 bl lwip_htonl
 2246 0206 0446     	 mov r4,r0
 2247 0208 7B6A     	 ldr r3,[r7,#36]
 2248 020a 1B89     	 ldrh r3,[r3,#8]
 2249 020c 1D46     	 mov r5,r3
 2250 020e 7B6A     	 ldr r3,[r7,#36]
 2251 0210 DB68     	 ldr r3,[r3,#12]
 2252 0212 9B89     	 ldrh r3,[r3,#12]
 2253 0214 9BB2     	 uxth r3,r3
 2254 0216 1846     	 mov r0,r3
 2255 0218 FFF7FEFF 	 bl lwip_htons
 2256 021c 0346     	 mov r3,r0
 2257 021e DBB2     	 uxtb r3,r3
 2258 0220 03F00303 	 and r3,r3,#3
 2259 0224 002B     	 cmp r3,#0
 2260 0226 01D0     	 beq .L130
 2261              	 .loc 1 1373 0 is_stmt 0 discriminator 1
 2262 0228 0123     	 movs r3,#1
 2263 022a 00E0     	 b .L131
 2264              	.L130:
 2265              	 .loc 1 1373 0 discriminator 2
 2266 022c 0023     	 movs r3,#0
 2267              	.L131:
 2268              	 .loc 1 1373 0 discriminator 4
 2269 022e 2B44     	 add r3,r3,r5
 2270 0230 2344     	 add r3,r3,r4
 2271 0232 BB60     	 str r3,[r7,#8]
1374:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 2272              	 .loc 1 1374 0 is_stmt 1 discriminator 4
 2273 0234 7B68     	 ldr r3,[r7,#4]
 2274 0236 1A6D     	 ldr r2,[r3,#80]
 2275 0238 BB68     	 ldr r3,[r7,#8]
 2276 023a D31A     	 subs r3,r2,r3
 2277 023c 002B     	 cmp r3,#0
 2278 023e 02DA     	 bge .L132
1375:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       pcb->snd_nxt = snd_nxt;
 2279              	 .loc 1 1375 0
 2280 0240 7B68     	 ldr r3,[r7,#4]
 2281 0242 BA68     	 ldr r2,[r7,#8]
 2282 0244 1A65     	 str r2,[r3,#80]
 2283              	.L132:
1376:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
1377:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* put segment on unacknowledged list if length > 0 */
1378:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if (TCP_TCPLEN(seg) > 0) {
 2284              	 .loc 1 1378 0
 2285 0246 7B6A     	 ldr r3,[r7,#36]
 2286 0248 1B89     	 ldrh r3,[r3,#8]
 2287 024a 1C46     	 mov r4,r3
 2288 024c 7B6A     	 ldr r3,[r7,#36]
 2289 024e DB68     	 ldr r3,[r3,#12]
 2290 0250 9B89     	 ldrh r3,[r3,#12]
 2291 0252 9BB2     	 uxth r3,r3
 2292 0254 1846     	 mov r0,r3
 2293 0256 FFF7FEFF 	 bl lwip_htons
 2294 025a 0346     	 mov r3,r0
 2295 025c DBB2     	 uxtb r3,r3
 2296 025e 03F00303 	 and r3,r3,#3
 2297 0262 002B     	 cmp r3,#0
 2298 0264 01D0     	 beq .L133
 2299              	 .loc 1 1378 0 is_stmt 0 discriminator 1
 2300 0266 0123     	 movs r3,#1
 2301 0268 00E0     	 b .L134
 2302              	.L133:
 2303              	 .loc 1 1378 0 discriminator 2
 2304 026a 0023     	 movs r3,#0
 2305              	.L134:
 2306              	 .loc 1 1378 0 discriminator 4
 2307 026c 2344     	 add r3,r3,r4
 2308 026e 002B     	 cmp r3,#0
 2309 0270 4BD0     	 beq .L135
1379:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       seg->next = NULL;
 2310              	 .loc 1 1379 0 is_stmt 1
 2311 0272 7B6A     	 ldr r3,[r7,#36]
 2312 0274 0022     	 movs r2,#0
 2313 0276 1A60     	 str r2,[r3]
1380:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       /* unacked list is empty? */
1381:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       if (pcb->unacked == NULL) {
 2314              	 .loc 1 1381 0
 2315 0278 7B68     	 ldr r3,[r7,#4]
 2316 027a 1B6F     	 ldr r3,[r3,#112]
 2317 027c 002B     	 cmp r3,#0
 2318 027e 07D1     	 bne .L136
1382:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         pcb->unacked = seg;
 2319              	 .loc 1 1382 0
 2320 0280 7B68     	 ldr r3,[r7,#4]
 2321 0282 7A6A     	 ldr r2,[r7,#36]
 2322 0284 1A67     	 str r2,[r3,#112]
1383:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         useg = seg;
 2323              	 .loc 1 1383 0
 2324 0286 7B6A     	 ldr r3,[r7,#36]
 2325 0288 3B62     	 str r3,[r7,#32]
 2326 028a 41E0     	 b .L142
 2327              	.L145:
 2328              	 .align 2
 2329              	.L144:
 2330 028c 00000000 	 .word tcp_input_pcb
 2331              	.L136:
1384:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         /* unacked list is not empty? */
1385:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       } else {
1386:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         /* In the case of fast retransmit, the packet should not go to the tail
1387:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****          * of the unacked queue, but rather somewhere before it. We need to check for
1388:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****          * this case. -STJ Jul 27, 2004 */
1389:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         if (TCP_SEQ_LT(lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(useg->tcphdr->seqno))) {
 2332              	 .loc 1 1389 0
 2333 0290 7B6A     	 ldr r3,[r7,#36]
 2334 0292 DB68     	 ldr r3,[r3,#12]
 2335 0294 5B68     	 ldr r3,[r3,#4]
 2336 0296 1846     	 mov r0,r3
 2337 0298 FFF7FEFF 	 bl lwip_htonl
 2338 029c 0446     	 mov r4,r0
 2339 029e 3B6A     	 ldr r3,[r7,#32]
 2340 02a0 DB68     	 ldr r3,[r3,#12]
 2341 02a2 5B68     	 ldr r3,[r3,#4]
 2342 02a4 1846     	 mov r0,r3
 2343 02a6 FFF7FEFF 	 bl lwip_htonl
 2344 02aa 0346     	 mov r3,r0
 2345 02ac E31A     	 subs r3,r4,r3
 2346 02ae 002B     	 cmp r3,#0
 2347 02b0 24DA     	 bge .L138
 2348              	.LBB12:
1390:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           /* add segment to before tail of unacked list, keeping the list sorted */
1391:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           struct tcp_seg **cur_seg = &(pcb->unacked);
 2349              	 .loc 1 1391 0
 2350 02b2 7B68     	 ldr r3,[r7,#4]
 2351 02b4 7033     	 adds r3,r3,#112
 2352 02b6 FB61     	 str r3,[r7,#28]
1392:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           while (*cur_seg &&
 2353              	 .loc 1 1392 0
 2354 02b8 02E0     	 b .L139
 2355              	.L141:
1393:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                  TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno)))
1394:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****             cur_seg = &((*cur_seg)->next );
 2356              	 .loc 1 1394 0
 2357 02ba FB69     	 ldr r3,[r7,#28]
 2358 02bc 1B68     	 ldr r3,[r3]
 2359 02be FB61     	 str r3,[r7,#28]
 2360              	.L139:
1392:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           while (*cur_seg &&
 2361              	 .loc 1 1392 0
 2362 02c0 FB69     	 ldr r3,[r7,#28]
 2363 02c2 1B68     	 ldr r3,[r3]
 2364 02c4 002B     	 cmp r3,#0
 2365 02c6 11D0     	 beq .L140
1393:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                  TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno)))
 2366              	 .loc 1 1393 0 discriminator 1
 2367 02c8 FB69     	 ldr r3,[r7,#28]
 2368 02ca 1B68     	 ldr r3,[r3]
 2369 02cc DB68     	 ldr r3,[r3,#12]
 2370 02ce 5B68     	 ldr r3,[r3,#4]
 2371 02d0 1846     	 mov r0,r3
 2372 02d2 FFF7FEFF 	 bl lwip_htonl
 2373 02d6 0446     	 mov r4,r0
 2374 02d8 7B6A     	 ldr r3,[r7,#36]
 2375 02da DB68     	 ldr r3,[r3,#12]
 2376 02dc 5B68     	 ldr r3,[r3,#4]
 2377 02de 1846     	 mov r0,r3
 2378 02e0 FFF7FEFF 	 bl lwip_htonl
 2379 02e4 0346     	 mov r3,r0
 2380 02e6 E31A     	 subs r3,r4,r3
1392:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           while (*cur_seg &&
 2381              	 .loc 1 1392 0 discriminator 1
 2382 02e8 002B     	 cmp r3,#0
 2383 02ea E6DB     	 blt .L141
 2384              	.L140:
1395:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           }
1396:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           seg->next = (*cur_seg);
 2385              	 .loc 1 1396 0
 2386 02ec FB69     	 ldr r3,[r7,#28]
 2387 02ee 1A68     	 ldr r2,[r3]
 2388 02f0 7B6A     	 ldr r3,[r7,#36]
 2389 02f2 1A60     	 str r2,[r3]
1397:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           (*cur_seg) = seg;
 2390              	 .loc 1 1397 0
 2391 02f4 FB69     	 ldr r3,[r7,#28]
 2392 02f6 7A6A     	 ldr r2,[r7,#36]
 2393 02f8 1A60     	 str r2,[r3]
 2394              	.LBE12:
 2395 02fa 09E0     	 b .L142
 2396              	.L138:
1398:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         } else {
1399:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           /* add segment to tail of unacked list */
1400:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           useg->next = seg;
 2397              	 .loc 1 1400 0
 2398 02fc 3B6A     	 ldr r3,[r7,#32]
 2399 02fe 7A6A     	 ldr r2,[r7,#36]
 2400 0300 1A60     	 str r2,[r3]
1401:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****           useg = useg->next;
 2401              	 .loc 1 1401 0
 2402 0302 3B6A     	 ldr r3,[r7,#32]
 2403 0304 1B68     	 ldr r3,[r3]
 2404 0306 3B62     	 str r3,[r7,#32]
 2405 0308 02E0     	 b .L142
 2406              	.L135:
1402:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         }
1403:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       }
1404:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       /* do not queue empty segments on the unacked list */
1405:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     } else {
1406:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       tcp_seg_free(seg);
 2407              	 .loc 1 1406 0
 2408 030a 786A     	 ldr r0,[r7,#36]
 2409 030c FFF7FEFF 	 bl tcp_seg_free
 2410              	.L142:
1407:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
1408:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     seg = pcb->unsent;
 2411              	 .loc 1 1408 0
 2412 0310 7B68     	 ldr r3,[r7,#4]
 2413 0312 DB6E     	 ldr r3,[r3,#108]
 2414 0314 7B62     	 str r3,[r7,#36]
 2415              	.L120:
1332:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****          lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 2416              	 .loc 1 1332 0
 2417 0316 7B6A     	 ldr r3,[r7,#36]
 2418 0318 002B     	 cmp r3,#0
 2419 031a 10D0     	 beq .L126
1333:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_ASSERT("RST not expected here!",
 2420              	 .loc 1 1333 0 discriminator 1
 2421 031c 7B6A     	 ldr r3,[r7,#36]
 2422 031e DB68     	 ldr r3,[r3,#12]
 2423 0320 5B68     	 ldr r3,[r3,#4]
 2424 0322 1846     	 mov r0,r3
 2425 0324 FFF7FEFF 	 bl lwip_htonl
 2426 0328 0246     	 mov r2,r0
 2427 032a 7B68     	 ldr r3,[r7,#4]
 2428 032c 5B6C     	 ldr r3,[r3,#68]
 2429 032e D31A     	 subs r3,r2,r3
 2430 0330 7A6A     	 ldr r2,[r7,#36]
 2431 0332 1289     	 ldrh r2,[r2,#8]
 2432 0334 1A44     	 add r2,r2,r3
1332:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****          lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 2433              	 .loc 1 1332 0 discriminator 1
 2434 0336 BB69     	 ldr r3,[r7,#24]
 2435 0338 9A42     	 cmp r2,r3
 2436 033a 7FF6FAAE 	 bls .L143
 2437              	.L126:
1409:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1410:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_OVERSIZE
1411:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pcb->unsent == NULL) {
 2438              	 .loc 1 1411 0
 2439 033e 7B68     	 ldr r3,[r7,#4]
 2440 0340 DB6E     	 ldr r3,[r3,#108]
 2441 0342 002B     	 cmp r3,#0
 2442 0344 03D1     	 bne .L107
1412:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* last unsent has been removed, reset unsent_oversize */
1413:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     pcb->unsent_oversize = 0;
 2443              	 .loc 1 1413 0
 2444 0346 7B68     	 ldr r3,[r7,#4]
 2445 0348 0022     	 movs r2,#0
 2446 034a A3F86820 	 strh r2,[r3,#104]
 2447              	.L107:
1414:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1415:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_OVERSIZE */
1416:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1417:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** output_done:
1418:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   tcp_clear_flags(pcb, TF_NAGLEMEMERR);
 2448              	 .loc 1 1418 0
 2449 034e 7B68     	 ldr r3,[r7,#4]
 2450 0350 5B8B     	 ldrh r3,[r3,#26]
 2451 0352 23F08003 	 bic r3,r3,#128
 2452 0356 9AB2     	 uxth r2,r3
 2453 0358 7B68     	 ldr r3,[r7,#4]
 2454 035a 5A83     	 strh r2,[r3,#26]
1419:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   return ERR_OK;
 2455              	 .loc 1 1419 0
 2456 035c 0023     	 movs r3,#0
 2457              	.L104:
 2458 035e 5BB2     	 sxtb r3,r3
1420:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 2459              	 .loc 1 1420 0
 2460 0360 1846     	 mov r0,r3
 2461 0362 2837     	 adds r7,r7,#40
 2462              	.LCFI44:
 2463              	 .cfi_def_cfa_offset 16
 2464 0364 BD46     	 mov sp,r7
 2465              	.LCFI45:
 2466              	 .cfi_def_cfa_register 13
 2467              	 
 2468 0366 B0BD     	 pop {r4,r5,r7,pc}
 2469              	 .cfi_endproc
 2470              	.LFE141:
 2472              	 .section .text.tcp_output_segment_busy,"ax",%progbits
 2473              	 .align 2
 2474              	 .thumb
 2475              	 .thumb_func
 2477              	tcp_output_segment_busy:
 2478              	.LFB142:
1421:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1422:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /** Check if a segment's pbufs are used by someone else than TCP.
1423:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * This can happen on retransmission if the pbuf of this segment is still
1424:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * referenced by the netif driver due to deferred transmission.
1425:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * This is the case (only!) if someone down the TX call path called
1426:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * pbuf_ref() on one of the pbufs!
1427:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1428:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @arg seg the tcp segment to check
1429:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @return 1 if ref != 1, 0 if ref == 1
1430:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
1431:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** static int
1432:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_output_segment_busy(const struct tcp_seg *seg)
1433:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 2479              	 .loc 1 1433 0
 2480              	 .cfi_startproc
 2481              	 
 2482              	 
 2483              	 
 2484 0000 80B4     	 push {r7}
 2485              	.LCFI46:
 2486              	 .cfi_def_cfa_offset 4
 2487              	 .cfi_offset 7,-4
 2488 0002 83B0     	 sub sp,sp,#12
 2489              	.LCFI47:
 2490              	 .cfi_def_cfa_offset 16
 2491 0004 00AF     	 add r7,sp,#0
 2492              	.LCFI48:
 2493              	 .cfi_def_cfa_register 7
 2494 0006 7860     	 str r0,[r7,#4]
1434:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_output_segment_busy: invalid seg", seg != NULL);
1435:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1436:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* We only need to check the first pbuf here:
1437:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      If a pbuf is queued for transmission, a driver calls pbuf_ref(),
1438:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      which only changes the ref count of the first pbuf */
1439:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (seg->p->ref != 1) {
 2495              	 .loc 1 1439 0
 2496 0008 7B68     	 ldr r3,[r7,#4]
 2497 000a 5B68     	 ldr r3,[r3,#4]
 2498 000c 9B7B     	 ldrb r3,[r3,#14]
 2499 000e 012B     	 cmp r3,#1
 2500 0010 01D0     	 beq .L147
1440:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* other reference found */
1441:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return 1;
 2501              	 .loc 1 1441 0
 2502 0012 0123     	 movs r3,#1
 2503 0014 00E0     	 b .L148
 2504              	.L147:
1442:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1443:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* no other references found */
1444:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   return 0;
 2505              	 .loc 1 1444 0
 2506 0016 0023     	 movs r3,#0
 2507              	.L148:
1445:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 2508              	 .loc 1 1445 0
 2509 0018 1846     	 mov r0,r3
 2510 001a 0C37     	 adds r7,r7,#12
 2511              	.LCFI49:
 2512              	 .cfi_def_cfa_offset 4
 2513 001c BD46     	 mov sp,r7
 2514              	.LCFI50:
 2515              	 .cfi_def_cfa_register 13
 2516              	 
 2517 001e 5DF8047B 	 ldr r7,[sp],#4
 2518              	.LCFI51:
 2519              	 .cfi_restore 7
 2520              	 .cfi_def_cfa_offset 0
 2521 0022 7047     	 bx lr
 2522              	 .cfi_endproc
 2523              	.LFE142:
 2525              	 .section .text.tcp_output_segment,"ax",%progbits
 2526              	 .align 2
 2527              	 .thumb
 2528              	 .thumb_func
 2530              	tcp_output_segment:
 2531              	.LFB143:
1446:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1447:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /**
1448:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Called by tcp_output() to actually send a TCP segment over IP.
1449:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1450:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param seg the tcp_seg to send
1451:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb the tcp_pcb for the TCP connection used to send the segment
1452:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param netif the netif used to send the segment
1453:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
1454:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** static err_t
1455:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb, struct netif *netif)
1456:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 2532              	 .loc 1 1456 0
 2533              	 .cfi_startproc
 2534              	 
 2535              	 
 2536 0000 90B5     	 push {r4,r7,lr}
 2537              	.LCFI52:
 2538              	 .cfi_def_cfa_offset 12
 2539              	 .cfi_offset 4,-12
 2540              	 .cfi_offset 7,-8
 2541              	 .cfi_offset 14,-4
 2542 0002 8DB0     	 sub sp,sp,#52
 2543              	.LCFI53:
 2544              	 .cfi_def_cfa_offset 64
 2545 0004 04AF     	 add r7,sp,#16
 2546              	.LCFI54:
 2547              	 .cfi_def_cfa 7,48
 2548 0006 F860     	 str r0,[r7,#12]
 2549 0008 B960     	 str r1,[r7,#8]
 2550 000a 7A60     	 str r2,[r7,#4]
1457:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   err_t err;
1458:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u16_t len;
1459:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u32_t *opts;
1460:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
1461:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   int seg_chksum_was_swapped = 0;
1462:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
1463:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1464:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_output_segment: invalid seg", seg != NULL);
1465:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_output_segment: invalid pcb", pcb != NULL);
1466:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_output_segment: invalid netif", netif != NULL);
1467:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1468:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (tcp_output_segment_busy(seg)) {
 2551              	 .loc 1 1468 0
 2552 000c F868     	 ldr r0,[r7,#12]
 2553 000e FFF7FEFF 	 bl tcp_output_segment_busy
 2554 0012 0346     	 mov r3,r0
 2555 0014 002B     	 cmp r3,#0
 2556 0016 01D0     	 beq .L150
1469:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* This should not happen: rexmit functions should have checked this.
1470:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****        However, since this function modifies p->len, we must not continue in this case. */
1471:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_RTO_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_output_segment: segment busy\n"));
1472:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return ERR_OK;
 2557              	 .loc 1 1472 0
 2558 0018 0023     	 movs r3,#0
 2559 001a 8AE0     	 b .L151
 2560              	.L150:
1473:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1474:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1475:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* The TCP header has already been constructed, but the ackno and
1476:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****    wnd fields remain. */
1477:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
 2561              	 .loc 1 1477 0
 2562 001c FB68     	 ldr r3,[r7,#12]
 2563 001e DC68     	 ldr r4,[r3,#12]
 2564 0020 BB68     	 ldr r3,[r7,#8]
 2565 0022 5B6A     	 ldr r3,[r3,#36]
 2566 0024 1846     	 mov r0,r3
 2567 0026 FFF7FEFF 	 bl lwip_htonl
 2568 002a 0346     	 mov r3,r0
 2569 002c A360     	 str r3,[r4,#8]
1478:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1479:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* advertise our receive window size in this TCP segment */
1480:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if LWIP_WND_SCALE
1481:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (seg->flags & TF_SEG_OPTS_WND_SCALE) {
1482:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* The Window field in a SYN segment itself (the only type where we send
1483:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****        the window scale option) is never scaled. */
1484:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(pcb->rcv_ann_wnd));
1485:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   } else
1486:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* LWIP_WND_SCALE */
1487:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   {
1488:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
 2570              	 .loc 1 1488 0
 2571 002e FB68     	 ldr r3,[r7,#12]
 2572 0030 DC68     	 ldr r4,[r3,#12]
 2573 0032 BB68     	 ldr r3,[r7,#8]
 2574 0034 5B8D     	 ldrh r3,[r3,#42]
 2575 0036 1846     	 mov r0,r3
 2576 0038 FFF7FEFF 	 bl lwip_htons
 2577 003c 0346     	 mov r3,r0
 2578 003e E381     	 strh r3,[r4,#14]
1489:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1490:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1491:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 2579              	 .loc 1 1491 0
 2580 0040 BB68     	 ldr r3,[r7,#8]
 2581 0042 5B6A     	 ldr r3,[r3,#36]
 2582 0044 BA68     	 ldr r2,[r7,#8]
 2583 0046 528D     	 ldrh r2,[r2,#42]
 2584 0048 1A44     	 add r2,r2,r3
 2585 004a BB68     	 ldr r3,[r7,#8]
 2586 004c DA62     	 str r2,[r3,#44]
1492:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1493:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Add any requested options.  NB MSS option is only set on SYN
1494:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      packets, so ignore it here */
1495:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* cast through void* to get rid of alignment warnings */
1496:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   opts = (u32_t *)(void *)(seg->tcphdr + 1);
 2587              	 .loc 1 1496 0
 2588 004e FB68     	 ldr r3,[r7,#12]
 2589 0050 DB68     	 ldr r3,[r3,#12]
 2590 0052 1433     	 adds r3,r3,#20
 2591 0054 FB61     	 str r3,[r7,#28]
1497:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (seg->flags & TF_SEG_OPTS_MSS) {
 2592              	 .loc 1 1497 0
 2593 0056 FB68     	 ldr r3,[r7,#12]
 2594 0058 9B7A     	 ldrb r3,[r3,#10]
 2595 005a 03F00103 	 and r3,r3,#1
 2596 005e 002B     	 cmp r3,#0
 2597 0060 15D0     	 beq .L152
 2598              	.LBB13:
1498:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     u16_t mss;
1499:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CALCULATE_EFF_SEND_MSS
1500:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     mss = tcp_eff_send_mss_netif(TCP_MSS, netif, &pcb->remote_ip);
 2599              	 .loc 1 1500 0
 2600 0062 BB68     	 ldr r3,[r7,#8]
 2601 0064 0433     	 adds r3,r3,#4
 2602 0066 4FF40670 	 mov r0,#536
 2603 006a 7968     	 ldr r1,[r7,#4]
 2604 006c 1A46     	 mov r2,r3
 2605 006e FFF7FEFF 	 bl tcp_eff_send_mss_netif
 2606 0072 0346     	 mov r3,r0
 2607 0074 7B83     	 strh r3,[r7,#26]
1501:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #else /* TCP_CALCULATE_EFF_SEND_MSS */
1502:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     mss = TCP_MSS;
1503:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_CALCULATE_EFF_SEND_MSS */
1504:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     *opts = TCP_BUILD_MSS_OPTION(mss);
 2608              	 .loc 1 1504 0
 2609 0076 7B8B     	 ldrh r3,[r7,#26]
 2610 0078 43F00173 	 orr r3,r3,#33816576
 2611 007c 1846     	 mov r0,r3
 2612 007e FFF7FEFF 	 bl lwip_htonl
 2613 0082 0246     	 mov r2,r0
 2614 0084 FB69     	 ldr r3,[r7,#28]
 2615 0086 1A60     	 str r2,[r3]
1505:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     opts += 1;
 2616              	 .loc 1 1505 0
 2617 0088 FB69     	 ldr r3,[r7,#28]
 2618 008a 0433     	 adds r3,r3,#4
 2619 008c FB61     	 str r3,[r7,#28]
 2620              	.L152:
 2621              	.LBE13:
1506:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1507:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if LWIP_TCP_TIMESTAMPS
1508:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   pcb->ts_lastacksent = pcb->rcv_nxt;
1509:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1510:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (seg->flags & TF_SEG_OPTS_TS) {
1511:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcp_build_timestamp_option(pcb, opts);
1512:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     opts += 3;
1513:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1514:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
1515:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if LWIP_WND_SCALE
1516:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (seg->flags & TF_SEG_OPTS_WND_SCALE) {
1517:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcp_build_wnd_scale_option(opts);
1518:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     opts += 1;
1519:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1520:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
1521:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if LWIP_TCP_SACK_OUT
1522:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (seg->flags & TF_SEG_OPTS_SACK_PERM) {
1523:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* Pad with two NOP options to make everything nicely aligned
1524:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * NOTE: When we send both timestamp and SACK_PERM options,
1525:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * we could use the first two NOPs before the timestamp to store SACK_PERM option,
1526:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      * but that would complicate the code.
1527:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      */
1528:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     *(opts++) = PP_HTONL(0x01010402);
1529:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1530:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
1531:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1532:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Set retransmission timer running if it is not currently enabled
1533:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      This must be set before checking the route. */
1534:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pcb->rtime < 0) {
 2622              	 .loc 1 1534 0
 2623 008e BB68     	 ldr r3,[r7,#8]
 2624 0090 1B8E     	 ldrh r3,[r3,#48]
 2625 0092 1BB2     	 sxth r3,r3
 2626 0094 002B     	 cmp r3,#0
 2627 0096 02DA     	 bge .L153
1535:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     pcb->rtime = 0;
 2628              	 .loc 1 1535 0
 2629 0098 BB68     	 ldr r3,[r7,#8]
 2630 009a 0022     	 movs r2,#0
 2631 009c 1A86     	 strh r2,[r3,#48]
 2632              	.L153:
1536:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1537:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1538:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pcb->rttest == 0) {
 2633              	 .loc 1 1538 0
 2634 009e BB68     	 ldr r3,[r7,#8]
 2635 00a0 5B6B     	 ldr r3,[r3,#52]
 2636 00a2 002B     	 cmp r3,#0
 2637 00a4 0CD1     	 bne .L154
1539:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     pcb->rttest = tcp_ticks;
 2638              	 .loc 1 1539 0
 2639 00a6 254B     	 ldr r3,.L155
 2640 00a8 1A68     	 ldr r2,[r3]
 2641 00aa BB68     	 ldr r3,[r7,#8]
 2642 00ac 5A63     	 str r2,[r3,#52]
1540:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     pcb->rtseq = lwip_ntohl(seg->tcphdr->seqno);
 2643              	 .loc 1 1540 0
 2644 00ae FB68     	 ldr r3,[r7,#12]
 2645 00b0 DB68     	 ldr r3,[r3,#12]
 2646 00b2 5B68     	 ldr r3,[r3,#4]
 2647 00b4 1846     	 mov r0,r3
 2648 00b6 FFF7FEFF 	 bl lwip_htonl
 2649 00ba 0246     	 mov r2,r0
 2650 00bc BB68     	 ldr r3,[r7,#8]
 2651 00be 9A63     	 str r2,[r3,#56]
 2652              	.L154:
1541:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1542:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_output_segment: rtseq %"U32_F"\n", pcb->rtseq));
1543:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1544:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
1545:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                                  lwip_htonl(seg->tcphdr->seqno), lwip_htonl(seg->tcphdr->seqno) +
1546:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                                  seg->len));
1547:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1548:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 2653              	 .loc 1 1548 0
 2654 00c0 FB68     	 ldr r3,[r7,#12]
 2655 00c2 DB68     	 ldr r3,[r3,#12]
 2656 00c4 1A46     	 mov r2,r3
 2657 00c6 FB68     	 ldr r3,[r7,#12]
 2658 00c8 5B68     	 ldr r3,[r3,#4]
 2659 00ca 5B68     	 ldr r3,[r3,#4]
 2660 00cc D31A     	 subs r3,r2,r3
 2661 00ce 3B83     	 strh r3,[r7,#24]
1549:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (len == 0) {
1550:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /** Exclude retransmitted segments from this count. */
1551:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     MIB2_STATS_INC(mib2.tcpoutsegs);
1552:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1553:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1554:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->p->len -= len;
 2662              	 .loc 1 1554 0
 2663 00d0 FB68     	 ldr r3,[r7,#12]
 2664 00d2 5B68     	 ldr r3,[r3,#4]
 2665 00d4 FA68     	 ldr r2,[r7,#12]
 2666 00d6 5268     	 ldr r2,[r2,#4]
 2667 00d8 5189     	 ldrh r1,[r2,#10]
 2668 00da 3A8B     	 ldrh r2,[r7,#24]
 2669 00dc 8A1A     	 subs r2,r1,r2
 2670 00de 92B2     	 uxth r2,r2
 2671 00e0 5A81     	 strh r2,[r3,#10]
1555:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->p->tot_len -= len;
 2672              	 .loc 1 1555 0
 2673 00e2 FB68     	 ldr r3,[r7,#12]
 2674 00e4 5B68     	 ldr r3,[r3,#4]
 2675 00e6 FA68     	 ldr r2,[r7,#12]
 2676 00e8 5268     	 ldr r2,[r2,#4]
 2677 00ea 1189     	 ldrh r1,[r2,#8]
 2678 00ec 3A8B     	 ldrh r2,[r7,#24]
 2679 00ee 8A1A     	 subs r2,r1,r2
 2680 00f0 92B2     	 uxth r2,r2
 2681 00f2 1A81     	 strh r2,[r3,#8]
1556:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1557:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->p->payload = seg->tcphdr;
 2682              	 .loc 1 1557 0
 2683 00f4 FB68     	 ldr r3,[r7,#12]
 2684 00f6 5B68     	 ldr r3,[r3,#4]
 2685 00f8 FA68     	 ldr r2,[r7,#12]
 2686 00fa D268     	 ldr r2,[r2,#12]
 2687 00fc 5A60     	 str r2,[r3,#4]
1558:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1559:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->tcphdr->chksum = 0;
 2688              	 .loc 1 1559 0
 2689 00fe FB68     	 ldr r3,[r7,#12]
 2690 0100 DB68     	 ldr r3,[r3,#12]
 2691 0102 0022     	 movs r2,#0
 2692 0104 1A74     	 strb r2,[r3,#16]
 2693 0106 0022     	 movs r2,#0
 2694 0108 5A74     	 strb r2,[r3,#17]
1560:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1561:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #ifdef LWIP_HOOK_TCP_OUT_ADD_TCPOPTS
1562:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   opts = LWIP_HOOK_TCP_OUT_ADD_TCPOPTS(seg->p, seg->tcphdr, pcb, opts);
1563:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
1564:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(seg->tcphdr + 1)) + LWIP_TCP_OPT_LENG
1565:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1566:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if CHECKSUM_GEN_TCP
1567:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
1568:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
1569:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     u32_t acc;
1570:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
1571:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     u16_t chksum_slow = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
1572:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                                          seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);
1573:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
1574:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if ((seg->flags & TF_SEG_DATA_CHECKSUMMED) == 0) {
1575:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       LWIP_ASSERT("data included but not checksummed",
1576:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                   seg->p->tot_len == TCPH_HDRLEN_BYTES(seg->tcphdr));
1577:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
1578:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1579:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
1580:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
1581:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                                    seg->p->tot_len, TCPH_HDRLEN_BYTES(seg->tcphdr), &pcb->local_ip,
1582:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* add payload checksum */
1583:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if (seg->chksum_swapped) {
1584:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       seg_chksum_was_swapped = 1;
1585:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
1586:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       seg->chksum_swapped = 0;
1587:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
1588:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     acc = (u16_t)~acc + seg->chksum;
1589:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     seg->tcphdr->chksum = (u16_t)~FOLD_U32T(acc);
1590:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
1591:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if (chksum_slow != seg->tcphdr->chksum) {
1592:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       TCP_CHECKSUM_ON_COPY_SANITY_CHECK_FAIL(
1593:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         ("tcp_output_segment: calculated checksum is %"X16_F" instead of %"X16_F"\n",
1594:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****          seg->tcphdr->chksum, chksum_slow));
1595:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       seg->tcphdr->chksum = chksum_slow;
1596:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
1597:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
1598:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #else /* TCP_CHECKSUM_ON_COPY */
1599:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     seg->tcphdr->chksum = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
1600:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                                            seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);
1601:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_CHECKSUM_ON_COPY */
1602:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1603:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* CHECKSUM_GEN_TCP */
1604:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   TCP_STATS_INC(tcp.xmit);
1605:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1606:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   NETIF_SET_HINTS(netif, &(pcb->netif_hints));
1607:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   err = ip_output_if(seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
 2695              	 .loc 1 1607 0
 2696 010a FB68     	 ldr r3,[r7,#12]
 2697 010c 5868     	 ldr r0,[r3,#4]
 2698 010e B968     	 ldr r1,[r7,#8]
 2699 0110 BB68     	 ldr r3,[r7,#8]
 2700 0112 1A1D     	 adds r2,r3,#4
 2701 0114 BB68     	 ldr r3,[r7,#8]
 2702 0116 DC7A     	 ldrb r4,[r3,#11]
 2703 0118 BB68     	 ldr r3,[r7,#8]
 2704 011a 9B7A     	 ldrb r3,[r3,#10]
 2705 011c 0093     	 str r3,[sp]
 2706 011e 0623     	 movs r3,#6
 2707 0120 0193     	 str r3,[sp,#4]
 2708 0122 7B68     	 ldr r3,[r7,#4]
 2709 0124 0293     	 str r3,[sp,#8]
 2710 0126 2346     	 mov r3,r4
 2711 0128 FFF7FEFF 	 bl ip4_output_if
 2712 012c 0346     	 mov r3,r0
 2713 012e FB75     	 strb r3,[r7,#23]
1608:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                      pcb->tos, IP_PROTO_TCP, netif);
1609:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   NETIF_RESET_HINTS(netif);
1610:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1611:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_CHECKSUM_ON_COPY
1612:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (seg_chksum_was_swapped) {
1613:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* if data is added to this segment later, chksum needs to be swapped,
1614:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****        so restore this now */
1615:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
1616:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     seg->chksum_swapped = 1;
1617:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1618:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
1619:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1620:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   return err;
 2714              	 .loc 1 1620 0
 2715 0130 FB7D     	 ldrb r3,[r7,#23]
 2716              	.L151:
 2717 0132 5BB2     	 sxtb r3,r3
1621:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 2718              	 .loc 1 1621 0
 2719 0134 1846     	 mov r0,r3
 2720 0136 2437     	 adds r7,r7,#36
 2721              	.LCFI55:
 2722              	 .cfi_def_cfa_offset 12
 2723 0138 BD46     	 mov sp,r7
 2724              	.LCFI56:
 2725              	 .cfi_def_cfa_register 13
 2726              	 
 2727 013a 90BD     	 pop {r4,r7,pc}
 2728              	.L156:
 2729              	 .align 2
 2730              	.L155:
 2731 013c 00000000 	 .word tcp_ticks
 2732              	 .cfi_endproc
 2733              	.LFE143:
 2735              	 .section .text.tcp_rexmit_rto_prepare,"ax",%progbits
 2736              	 .align 2
 2737              	 .global tcp_rexmit_rto_prepare
 2738              	 .thumb
 2739              	 .thumb_func
 2741              	tcp_rexmit_rto_prepare:
 2742              	.LFB144:
1622:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1623:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /**
1624:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Requeue all unacked segments for retransmission
1625:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1626:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Called by tcp_slowtmr() for slow retransmission.
1627:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1628:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
1629:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
1630:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** err_t
1631:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_rexmit_rto_prepare(struct tcp_pcb *pcb)
1632:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 2743              	 .loc 1 1632 0
 2744              	 .cfi_startproc
 2745              	 
 2746              	 
 2747 0000 B0B5     	 push {r4,r5,r7,lr}
 2748              	.LCFI57:
 2749              	 .cfi_def_cfa_offset 16
 2750              	 .cfi_offset 4,-16
 2751              	 .cfi_offset 5,-12
 2752              	 .cfi_offset 7,-8
 2753              	 .cfi_offset 14,-4
 2754 0002 84B0     	 sub sp,sp,#16
 2755              	.LCFI58:
 2756              	 .cfi_def_cfa_offset 32
 2757 0004 00AF     	 add r7,sp,#0
 2758              	.LCFI59:
 2759              	 .cfi_def_cfa_register 7
 2760 0006 7860     	 str r0,[r7,#4]
1633:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct tcp_seg *seg;
1634:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1635:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_rexmit_rto_prepare: invalid pcb", pcb != NULL);
1636:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1637:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pcb->unacked == NULL) {
 2761              	 .loc 1 1637 0
 2762 0008 7B68     	 ldr r3,[r7,#4]
 2763 000a 1B6F     	 ldr r3,[r3,#112]
 2764 000c 002B     	 cmp r3,#0
 2765 000e 01D1     	 bne .L158
1638:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return ERR_VAL;
 2766              	 .loc 1 1638 0
 2767 0010 FA23     	 movs r3,#250
 2768 0012 4EE0     	 b .L159
 2769              	.L158:
1639:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1640:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1641:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Move all unacked segments to the head of the unsent queue.
1642:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      However, give up if any of the unsent pbufs are still referenced by the
1643:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      netif driver due to deferred transmission. No point loading the link further
1644:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      if it is struggling to flush its buffered writes. */
1645:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   for (seg = pcb->unacked; seg->next != NULL; seg = seg->next) {
 2770              	 .loc 1 1645 0
 2771 0014 7B68     	 ldr r3,[r7,#4]
 2772 0016 1B6F     	 ldr r3,[r3,#112]
 2773 0018 FB60     	 str r3,[r7,#12]
 2774 001a 0AE0     	 b .L160
 2775              	.L162:
1646:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if (tcp_output_segment_busy(seg)) {
 2776              	 .loc 1 1646 0
 2777 001c F868     	 ldr r0,[r7,#12]
 2778 001e FFF7FEFF 	 bl tcp_output_segment_busy
 2779 0022 0346     	 mov r3,r0
 2780 0024 002B     	 cmp r3,#0
 2781 0026 01D0     	 beq .L161
1647:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit_rto: segment busy\n"));
1648:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       return ERR_VAL;
 2782              	 .loc 1 1648 0
 2783 0028 FA23     	 movs r3,#250
 2784 002a 42E0     	 b .L159
 2785              	.L161:
1645:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if (tcp_output_segment_busy(seg)) {
 2786              	 .loc 1 1645 0 discriminator 2
 2787 002c FB68     	 ldr r3,[r7,#12]
 2788 002e 1B68     	 ldr r3,[r3]
 2789 0030 FB60     	 str r3,[r7,#12]
 2790              	.L160:
1645:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if (tcp_output_segment_busy(seg)) {
 2791              	 .loc 1 1645 0 is_stmt 0 discriminator 1
 2792 0032 FB68     	 ldr r3,[r7,#12]
 2793 0034 1B68     	 ldr r3,[r3]
 2794 0036 002B     	 cmp r3,#0
 2795 0038 F0D1     	 bne .L162
1649:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
1650:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1651:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (tcp_output_segment_busy(seg)) {
 2796              	 .loc 1 1651 0 is_stmt 1
 2797 003a F868     	 ldr r0,[r7,#12]
 2798 003c FFF7FEFF 	 bl tcp_output_segment_busy
 2799 0040 0346     	 mov r3,r0
 2800 0042 002B     	 cmp r3,#0
 2801 0044 01D0     	 beq .L163
1652:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit_rto: segment busy\n"));
1653:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return ERR_VAL;
 2802              	 .loc 1 1653 0
 2803 0046 FA23     	 movs r3,#250
 2804 0048 33E0     	 b .L159
 2805              	.L163:
1654:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1655:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* concatenate unsent queue after unacked queue */
1656:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->next = pcb->unsent;
 2806              	 .loc 1 1656 0
 2807 004a 7B68     	 ldr r3,[r7,#4]
 2808 004c DA6E     	 ldr r2,[r3,#108]
 2809 004e FB68     	 ldr r3,[r7,#12]
 2810 0050 1A60     	 str r2,[r3]
1657:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_OVERSIZE_DBGCHECK
1658:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* if last unsent changed, we need to update unsent_oversize */
1659:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pcb->unsent == NULL) {
1660:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     pcb->unsent_oversize = seg->oversize_left;
1661:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1662:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_OVERSIZE_DBGCHECK */
1663:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* unsent queue is the concatenated queue (of unacked, unsent) */
1664:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   pcb->unsent = pcb->unacked;
 2811              	 .loc 1 1664 0
 2812 0052 7B68     	 ldr r3,[r7,#4]
 2813 0054 1A6F     	 ldr r2,[r3,#112]
 2814 0056 7B68     	 ldr r3,[r7,#4]
 2815 0058 DA66     	 str r2,[r3,#108]
1665:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* unacked queue is now empty */
1666:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   pcb->unacked = NULL;
 2816              	 .loc 1 1666 0
 2817 005a 7B68     	 ldr r3,[r7,#4]
 2818 005c 0022     	 movs r2,#0
 2819 005e 1A67     	 str r2,[r3,#112]
1667:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1668:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Mark RTO in-progress */
1669:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   tcp_set_flags(pcb, TF_RTO);
 2820              	 .loc 1 1669 0
 2821 0060 7B68     	 ldr r3,[r7,#4]
 2822 0062 5B8B     	 ldrh r3,[r3,#26]
 2823 0064 43F40063 	 orr r3,r3,#2048
 2824 0068 9AB2     	 uxth r2,r3
 2825 006a 7B68     	 ldr r3,[r7,#4]
 2826 006c 5A83     	 strh r2,[r3,#26]
1670:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Record the next byte following retransmit */
1671:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   pcb->rto_end = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 2827              	 .loc 1 1671 0
 2828 006e FB68     	 ldr r3,[r7,#12]
 2829 0070 DB68     	 ldr r3,[r3,#12]
 2830 0072 5B68     	 ldr r3,[r3,#4]
 2831 0074 1846     	 mov r0,r3
 2832 0076 FFF7FEFF 	 bl lwip_htonl
 2833 007a 0446     	 mov r4,r0
 2834 007c FB68     	 ldr r3,[r7,#12]
 2835 007e 1B89     	 ldrh r3,[r3,#8]
 2836 0080 1D46     	 mov r5,r3
 2837 0082 FB68     	 ldr r3,[r7,#12]
 2838 0084 DB68     	 ldr r3,[r3,#12]
 2839 0086 9B89     	 ldrh r3,[r3,#12]
 2840 0088 9BB2     	 uxth r3,r3
 2841 008a 1846     	 mov r0,r3
 2842 008c FFF7FEFF 	 bl lwip_htons
 2843 0090 0346     	 mov r3,r0
 2844 0092 DBB2     	 uxtb r3,r3
 2845 0094 03F00303 	 and r3,r3,#3
 2846 0098 002B     	 cmp r3,#0
 2847 009a 01D0     	 beq .L164
 2848              	 .loc 1 1671 0 is_stmt 0 discriminator 1
 2849 009c 0123     	 movs r3,#1
 2850 009e 00E0     	 b .L165
 2851              	.L164:
 2852              	 .loc 1 1671 0 discriminator 2
 2853 00a0 0023     	 movs r3,#0
 2854              	.L165:
 2855              	 .loc 1 1671 0 discriminator 4
 2856 00a2 2B44     	 add r3,r3,r5
 2857 00a4 E218     	 adds r2,r4,r3
 2858 00a6 7B68     	 ldr r3,[r7,#4]
 2859 00a8 DA64     	 str r2,[r3,#76]
1672:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Don't take any RTT measurements after retransmitting. */
1673:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   pcb->rttest = 0;
 2860              	 .loc 1 1673 0 is_stmt 1 discriminator 4
 2861 00aa 7B68     	 ldr r3,[r7,#4]
 2862 00ac 0022     	 movs r2,#0
 2863 00ae 5A63     	 str r2,[r3,#52]
1674:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1675:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   return ERR_OK;
 2864              	 .loc 1 1675 0 discriminator 4
 2865 00b0 0023     	 movs r3,#0
 2866              	.L159:
 2867 00b2 5BB2     	 sxtb r3,r3
1676:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 2868              	 .loc 1 1676 0
 2869 00b4 1846     	 mov r0,r3
 2870 00b6 1037     	 adds r7,r7,#16
 2871              	.LCFI60:
 2872              	 .cfi_def_cfa_offset 16
 2873 00b8 BD46     	 mov sp,r7
 2874              	.LCFI61:
 2875              	 .cfi_def_cfa_register 13
 2876              	 
 2877 00ba B0BD     	 pop {r4,r5,r7,pc}
 2878              	 .cfi_endproc
 2879              	.LFE144:
 2881              	 .section .text.tcp_rexmit_rto_commit,"ax",%progbits
 2882              	 .align 2
 2883              	 .global tcp_rexmit_rto_commit
 2884              	 .thumb
 2885              	 .thumb_func
 2887              	tcp_rexmit_rto_commit:
 2888              	.LFB145:
1677:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1678:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /**
1679:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Requeue all unacked segments for retransmission
1680:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1681:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Called by tcp_slowtmr() for slow retransmission.
1682:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1683:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
1684:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
1685:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** void
1686:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_rexmit_rto_commit(struct tcp_pcb *pcb)
1687:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 2889              	 .loc 1 1687 0
 2890              	 .cfi_startproc
 2891              	 
 2892              	 
 2893 0000 80B5     	 push {r7,lr}
 2894              	.LCFI62:
 2895              	 .cfi_def_cfa_offset 8
 2896              	 .cfi_offset 7,-8
 2897              	 .cfi_offset 14,-4
 2898 0002 82B0     	 sub sp,sp,#8
 2899              	.LCFI63:
 2900              	 .cfi_def_cfa_offset 16
 2901 0004 00AF     	 add r7,sp,#0
 2902              	.LCFI64:
 2903              	 .cfi_def_cfa_register 7
 2904 0006 7860     	 str r0,[r7,#4]
1688:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_rexmit_rto_commit: invalid pcb", pcb != NULL);
1689:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1690:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* increment number of retransmissions */
1691:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pcb->nrtx < 0xFF) {
 2905              	 .loc 1 1691 0
 2906 0008 7B68     	 ldr r3,[r7,#4]
 2907 000a 93F84230 	 ldrb r3,[r3,#66]
 2908 000e FF2B     	 cmp r3,#255
 2909 0010 07D0     	 beq .L167
1692:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     ++pcb->nrtx;
 2910              	 .loc 1 1692 0
 2911 0012 7B68     	 ldr r3,[r7,#4]
 2912 0014 93F84230 	 ldrb r3,[r3,#66]
 2913 0018 0133     	 adds r3,r3,#1
 2914 001a DAB2     	 uxtb r2,r3
 2915 001c 7B68     	 ldr r3,[r7,#4]
 2916 001e 83F84220 	 strb r2,[r3,#66]
 2917              	.L167:
1693:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1694:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Do the actual retransmission */
1695:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   tcp_output(pcb);
 2918              	 .loc 1 1695 0
 2919 0022 7868     	 ldr r0,[r7,#4]
 2920 0024 FFF7FEFF 	 bl tcp_output
1696:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 2921              	 .loc 1 1696 0
 2922 0028 0837     	 adds r7,r7,#8
 2923              	.LCFI65:
 2924              	 .cfi_def_cfa_offset 8
 2925 002a BD46     	 mov sp,r7
 2926              	.LCFI66:
 2927              	 .cfi_def_cfa_register 13
 2928              	 
 2929 002c 80BD     	 pop {r7,pc}
 2930              	 .cfi_endproc
 2931              	.LFE145:
 2933 002e 00BF     	 .section .text.tcp_rexmit_rto,"ax",%progbits
 2934              	 .align 2
 2935              	 .global tcp_rexmit_rto
 2936              	 .thumb
 2937              	 .thumb_func
 2939              	tcp_rexmit_rto:
 2940              	.LFB146:
1697:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1698:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /**
1699:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Requeue all unacked segments for retransmission
1700:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1701:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Called by tcp_process() only, tcp_slowtmr() needs to do some things between
1702:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * "prepare" and "commit".
1703:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1704:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
1705:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
1706:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** void
1707:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_rexmit_rto(struct tcp_pcb *pcb)
1708:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 2941              	 .loc 1 1708 0
 2942              	 .cfi_startproc
 2943              	 
 2944              	 
 2945 0000 80B5     	 push {r7,lr}
 2946              	.LCFI67:
 2947              	 .cfi_def_cfa_offset 8
 2948              	 .cfi_offset 7,-8
 2949              	 .cfi_offset 14,-4
 2950 0002 82B0     	 sub sp,sp,#8
 2951              	.LCFI68:
 2952              	 .cfi_def_cfa_offset 16
 2953 0004 00AF     	 add r7,sp,#0
 2954              	.LCFI69:
 2955              	 .cfi_def_cfa_register 7
 2956 0006 7860     	 str r0,[r7,#4]
1709:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_rexmit_rto: invalid pcb", pcb != NULL);
1710:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1711:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (tcp_rexmit_rto_prepare(pcb) == ERR_OK) {
 2957              	 .loc 1 1711 0
 2958 0008 7868     	 ldr r0,[r7,#4]
 2959 000a FFF7FEFF 	 bl tcp_rexmit_rto_prepare
 2960 000e 0346     	 mov r3,r0
 2961 0010 002B     	 cmp r3,#0
 2962 0012 02D1     	 bne .L168
1712:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcp_rexmit_rto_commit(pcb);
 2963              	 .loc 1 1712 0
 2964 0014 7868     	 ldr r0,[r7,#4]
 2965 0016 FFF7FEFF 	 bl tcp_rexmit_rto_commit
 2966              	.L168:
1713:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1714:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 2967              	 .loc 1 1714 0
 2968 001a 0837     	 adds r7,r7,#8
 2969              	.LCFI70:
 2970              	 .cfi_def_cfa_offset 8
 2971 001c BD46     	 mov sp,r7
 2972              	.LCFI71:
 2973              	 .cfi_def_cfa_register 13
 2974              	 
 2975 001e 80BD     	 pop {r7,pc}
 2976              	 .cfi_endproc
 2977              	.LFE146:
 2979              	 .section .text.tcp_rexmit,"ax",%progbits
 2980              	 .align 2
 2981              	 .global tcp_rexmit
 2982              	 .thumb
 2983              	 .thumb_func
 2985              	tcp_rexmit:
 2986              	.LFB147:
1715:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1716:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /**
1717:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Requeue the first unacked segment for retransmission
1718:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1719:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Called by tcp_receive() for fast retransmit.
1720:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1721:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb the tcp_pcb for which to retransmit the first unacked segment
1722:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
1723:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** err_t
1724:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_rexmit(struct tcp_pcb *pcb)
1725:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 2987              	 .loc 1 1725 0
 2988              	 .cfi_startproc
 2989              	 
 2990              	 
 2991 0000 90B5     	 push {r4,r7,lr}
 2992              	.LCFI72:
 2993              	 .cfi_def_cfa_offset 12
 2994              	 .cfi_offset 4,-12
 2995              	 .cfi_offset 7,-8
 2996              	 .cfi_offset 14,-4
 2997 0002 85B0     	 sub sp,sp,#20
 2998              	.LCFI73:
 2999              	 .cfi_def_cfa_offset 32
 3000 0004 00AF     	 add r7,sp,#0
 3001              	.LCFI74:
 3002              	 .cfi_def_cfa_register 7
 3003 0006 7860     	 str r0,[r7,#4]
1726:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct tcp_seg *seg;
1727:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct tcp_seg **cur_seg;
1728:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1729:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_rexmit: invalid pcb", pcb != NULL);
1730:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1731:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pcb->unacked == NULL) {
 3004              	 .loc 1 1731 0
 3005 0008 7B68     	 ldr r3,[r7,#4]
 3006 000a 1B6F     	 ldr r3,[r3,#112]
 3007 000c 002B     	 cmp r3,#0
 3008 000e 01D1     	 bne .L171
1732:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return ERR_VAL;
 3009              	 .loc 1 1732 0
 3010 0010 FA23     	 movs r3,#250
 3011 0012 4BE0     	 b .L172
 3012              	.L171:
1733:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1734:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1735:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg = pcb->unacked;
 3013              	 .loc 1 1735 0
 3014 0014 7B68     	 ldr r3,[r7,#4]
 3015 0016 1B6F     	 ldr r3,[r3,#112]
 3016 0018 BB60     	 str r3,[r7,#8]
1736:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1737:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Give up if the segment is still referenced by the netif driver
1738:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      due to deferred transmission. */
1739:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (tcp_output_segment_busy(seg)) {
 3017              	 .loc 1 1739 0
 3018 001a B868     	 ldr r0,[r7,#8]
 3019 001c FFF7FEFF 	 bl tcp_output_segment_busy
 3020 0020 0346     	 mov r3,r0
 3021 0022 002B     	 cmp r3,#0
 3022 0024 01D0     	 beq .L173
1740:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit busy\n"));
1741:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return ERR_VAL;
 3023              	 .loc 1 1741 0
 3024 0026 FA23     	 movs r3,#250
 3025 0028 40E0     	 b .L172
 3026              	.L173:
1742:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1743:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1744:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Move the first unacked segment to the unsent queue */
1745:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Keep the unsent queue sorted. */
1746:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   pcb->unacked = seg->next;
 3027              	 .loc 1 1746 0
 3028 002a BB68     	 ldr r3,[r7,#8]
 3029 002c 1A68     	 ldr r2,[r3]
 3030 002e 7B68     	 ldr r3,[r7,#4]
 3031 0030 1A67     	 str r2,[r3,#112]
1747:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1748:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   cur_seg = &(pcb->unsent);
 3032              	 .loc 1 1748 0
 3033 0032 7B68     	 ldr r3,[r7,#4]
 3034 0034 6C33     	 adds r3,r3,#108
 3035 0036 FB60     	 str r3,[r7,#12]
1749:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   while (*cur_seg &&
 3036              	 .loc 1 1749 0
 3037 0038 02E0     	 b .L174
 3038              	.L176:
1750:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****          TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
1751:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     cur_seg = &((*cur_seg)->next );
 3039              	 .loc 1 1751 0
 3040 003a FB68     	 ldr r3,[r7,#12]
 3041 003c 1B68     	 ldr r3,[r3]
 3042 003e FB60     	 str r3,[r7,#12]
 3043              	.L174:
1749:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   while (*cur_seg &&
 3044              	 .loc 1 1749 0
 3045 0040 FB68     	 ldr r3,[r7,#12]
 3046 0042 1B68     	 ldr r3,[r3]
 3047 0044 002B     	 cmp r3,#0
 3048 0046 11D0     	 beq .L175
1750:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****          TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
 3049              	 .loc 1 1750 0 discriminator 1
 3050 0048 FB68     	 ldr r3,[r7,#12]
 3051 004a 1B68     	 ldr r3,[r3]
 3052 004c DB68     	 ldr r3,[r3,#12]
 3053 004e 5B68     	 ldr r3,[r3,#4]
 3054 0050 1846     	 mov r0,r3
 3055 0052 FFF7FEFF 	 bl lwip_htonl
 3056 0056 0446     	 mov r4,r0
 3057 0058 BB68     	 ldr r3,[r7,#8]
 3058 005a DB68     	 ldr r3,[r3,#12]
 3059 005c 5B68     	 ldr r3,[r3,#4]
 3060 005e 1846     	 mov r0,r3
 3061 0060 FFF7FEFF 	 bl lwip_htonl
 3062 0064 0346     	 mov r3,r0
 3063 0066 E31A     	 subs r3,r4,r3
1749:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   while (*cur_seg &&
 3064              	 .loc 1 1749 0 discriminator 1
 3065 0068 002B     	 cmp r3,#0
 3066 006a E6DB     	 blt .L176
 3067              	.L175:
1752:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1753:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg->next = *cur_seg;
 3068              	 .loc 1 1753 0
 3069 006c FB68     	 ldr r3,[r7,#12]
 3070 006e 1A68     	 ldr r2,[r3]
 3071 0070 BB68     	 ldr r3,[r7,#8]
 3072 0072 1A60     	 str r2,[r3]
1754:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   *cur_seg = seg;
 3073              	 .loc 1 1754 0
 3074 0074 FB68     	 ldr r3,[r7,#12]
 3075 0076 BA68     	 ldr r2,[r7,#8]
 3076 0078 1A60     	 str r2,[r3]
1755:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if TCP_OVERSIZE
1756:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (seg->next == NULL) {
 3077              	 .loc 1 1756 0
 3078 007a BB68     	 ldr r3,[r7,#8]
 3079 007c 1B68     	 ldr r3,[r3]
 3080 007e 002B     	 cmp r3,#0
 3081 0080 03D1     	 bne .L177
1757:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* the retransmitted segment is last in unsent, so reset unsent_oversize */
1758:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     pcb->unsent_oversize = 0;
 3082              	 .loc 1 1758 0
 3083 0082 7B68     	 ldr r3,[r7,#4]
 3084 0084 0022     	 movs r2,#0
 3085 0086 A3F86820 	 strh r2,[r3,#104]
 3086              	.L177:
1759:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1760:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif /* TCP_OVERSIZE */
1761:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1762:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pcb->nrtx < 0xFF) {
 3087              	 .loc 1 1762 0
 3088 008a 7B68     	 ldr r3,[r7,#4]
 3089 008c 93F84230 	 ldrb r3,[r3,#66]
 3090 0090 FF2B     	 cmp r3,#255
 3091 0092 07D0     	 beq .L178
1763:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     ++pcb->nrtx;
 3092              	 .loc 1 1763 0
 3093 0094 7B68     	 ldr r3,[r7,#4]
 3094 0096 93F84230 	 ldrb r3,[r3,#66]
 3095 009a 0133     	 adds r3,r3,#1
 3096 009c DAB2     	 uxtb r2,r3
 3097 009e 7B68     	 ldr r3,[r7,#4]
 3098 00a0 83F84220 	 strb r2,[r3,#66]
 3099              	.L178:
1764:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1765:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1766:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Don't take any rtt measurements after retransmitting. */
1767:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   pcb->rttest = 0;
 3100              	 .loc 1 1767 0
 3101 00a4 7B68     	 ldr r3,[r7,#4]
 3102 00a6 0022     	 movs r2,#0
 3103 00a8 5A63     	 str r2,[r3,#52]
1768:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1769:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Do the actual retransmission. */
1770:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   MIB2_STATS_INC(mib2.tcpretranssegs);
1771:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* No need to call tcp_output: we are always called from tcp_input()
1772:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      and thus tcp_output directly returns. */
1773:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   return ERR_OK;
 3104              	 .loc 1 1773 0
 3105 00aa 0023     	 movs r3,#0
 3106              	.L172:
 3107 00ac 5BB2     	 sxtb r3,r3
1774:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 3108              	 .loc 1 1774 0
 3109 00ae 1846     	 mov r0,r3
 3110 00b0 1437     	 adds r7,r7,#20
 3111              	.LCFI75:
 3112              	 .cfi_def_cfa_offset 12
 3113 00b2 BD46     	 mov sp,r7
 3114              	.LCFI76:
 3115              	 .cfi_def_cfa_register 13
 3116              	 
 3117 00b4 90BD     	 pop {r4,r7,pc}
 3118              	 .cfi_endproc
 3119              	.LFE147:
 3121 00b6 00BF     	 .section .text.tcp_rexmit_fast,"ax",%progbits
 3122              	 .align 2
 3123              	 .global tcp_rexmit_fast
 3124              	 .thumb
 3125              	 .thumb_func
 3127              	tcp_rexmit_fast:
 3128              	.LFB148:
1775:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1776:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1777:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /**
1778:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Handle retransmission after three dupacks received
1779:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1780:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb the tcp_pcb for which to retransmit the first unacked segment
1781:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
1782:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** void
1783:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_rexmit_fast(struct tcp_pcb *pcb)
1784:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 3129              	 .loc 1 1784 0
 3130              	 .cfi_startproc
 3131              	 
 3132              	 
 3133 0000 80B5     	 push {r7,lr}
 3134              	.LCFI77:
 3135              	 .cfi_def_cfa_offset 8
 3136              	 .cfi_offset 7,-8
 3137              	 .cfi_offset 14,-4
 3138 0002 82B0     	 sub sp,sp,#8
 3139              	.LCFI78:
 3140              	 .cfi_def_cfa_offset 16
 3141 0004 00AF     	 add r7,sp,#0
 3142              	.LCFI79:
 3143              	 .cfi_def_cfa_register 7
 3144 0006 7860     	 str r0,[r7,#4]
1785:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_rexmit_fast: invalid pcb", pcb != NULL);
1786:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1787:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 3145              	 .loc 1 1787 0
 3146 0008 7B68     	 ldr r3,[r7,#4]
 3147 000a 1B6F     	 ldr r3,[r3,#112]
 3148 000c 002B     	 cmp r3,#0
 3149 000e 44D0     	 beq .L179
 3150              	 .loc 1 1787 0 is_stmt 0 discriminator 1
 3151 0010 7B68     	 ldr r3,[r7,#4]
 3152 0012 5B8B     	 ldrh r3,[r3,#26]
 3153 0014 03F00403 	 and r3,r3,#4
 3154 0018 002B     	 cmp r3,#0
 3155 001a 3ED1     	 bne .L179
1788:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* This is fast retransmit. Retransmit the first unacked segment. */
1789:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_FR_DEBUG,
1790:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 ("tcp_receive: dupacks %"U16_F" (%"U32_F
1791:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                  "), fast retransmit %"U32_F"\n",
1792:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                  (u16_t)pcb->dupacks, pcb->lastack,
1793:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                  lwip_ntohl(pcb->unacked->tcphdr->seqno)));
1794:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if (tcp_rexmit(pcb) == ERR_OK) {
 3156              	 .loc 1 1794 0 is_stmt 1
 3157 001c 7868     	 ldr r0,[r7,#4]
 3158 001e FFF7FEFF 	 bl tcp_rexmit
 3159 0022 0346     	 mov r3,r0
 3160 0024 002B     	 cmp r3,#0
 3161 0026 38D1     	 bne .L179
1795:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       /* Set ssthresh to half of the minimum of the current
1796:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****        * cwnd and the advertised window */
1797:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       pcb->ssthresh = LWIP_MIN(pcb->cwnd, pcb->snd_wnd) / 2;
 3162              	 .loc 1 1797 0
 3163 0028 7B68     	 ldr r3,[r7,#4]
 3164 002a B3F86020 	 ldrh r2,[r3,#96]
 3165 002e 7B68     	 ldr r3,[r7,#4]
 3166 0030 B3F84830 	 ldrh r3,[r3,#72]
 3167 0034 9342     	 cmp r3,r2
 3168 0036 28BF     	 it cs
 3169 0038 1346     	 movcs r3,r2
 3170 003a 9BB2     	 uxth r3,r3
 3171 003c DA0F     	 lsrs r2,r3,#31
 3172 003e 1344     	 add r3,r3,r2
 3173 0040 5B10     	 asrs r3,r3,#1
 3174 0042 9AB2     	 uxth r2,r3
 3175 0044 7B68     	 ldr r3,[r7,#4]
 3176 0046 A3F84A20 	 strh r2,[r3,#74]
1798:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1799:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       /* The minimum value for ssthresh should be 2 MSS */
1800:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       if (pcb->ssthresh < (2U * pcb->mss)) {
 3177              	 .loc 1 1800 0
 3178 004a 7B68     	 ldr r3,[r7,#4]
 3179 004c B3F84A30 	 ldrh r3,[r3,#74]
 3180 0050 1A46     	 mov r2,r3
 3181 0052 7B68     	 ldr r3,[r7,#4]
 3182 0054 5B8E     	 ldrh r3,[r3,#50]
 3183 0056 5B00     	 lsls r3,r3,#1
 3184 0058 9A42     	 cmp r2,r3
 3185 005a 06D2     	 bcs .L181
1801:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         LWIP_DEBUGF(TCP_FR_DEBUG,
1802:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                     ("tcp_receive: The minimum value for ssthresh %"TCPWNDSIZE_F
1803:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                      " should be min 2 mss %"U16_F"...\n",
1804:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                      pcb->ssthresh, (u16_t)(2 * pcb->mss)));
1805:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         pcb->ssthresh = 2 * pcb->mss;
 3186              	 .loc 1 1805 0
 3187 005c 7B68     	 ldr r3,[r7,#4]
 3188 005e 5B8E     	 ldrh r3,[r3,#50]
 3189 0060 5B00     	 lsls r3,r3,#1
 3190 0062 9AB2     	 uxth r2,r3
 3191 0064 7B68     	 ldr r3,[r7,#4]
 3192 0066 A3F84A20 	 strh r2,[r3,#74]
 3193              	.L181:
1806:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       }
1807:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1808:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 3194              	 .loc 1 1808 0
 3195 006a 7B68     	 ldr r3,[r7,#4]
 3196 006c B3F84A20 	 ldrh r2,[r3,#74]
 3197 0070 7B68     	 ldr r3,[r7,#4]
 3198 0072 5B8E     	 ldrh r3,[r3,#50]
 3199 0074 1946     	 mov r1,r3
 3200 0076 4900     	 lsls r1,r1,#1
 3201 0078 0B44     	 add r3,r3,r1
 3202 007a 9BB2     	 uxth r3,r3
 3203 007c 1344     	 add r3,r3,r2
 3204 007e 9AB2     	 uxth r2,r3
 3205 0080 7B68     	 ldr r3,[r7,#4]
 3206 0082 A3F84820 	 strh r2,[r3,#72]
1809:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       tcp_set_flags(pcb, TF_INFR);
 3207              	 .loc 1 1809 0
 3208 0086 7B68     	 ldr r3,[r7,#4]
 3209 0088 5B8B     	 ldrh r3,[r3,#26]
 3210 008a 43F00403 	 orr r3,r3,#4
 3211 008e 9AB2     	 uxth r2,r3
 3212 0090 7B68     	 ldr r3,[r7,#4]
 3213 0092 5A83     	 strh r2,[r3,#26]
1810:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1811:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       /* Reset the retransmission timer to prevent immediate rto retransmissions */
1812:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       pcb->rtime = 0;
 3214              	 .loc 1 1812 0
 3215 0094 7B68     	 ldr r3,[r7,#4]
 3216 0096 0022     	 movs r2,#0
 3217 0098 1A86     	 strh r2,[r3,#48]
 3218              	.L179:
1813:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
1814:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1815:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 3219              	 .loc 1 1815 0
 3220 009a 0837     	 adds r7,r7,#8
 3221              	.LCFI80:
 3222              	 .cfi_def_cfa_offset 8
 3223 009c BD46     	 mov sp,r7
 3224              	.LCFI81:
 3225              	 .cfi_def_cfa_register 13
 3226              	 
 3227 009e 80BD     	 pop {r7,pc}
 3228              	 .cfi_endproc
 3229              	.LFE148:
 3231              	 .section .text.tcp_output_alloc_header_common,"ax",%progbits
 3232              	 .align 2
 3233              	 .thumb
 3234              	 .thumb_func
 3236              	tcp_output_alloc_header_common:
 3237              	.LFB149:
1816:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1817:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** static struct pbuf *
1818:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_output_alloc_header_common(u32_t ackno, u16_t optlen, u16_t datalen,
1819:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                         u32_t seqno_be /* already in network byte order */,
1820:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                         u16_t src_port, u16_t dst_port, u8_t flags, u16_t wnd)
1821:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 3238              	 .loc 1 1821 0
 3239              	 .cfi_startproc
 3240              	 
 3241              	 
 3242 0000 80B5     	 push {r7,lr}
 3243              	.LCFI82:
 3244              	 .cfi_def_cfa_offset 8
 3245              	 .cfi_offset 7,-8
 3246              	 .cfi_offset 14,-4
 3247 0002 86B0     	 sub sp,sp,#24
 3248              	.LCFI83:
 3249              	 .cfi_def_cfa_offset 32
 3250 0004 00AF     	 add r7,sp,#0
 3251              	.LCFI84:
 3252              	 .cfi_def_cfa_register 7
 3253 0006 F860     	 str r0,[r7,#12]
 3254 0008 7B60     	 str r3,[r7,#4]
 3255 000a 0B46     	 mov r3,r1
 3256 000c 7B81     	 strh r3,[r7,#10]
 3257 000e 1346     	 mov r3,r2
 3258 0010 3B81     	 strh r3,[r7,#8]
1822:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct tcp_hdr *tcphdr;
1823:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct pbuf *p;
1824:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1825:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 3259              	 .loc 1 1825 0
 3260 0012 7A89     	 ldrh r2,[r7,#10]
 3261 0014 3B89     	 ldrh r3,[r7,#8]
 3262 0016 1344     	 add r3,r3,r2
 3263 0018 9BB2     	 uxth r3,r3
 3264 001a 1433     	 adds r3,r3,#20
 3265 001c 9BB2     	 uxth r3,r3
 3266 001e 2420     	 movs r0,#36
 3267 0020 1946     	 mov r1,r3
 3268 0022 4FF42072 	 mov r2,#640
 3269 0026 FFF7FEFF 	 bl pbuf_alloc
 3270 002a 7861     	 str r0,[r7,#20]
1826:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (p != NULL) {
 3271              	 .loc 1 1826 0
 3272 002c 7B69     	 ldr r3,[r7,#20]
 3273 002e 002B     	 cmp r3,#0
 3274 0030 40D0     	 beq .L183
1827:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
1828:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 (p->len >= TCP_HLEN + optlen));
1829:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcphdr = (struct tcp_hdr *)p->payload;
 3275              	 .loc 1 1829 0
 3276 0032 7B69     	 ldr r3,[r7,#20]
 3277 0034 5B68     	 ldr r3,[r3,#4]
 3278 0036 3B61     	 str r3,[r7,#16]
1830:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcphdr->src = lwip_htons(src_port);
 3279              	 .loc 1 1830 0
 3280 0038 3B8C     	 ldrh r3,[r7,#32]
 3281 003a 1846     	 mov r0,r3
 3282 003c FFF7FEFF 	 bl lwip_htons
 3283 0040 0346     	 mov r3,r0
 3284 0042 1A46     	 mov r2,r3
 3285 0044 3B69     	 ldr r3,[r7,#16]
 3286 0046 1A80     	 strh r2,[r3]
1831:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcphdr->dest = lwip_htons(dst_port);
 3287              	 .loc 1 1831 0
 3288 0048 BB8C     	 ldrh r3,[r7,#36]
 3289 004a 1846     	 mov r0,r3
 3290 004c FFF7FEFF 	 bl lwip_htons
 3291 0050 0346     	 mov r3,r0
 3292 0052 1A46     	 mov r2,r3
 3293 0054 3B69     	 ldr r3,[r7,#16]
 3294 0056 5A80     	 strh r2,[r3,#2]
1832:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcphdr->seqno = seqno_be;
 3295              	 .loc 1 1832 0
 3296 0058 3B69     	 ldr r3,[r7,#16]
 3297 005a 7A68     	 ldr r2,[r7,#4]
 3298 005c 5A60     	 str r2,[r3,#4]
1833:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcphdr->ackno = lwip_htonl(ackno);
 3299              	 .loc 1 1833 0
 3300 005e F868     	 ldr r0,[r7,#12]
 3301 0060 FFF7FEFF 	 bl lwip_htonl
 3302 0064 0246     	 mov r2,r0
 3303 0066 3B69     	 ldr r3,[r7,#16]
 3304 0068 9A60     	 str r2,[r3,#8]
1834:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), flags);
 3305              	 .loc 1 1834 0
 3306 006a 7B89     	 ldrh r3,[r7,#10]
 3307 006c 9B08     	 lsrs r3,r3,#2
 3308 006e 9BB2     	 uxth r3,r3
 3309 0070 0533     	 adds r3,r3,#5
 3310 0072 9BB2     	 uxth r3,r3
 3311 0074 1B03     	 lsls r3,r3,#12
 3312 0076 9AB2     	 uxth r2,r3
 3313 0078 97F82830 	 ldrb r3,[r7,#40]
 3314 007c 9BB2     	 uxth r3,r3
 3315 007e 1343     	 orrs r3,r3,r2
 3316 0080 9BB2     	 uxth r3,r3
 3317 0082 1846     	 mov r0,r3
 3318 0084 FFF7FEFF 	 bl lwip_htons
 3319 0088 0346     	 mov r3,r0
 3320 008a 1A46     	 mov r2,r3
 3321 008c 3B69     	 ldr r3,[r7,#16]
 3322 008e 9A81     	 strh r2,[r3,#12]
1835:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcphdr->wnd = lwip_htons(wnd);
 3323              	 .loc 1 1835 0
 3324 0090 BB8D     	 ldrh r3,[r7,#44]
 3325 0092 1846     	 mov r0,r3
 3326 0094 FFF7FEFF 	 bl lwip_htons
 3327 0098 0346     	 mov r3,r0
 3328 009a 1A46     	 mov r2,r3
 3329 009c 3B69     	 ldr r3,[r7,#16]
 3330 009e DA81     	 strh r2,[r3,#14]
1836:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcphdr->chksum = 0;
 3331              	 .loc 1 1836 0
 3332 00a0 3B69     	 ldr r3,[r7,#16]
 3333 00a2 0022     	 movs r2,#0
 3334 00a4 1A74     	 strb r2,[r3,#16]
 3335 00a6 0022     	 movs r2,#0
 3336 00a8 5A74     	 strb r2,[r3,#17]
1837:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcphdr->urgp = 0;
 3337              	 .loc 1 1837 0
 3338 00aa 3B69     	 ldr r3,[r7,#16]
 3339 00ac 0022     	 movs r2,#0
 3340 00ae 9A74     	 strb r2,[r3,#18]
 3341 00b0 0022     	 movs r2,#0
 3342 00b2 DA74     	 strb r2,[r3,#19]
 3343              	.L183:
1838:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1839:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   return p;
 3344              	 .loc 1 1839 0
 3345 00b4 7B69     	 ldr r3,[r7,#20]
1840:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 3346              	 .loc 1 1840 0
 3347 00b6 1846     	 mov r0,r3
 3348 00b8 1837     	 adds r7,r7,#24
 3349              	.LCFI85:
 3350              	 .cfi_def_cfa_offset 8
 3351 00ba BD46     	 mov sp,r7
 3352              	.LCFI86:
 3353              	 .cfi_def_cfa_register 13
 3354              	 
 3355 00bc 80BD     	 pop {r7,pc}
 3356              	 .cfi_endproc
 3357              	.LFE149:
 3359 00be 00BF     	 .section .text.tcp_output_alloc_header,"ax",%progbits
 3360              	 .align 2
 3361              	 .thumb
 3362              	 .thumb_func
 3364              	tcp_output_alloc_header:
 3365              	.LFB150:
1841:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1842:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /** Allocate a pbuf and create a tcphdr at p->payload, used for output
1843:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * functions other than the default tcp_output -> tcp_output_segment
1844:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * (e.g. tcp_send_empty_ack, etc.)
1845:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1846:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb tcp pcb for which to send a packet (used to initialize tcp_hdr)
1847:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param optlen length of header-options
1848:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param datalen length of tcp data to reserve in pbuf
1849:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param seqno_be seqno in network byte order (big-endian)
1850:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @return pbuf with p->payload being the tcp_hdr
1851:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
1852:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** static struct pbuf *
1853:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
1854:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                         u32_t seqno_be /* already in network byte order */)
1855:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 3366              	 .loc 1 1855 0
 3367              	 .cfi_startproc
 3368              	 
 3369              	 
 3370 0000 B0B5     	 push {r4,r5,r7,lr}
 3371              	.LCFI87:
 3372              	 .cfi_def_cfa_offset 16
 3373              	 .cfi_offset 4,-16
 3374              	 .cfi_offset 5,-12
 3375              	 .cfi_offset 7,-8
 3376              	 .cfi_offset 14,-4
 3377 0002 8AB0     	 sub sp,sp,#40
 3378              	.LCFI88:
 3379              	 .cfi_def_cfa_offset 56
 3380 0004 04AF     	 add r7,sp,#16
 3381              	.LCFI89:
 3382              	 .cfi_def_cfa 7,40
 3383 0006 F860     	 str r0,[r7,#12]
 3384 0008 7B60     	 str r3,[r7,#4]
 3385 000a 0B46     	 mov r3,r1
 3386 000c 7B81     	 strh r3,[r7,#10]
 3387 000e 1346     	 mov r3,r2
 3388 0010 3B81     	 strh r3,[r7,#8]
1856:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct pbuf *p;
1857:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1858:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_output_alloc_header: invalid pcb", pcb != NULL);
1859:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1860:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   p = tcp_output_alloc_header_common(pcb->rcv_nxt, optlen, datalen,
 3389              	 .loc 1 1860 0
 3390 0012 FB68     	 ldr r3,[r7,#12]
 3391 0014 586A     	 ldr r0,[r3,#36]
 3392 0016 FB68     	 ldr r3,[r7,#12]
 3393 0018 D98A     	 ldrh r1,[r3,#22]
 3394 001a FB68     	 ldr r3,[r7,#12]
 3395 001c 1A8B     	 ldrh r2,[r3,#24]
 3396 001e FB68     	 ldr r3,[r7,#12]
 3397 0020 5B8D     	 ldrh r3,[r3,#42]
 3398 0022 7D89     	 ldrh r5,[r7,#10]
 3399 0024 3C89     	 ldrh r4,[r7,#8]
 3400 0026 0091     	 str r1,[sp]
 3401 0028 0192     	 str r2,[sp,#4]
 3402 002a 1022     	 movs r2,#16
 3403 002c 0292     	 str r2,[sp,#8]
 3404 002e 0393     	 str r3,[sp,#12]
 3405 0030 2946     	 mov r1,r5
 3406 0032 2246     	 mov r2,r4
 3407 0034 7B68     	 ldr r3,[r7,#4]
 3408 0036 FFF7FEFF 	 bl tcp_output_alloc_header_common
 3409 003a 7861     	 str r0,[r7,#20]
1861:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     seqno_be, pcb->local_port, pcb->remote_port, TCP_ACK,
1862:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
1863:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (p != NULL) {
 3410              	 .loc 1 1863 0
 3411 003c 7B69     	 ldr r3,[r7,#20]
 3412 003e 002B     	 cmp r3,#0
 3413 0040 06D0     	 beq .L186
1864:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* If we're sending a packet, update the announced right window edge */
1865:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 3414              	 .loc 1 1865 0
 3415 0042 FB68     	 ldr r3,[r7,#12]
 3416 0044 5B6A     	 ldr r3,[r3,#36]
 3417 0046 FA68     	 ldr r2,[r7,#12]
 3418 0048 528D     	 ldrh r2,[r2,#42]
 3419 004a 1A44     	 add r2,r2,r3
 3420 004c FB68     	 ldr r3,[r7,#12]
 3421 004e DA62     	 str r2,[r3,#44]
 3422              	.L186:
1866:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1867:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   return p;
 3423              	 .loc 1 1867 0
 3424 0050 7B69     	 ldr r3,[r7,#20]
1868:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 3425              	 .loc 1 1868 0
 3426 0052 1846     	 mov r0,r3
 3427 0054 1837     	 adds r7,r7,#24
 3428              	.LCFI90:
 3429              	 .cfi_def_cfa_offset 16
 3430 0056 BD46     	 mov sp,r7
 3431              	.LCFI91:
 3432              	 .cfi_def_cfa_register 13
 3433              	 
 3434 0058 B0BD     	 pop {r4,r5,r7,pc}
 3435              	 .cfi_endproc
 3436              	.LFE150:
 3438 005a 00BF     	 .section .text.tcp_output_fill_options,"ax",%progbits
 3439              	 .align 2
 3440              	 .thumb
 3441              	 .thumb_func
 3443              	tcp_output_fill_options:
 3444              	.LFB151:
1869:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1870:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /* Fill in options for control segments */
1871:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** static void
1872:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_output_fill_options(const struct tcp_pcb *pcb, struct pbuf *p, u8_t optflags, u8_t num_sacks)
1873:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 3445              	 .loc 1 1873 0
 3446              	 .cfi_startproc
 3447              	 
 3448              	 
 3449              	 
 3450 0000 80B4     	 push {r7}
 3451              	.LCFI92:
 3452              	 .cfi_def_cfa_offset 4
 3453              	 .cfi_offset 7,-4
 3454 0002 89B0     	 sub sp,sp,#36
 3455              	.LCFI93:
 3456              	 .cfi_def_cfa_offset 40
 3457 0004 00AF     	 add r7,sp,#0
 3458              	.LCFI94:
 3459              	 .cfi_def_cfa_register 7
 3460 0006 F860     	 str r0,[r7,#12]
 3461 0008 B960     	 str r1,[r7,#8]
 3462 000a 1146     	 mov r1,r2
 3463 000c 1A46     	 mov r2,r3
 3464 000e 0B46     	 mov r3,r1
 3465 0010 FB71     	 strb r3,[r7,#7]
 3466 0012 1346     	 mov r3,r2
 3467 0014 BB71     	 strb r3,[r7,#6]
1874:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct tcp_hdr *tcphdr;
1875:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u32_t *opts;
1876:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u16_t sacks_len = 0;
 3468              	 .loc 1 1876 0
 3469 0016 0023     	 movs r3,#0
 3470 0018 FB83     	 strh r3,[r7,#30]
1877:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1878:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_output_fill_options: invalid pbuf", p != NULL);
1879:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1880:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   tcphdr = (struct tcp_hdr *)p->payload;
 3471              	 .loc 1 1880 0
 3472 001a BB68     	 ldr r3,[r7,#8]
 3473 001c 5B68     	 ldr r3,[r3,#4]
 3474 001e BB61     	 str r3,[r7,#24]
1881:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   opts = (u32_t *)(void *)(tcphdr + 1);
 3475              	 .loc 1 1881 0
 3476 0020 BB69     	 ldr r3,[r7,#24]
 3477 0022 1433     	 adds r3,r3,#20
 3478 0024 7B61     	 str r3,[r7,#20]
1882:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1883:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* NB. MSS and window scale options are only sent on SYNs, so ignore them here */
1884:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1885:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if LWIP_TCP_TIMESTAMPS
1886:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (optflags & TF_SEG_OPTS_TS) {
1887:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcp_build_timestamp_option(pcb, opts);
1888:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     opts += 3;
1889:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1890:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
1891:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1892:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if LWIP_TCP_SACK_OUT
1893:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pcb && (num_sacks > 0)) {
1894:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcp_build_sack_option(pcb, opts, num_sacks);
1895:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* 1 word for SACKs header (including 2xNOP), and 2 words for each SACK */
1896:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     sacks_len = 1 + num_sacks * 2;
1897:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     opts += sacks_len;
1898:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1899:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #else
1900:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_UNUSED_ARG(num_sacks);
1901:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
1902:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1903:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #ifdef LWIP_HOOK_TCP_OUT_ADD_TCPOPTS
1904:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   opts = LWIP_HOOK_TCP_OUT_ADD_TCPOPTS(p, tcphdr, pcb, opts);
1905:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
1906:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1907:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_UNUSED_ARG(pcb);
1908:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_UNUSED_ARG(sacks_len);
1909:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(tcphdr + 1)) + sacks_len * 4 + LWIP_T
1910:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_UNUSED_ARG(optflags); /* for LWIP_NOASSERT */
1911:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_UNUSED_ARG(opts); /* for LWIP_NOASSERT */
1912:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 3479              	 .loc 1 1912 0
 3480 0026 2437     	 adds r7,r7,#36
 3481              	.LCFI95:
 3482              	 .cfi_def_cfa_offset 4
 3483 0028 BD46     	 mov sp,r7
 3484              	.LCFI96:
 3485              	 .cfi_def_cfa_register 13
 3486              	 
 3487 002a 5DF8047B 	 ldr r7,[sp],#4
 3488              	.LCFI97:
 3489              	 .cfi_restore 7
 3490              	 .cfi_def_cfa_offset 0
 3491 002e 7047     	 bx lr
 3492              	 .cfi_endproc
 3493              	.LFE151:
 3495              	 .section .text.tcp_output_control_segment,"ax",%progbits
 3496              	 .align 2
 3497              	 .thumb
 3498              	 .thumb_func
 3500              	tcp_output_control_segment:
 3501              	.LFB152:
1913:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1914:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /** Output a control segment pbuf to IP.
1915:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1916:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Called from tcp_rst, tcp_send_empty_ack, tcp_keepalive and tcp_zero_window_probe,
1917:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * this function combines selecting a netif for transmission, generating the tcp
1918:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * header checksum and calling ip_output_if while handling netif hints and stats.
1919:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
1920:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** static err_t
1921:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_output_control_segment(const struct tcp_pcb *pcb, struct pbuf *p,
1922:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                            const ip_addr_t *src, const ip_addr_t *dst)
1923:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 3502              	 .loc 1 1923 0
 3503              	 .cfi_startproc
 3504              	 
 3505              	 
 3506 0000 90B5     	 push {r4,r7,lr}
 3507              	.LCFI98:
 3508              	 .cfi_def_cfa_offset 12
 3509              	 .cfi_offset 4,-12
 3510              	 .cfi_offset 7,-8
 3511              	 .cfi_offset 14,-4
 3512 0002 8BB0     	 sub sp,sp,#44
 3513              	.LCFI99:
 3514              	 .cfi_def_cfa_offset 56
 3515 0004 04AF     	 add r7,sp,#16
 3516              	.LCFI100:
 3517              	 .cfi_def_cfa 7,40
 3518 0006 F860     	 str r0,[r7,#12]
 3519 0008 B960     	 str r1,[r7,#8]
 3520 000a 7A60     	 str r2,[r7,#4]
 3521 000c 3B60     	 str r3,[r7]
1924:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   err_t err;
1925:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct netif *netif;
1926:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1927:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_output_control_segment: invalid pbuf", p != NULL);
1928:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1929:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   netif = tcp_route(pcb, src, dst);
 3522              	 .loc 1 1929 0
 3523 000e F868     	 ldr r0,[r7,#12]
 3524 0010 7968     	 ldr r1,[r7,#4]
 3525 0012 3A68     	 ldr r2,[r7]
 3526 0014 FFF7FEFF 	 bl tcp_route
 3527 0018 3861     	 str r0,[r7,#16]
1930:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (netif == NULL) {
 3528              	 .loc 1 1930 0
 3529 001a 3B69     	 ldr r3,[r7,#16]
 3530 001c 002B     	 cmp r3,#0
 3531 001e 02D1     	 bne .L190
1931:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     err = ERR_RTE;
 3532              	 .loc 1 1931 0
 3533 0020 FC23     	 movs r3,#252
 3534 0022 FB75     	 strb r3,[r7,#23]
 3535 0024 1CE0     	 b .L191
 3536              	.L190:
 3537              	.LBB14:
1932:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   } else {
1933:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     u8_t ttl, tos;
1934:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if CHECKSUM_GEN_TCP
1935:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
1936:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       struct tcp_hdr *tcphdr = (struct tcp_hdr *)p->payload;
1937:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
1938:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                                         src, dst);
1939:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
1940:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
1941:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     if (pcb != NULL) {
 3538              	 .loc 1 1941 0
 3539 0026 FB68     	 ldr r3,[r7,#12]
 3540 0028 002B     	 cmp r3,#0
 3541 002a 06D0     	 beq .L192
1942:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       NETIF_SET_HINTS(netif, LWIP_CONST_CAST(struct netif_hint*, &(pcb->netif_hints)));
1943:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       ttl = pcb->ttl;
 3542              	 .loc 1 1943 0
 3543 002c FB68     	 ldr r3,[r7,#12]
 3544 002e DB7A     	 ldrb r3,[r3,#11]
 3545 0030 BB75     	 strb r3,[r7,#22]
1944:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       tos = pcb->tos;
 3546              	 .loc 1 1944 0
 3547 0032 FB68     	 ldr r3,[r7,#12]
 3548 0034 9B7A     	 ldrb r3,[r3,#10]
 3549 0036 7B75     	 strb r3,[r7,#21]
 3550 0038 03E0     	 b .L193
 3551              	.L192:
1945:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     } else {
1946:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       /* Send output with hardcoded TTL/HL since we have no access to the pcb */
1947:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       ttl = TCP_TTL;
 3552              	 .loc 1 1947 0
 3553 003a FF23     	 movs r3,#255
 3554 003c BB75     	 strb r3,[r7,#22]
1948:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****       tos = 0;
 3555              	 .loc 1 1948 0
 3556 003e 0023     	 movs r3,#0
 3557 0040 7B75     	 strb r3,[r7,#21]
 3558              	.L193:
1949:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     }
1950:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     TCP_STATS_INC(tcp.xmit);
1951:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     err = ip_output_if(p, src, dst, ttl, tos, IP_PROTO_TCP, netif);
 3559              	 .loc 1 1951 0
 3560 0042 BC7D     	 ldrb r4,[r7,#22]
 3561 0044 7B7D     	 ldrb r3,[r7,#21]
 3562 0046 0093     	 str r3,[sp]
 3563 0048 0623     	 movs r3,#6
 3564 004a 0193     	 str r3,[sp,#4]
 3565 004c 3B69     	 ldr r3,[r7,#16]
 3566 004e 0293     	 str r3,[sp,#8]
 3567 0050 B868     	 ldr r0,[r7,#8]
 3568 0052 7968     	 ldr r1,[r7,#4]
 3569 0054 3A68     	 ldr r2,[r7]
 3570 0056 2346     	 mov r3,r4
 3571 0058 FFF7FEFF 	 bl ip4_output_if
 3572 005c 0346     	 mov r3,r0
 3573 005e FB75     	 strb r3,[r7,#23]
 3574              	.L191:
 3575              	.LBE14:
1952:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     NETIF_RESET_HINTS(netif);
1953:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
1954:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   pbuf_free(p);
 3576              	 .loc 1 1954 0
 3577 0060 B868     	 ldr r0,[r7,#8]
 3578 0062 FFF7FEFF 	 bl pbuf_free
1955:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   return err;
 3579              	 .loc 1 1955 0
 3580 0066 FB7D     	 ldrb r3,[r7,#23]
 3581 0068 5BB2     	 sxtb r3,r3
1956:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 3582              	 .loc 1 1956 0
 3583 006a 1846     	 mov r0,r3
 3584 006c 1C37     	 adds r7,r7,#28
 3585              	.LCFI101:
 3586              	 .cfi_def_cfa_offset 12
 3587 006e BD46     	 mov sp,r7
 3588              	.LCFI102:
 3589              	 .cfi_def_cfa_register 13
 3590              	 
 3591 0070 90BD     	 pop {r4,r7,pc}
 3592              	 .cfi_endproc
 3593              	.LFE152:
 3595 0072 00BF     	 .section .text.tcp_rst,"ax",%progbits
 3596              	 .align 2
 3597              	 .global tcp_rst
 3598              	 .thumb
 3599              	 .thumb_func
 3601              	tcp_rst:
 3602              	.LFB153:
1957:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1958:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /**
1959:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Send a TCP RESET packet (empty segment with RST flag set) either to
1960:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * abort a connection or to show that there is no matching local connection
1961:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * for a received segment.
1962:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1963:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Called by tcp_abort() (to abort a local connection), tcp_input() (if no
1964:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * matching local pcb was found), tcp_listen_input() (if incoming segment
1965:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * has ACK flag set) and tcp_process() (received segment in the wrong state)
1966:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1967:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Since a RST segment is in most cases not sent for an active connection,
1968:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * tcp_rst() has a number of arguments that are taken from a tcp_pcb for
1969:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * most other segment output functions.
1970:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
1971:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb TCP pcb (may be NULL if no pcb is available)
1972:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param seqno the sequence number to use for the outgoing segment
1973:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param ackno the acknowledge number to use for the outgoing segment
1974:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param local_ip the local IP address to send the segment from
1975:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param remote_ip the remote IP address to send the segment to
1976:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param local_port the local TCP port to send the segment from
1977:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param remote_port the remote TCP port to send the segment to
1978:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
1979:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** void
1980:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_rst(const struct tcp_pcb *pcb, u32_t seqno, u32_t ackno,
1981:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         const ip_addr_t *local_ip, const ip_addr_t *remote_ip,
1982:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****         u16_t local_port, u16_t remote_port)
1983:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 3603              	 .loc 1 1983 0
 3604              	 .cfi_startproc
 3605              	 
 3606              	 
 3607 0000 B0B5     	 push {r4,r5,r7,lr}
 3608              	.LCFI103:
 3609              	 .cfi_def_cfa_offset 16
 3610              	 .cfi_offset 4,-16
 3611              	 .cfi_offset 5,-12
 3612              	 .cfi_offset 7,-8
 3613              	 .cfi_offset 14,-4
 3614 0002 8AB0     	 sub sp,sp,#40
 3615              	.LCFI104:
 3616              	 .cfi_def_cfa_offset 56
 3617 0004 04AF     	 add r7,sp,#16
 3618              	.LCFI105:
 3619              	 .cfi_def_cfa 7,40
 3620 0006 F860     	 str r0,[r7,#12]
 3621 0008 B960     	 str r1,[r7,#8]
 3622 000a 7A60     	 str r2,[r7,#4]
 3623 000c 3B60     	 str r3,[r7]
1984:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct pbuf *p;
1985:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u16_t wnd;
1986:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u8_t optlen;
1987:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1988:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_rst: invalid local_ip", local_ip != NULL);
1989:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_rst: invalid remote_ip", remote_ip != NULL);
1990:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1991:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 3624              	 .loc 1 1991 0
 3625 000e 0023     	 movs r3,#0
 3626 0010 FB75     	 strb r3,[r7,#23]
1992:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1993:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if LWIP_WND_SCALE
1994:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   wnd = PP_HTONS(((TCP_WND >> TCP_RCV_SCALE) & 0xFFFF));
1995:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #else
1996:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   wnd = PP_HTONS(TCP_WND);
 3627              	 .loc 1 1996 0
 3628 0012 46F20803 	 movw r3,#24584
 3629 0016 BB82     	 strh r3,[r7,#20]
1997:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
1998:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
1999:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   p = tcp_output_alloc_header_common(ackno, optlen, 0, lwip_htonl(seqno), local_port,
 3630              	 .loc 1 1999 0
 3631 0018 FB7D     	 ldrb r3,[r7,#23]
 3632 001a 9CB2     	 uxth r4,r3
 3633 001c B868     	 ldr r0,[r7,#8]
 3634 001e FFF7FEFF 	 bl lwip_htonl
 3635 0022 0546     	 mov r5,r0
 3636 0024 BB8D     	 ldrh r3,[r7,#44]
 3637 0026 0093     	 str r3,[sp]
 3638 0028 3B8E     	 ldrh r3,[r7,#48]
 3639 002a 0193     	 str r3,[sp,#4]
 3640 002c 1423     	 movs r3,#20
 3641 002e 0293     	 str r3,[sp,#8]
 3642 0030 BB8A     	 ldrh r3,[r7,#20]
 3643 0032 0393     	 str r3,[sp,#12]
 3644 0034 7868     	 ldr r0,[r7,#4]
 3645 0036 2146     	 mov r1,r4
 3646 0038 0022     	 movs r2,#0
 3647 003a 2B46     	 mov r3,r5
 3648 003c FFF7FEFF 	 bl tcp_output_alloc_header_common
 3649 0040 3861     	 str r0,[r7,#16]
2000:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     remote_port, TCP_RST | TCP_ACK, wnd);
2001:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (p == NULL) {
 3650              	 .loc 1 2001 0
 3651 0042 3B69     	 ldr r3,[r7,#16]
 3652 0044 002B     	 cmp r3,#0
 3653 0046 00D1     	 bne .L196
2002:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
2003:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return;
 3654              	 .loc 1 2003 0
 3655 0048 0BE0     	 b .L195
 3656              	.L196:
2004:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
2005:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   tcp_output_fill_options(pcb, p, 0, optlen);
 3657              	 .loc 1 2005 0
 3658 004a FB7D     	 ldrb r3,[r7,#23]
 3659 004c F868     	 ldr r0,[r7,#12]
 3660 004e 3969     	 ldr r1,[r7,#16]
 3661 0050 0022     	 movs r2,#0
 3662 0052 FFF7FEFF 	 bl tcp_output_fill_options
2006:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2007:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   MIB2_STATS_INC(mib2.tcpoutrsts);
2008:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2009:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   tcp_output_control_segment(pcb, p, local_ip, remote_ip);
 3663              	 .loc 1 2009 0
 3664 0056 F868     	 ldr r0,[r7,#12]
 3665 0058 3969     	 ldr r1,[r7,#16]
 3666 005a 3A68     	 ldr r2,[r7]
 3667 005c BB6A     	 ldr r3,[r7,#40]
 3668 005e FFF7FEFF 	 bl tcp_output_control_segment
 3669              	.L195:
2010:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
2011:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 3670              	 .loc 1 2011 0
 3671 0062 1837     	 adds r7,r7,#24
 3672              	.LCFI106:
 3673              	 .cfi_def_cfa_offset 16
 3674 0064 BD46     	 mov sp,r7
 3675              	.LCFI107:
 3676              	 .cfi_def_cfa_register 13
 3677              	 
 3678 0066 B0BD     	 pop {r4,r5,r7,pc}
 3679              	 .cfi_endproc
 3680              	.LFE153:
 3682              	 .section .text.tcp_send_empty_ack,"ax",%progbits
 3683              	 .align 2
 3684              	 .global tcp_send_empty_ack
 3685              	 .thumb
 3686              	 .thumb_func
 3688              	tcp_send_empty_ack:
 3689              	.LFB154:
2012:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2013:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /**
2014:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Send an ACK without data.
2015:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
2016:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb Protocol control block for the TCP connection to send the ACK
2017:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
2018:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** err_t
2019:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_send_empty_ack(struct tcp_pcb *pcb)
2020:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 3690              	 .loc 1 2020 0
 3691              	 .cfi_startproc
 3692              	 
 3693              	 
 3694 0000 90B5     	 push {r4,r7,lr}
 3695              	.LCFI108:
 3696              	 .cfi_def_cfa_offset 12
 3697              	 .cfi_offset 4,-12
 3698              	 .cfi_offset 7,-8
 3699              	 .cfi_offset 14,-4
 3700 0002 87B0     	 sub sp,sp,#28
 3701              	.LCFI109:
 3702              	 .cfi_def_cfa_offset 40
 3703 0004 00AF     	 add r7,sp,#0
 3704              	.LCFI110:
 3705              	 .cfi_def_cfa_register 7
 3706 0006 7860     	 str r0,[r7,#4]
2021:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   err_t err;
2022:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct pbuf *p;
2023:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u8_t optlen, optflags = 0;
 3707              	 .loc 1 2023 0
 3708 0008 0023     	 movs r3,#0
 3709 000a FB75     	 strb r3,[r7,#23]
2024:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u8_t num_sacks = 0;
 3710              	 .loc 1 2024 0
 3711 000c 0023     	 movs r3,#0
 3712 000e BB75     	 strb r3,[r7,#22]
2025:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2026:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_send_empty_ack: invalid pcb", pcb != NULL);
2027:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2028:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if LWIP_TCP_TIMESTAMPS
2029:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pcb->flags & TF_TIMESTAMP) {
2030:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     optflags = TF_SEG_OPTS_TS;
2031:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
2032:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
2033:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 3713              	 .loc 1 2033 0
 3714 0010 FB7D     	 ldrb r3,[r7,#23]
 3715 0012 03F00103 	 and r3,r3,#1
 3716 0016 002B     	 cmp r3,#0
 3717 0018 01D0     	 beq .L199
 3718              	 .loc 1 2033 0 is_stmt 0 discriminator 1
 3719 001a 0423     	 movs r3,#4
 3720 001c 00E0     	 b .L200
 3721              	.L199:
 3722              	 .loc 1 2033 0 discriminator 2
 3723 001e 0023     	 movs r3,#0
 3724              	.L200:
 3725              	 .loc 1 2033 0 discriminator 4
 3726 0020 7B75     	 strb r3,[r7,#21]
2034:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2035:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if LWIP_TCP_SACK_OUT
2036:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* For now, SACKs are only sent with empty ACKs */
2037:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if ((num_sacks = tcp_get_num_sacks(pcb, optlen)) > 0) {
2038:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     optlen += 4 + num_sacks * 8; /* 4 bytes for header (including 2*NOP), plus 8B for each SACK */
2039:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
2040:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
2041:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2042:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt));
 3727              	 .loc 1 2042 0 is_stmt 1 discriminator 4
 3728 0022 7B7D     	 ldrb r3,[r7,#21]
 3729 0024 9CB2     	 uxth r4,r3
 3730 0026 7B68     	 ldr r3,[r7,#4]
 3731 0028 1B6D     	 ldr r3,[r3,#80]
 3732 002a 1846     	 mov r0,r3
 3733 002c FFF7FEFF 	 bl lwip_htonl
 3734 0030 0346     	 mov r3,r0
 3735 0032 7868     	 ldr r0,[r7,#4]
 3736 0034 2146     	 mov r1,r4
 3737 0036 0022     	 movs r2,#0
 3738 0038 FFF7FEFF 	 bl tcp_output_alloc_header
 3739 003c 3861     	 str r0,[r7,#16]
2043:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (p == NULL) {
 3740              	 .loc 1 2043 0 discriminator 4
 3741 003e 3B69     	 ldr r3,[r7,#16]
 3742 0040 002B     	 cmp r3,#0
 3743 0042 08D1     	 bne .L201
2044:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* let tcp_fasttmr retry sending this ACK */
2045:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 3744              	 .loc 1 2045 0
 3745 0044 7B68     	 ldr r3,[r7,#4]
 3746 0046 5B8B     	 ldrh r3,[r3,#26]
 3747 0048 43F00303 	 orr r3,r3,#3
 3748 004c 9AB2     	 uxth r2,r3
 3749 004e 7B68     	 ldr r3,[r7,#4]
 3750 0050 5A83     	 strh r2,[r3,#26]
2046:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
2047:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return ERR_BUF;
 3751              	 .loc 1 2047 0
 3752 0052 FE23     	 movs r3,#254
 3753 0054 22E0     	 b .L202
 3754              	.L201:
2048:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
2049:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   tcp_output_fill_options(pcb, p, optflags, num_sacks);
 3755              	 .loc 1 2049 0
 3756 0056 FA7D     	 ldrb r2,[r7,#23]
 3757 0058 BB7D     	 ldrb r3,[r7,#22]
 3758 005a 7868     	 ldr r0,[r7,#4]
 3759 005c 3969     	 ldr r1,[r7,#16]
 3760 005e FFF7FEFF 	 bl tcp_output_fill_options
2050:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2051:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #if LWIP_TCP_TIMESTAMPS
2052:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   pcb->ts_lastacksent = pcb->rcv_nxt;
2053:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** #endif
2054:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2055:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_DEBUGF(TCP_OUTPUT_DEBUG,
2056:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****               ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
2057:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 3761              	 .loc 1 2057 0
 3762 0062 7A68     	 ldr r2,[r7,#4]
 3763 0064 7B68     	 ldr r3,[r7,#4]
 3764 0066 0433     	 adds r3,r3,#4
 3765 0068 7868     	 ldr r0,[r7,#4]
 3766 006a 3969     	 ldr r1,[r7,#16]
 3767 006c FFF7FEFF 	 bl tcp_output_control_segment
 3768 0070 0346     	 mov r3,r0
 3769 0072 FB73     	 strb r3,[r7,#15]
2058:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (err != ERR_OK) {
 3770              	 .loc 1 2058 0
 3771 0074 97F90F30 	 ldrsb r3,[r7,#15]
 3772 0078 002B     	 cmp r3,#0
 3773 007a 07D0     	 beq .L203
2059:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* let tcp_fasttmr retry sending this ACK */
2060:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 3774              	 .loc 1 2060 0
 3775 007c 7B68     	 ldr r3,[r7,#4]
 3776 007e 5B8B     	 ldrh r3,[r3,#26]
 3777 0080 43F00303 	 orr r3,r3,#3
 3778 0084 9AB2     	 uxth r2,r3
 3779 0086 7B68     	 ldr r3,[r7,#4]
 3780 0088 5A83     	 strh r2,[r3,#26]
 3781 008a 06E0     	 b .L204
 3782              	.L203:
2061:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   } else {
2062:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* remove ACK flags from the PCB, as we sent an empty ACK now */
2063:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 3783              	 .loc 1 2063 0
 3784 008c 7B68     	 ldr r3,[r7,#4]
 3785 008e 5B8B     	 ldrh r3,[r3,#26]
 3786 0090 23F00303 	 bic r3,r3,#3
 3787 0094 9AB2     	 uxth r2,r3
 3788 0096 7B68     	 ldr r3,[r7,#4]
 3789 0098 5A83     	 strh r2,[r3,#26]
 3790              	.L204:
2064:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
2065:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2066:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   return err;
 3791              	 .loc 1 2066 0
 3792 009a FB7B     	 ldrb r3,[r7,#15]
 3793              	.L202:
 3794 009c 5BB2     	 sxtb r3,r3
2067:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 3795              	 .loc 1 2067 0
 3796 009e 1846     	 mov r0,r3
 3797 00a0 1C37     	 adds r7,r7,#28
 3798              	.LCFI111:
 3799              	 .cfi_def_cfa_offset 12
 3800 00a2 BD46     	 mov sp,r7
 3801              	.LCFI112:
 3802              	 .cfi_def_cfa_register 13
 3803              	 
 3804 00a4 90BD     	 pop {r4,r7,pc}
 3805              	 .cfi_endproc
 3806              	.LFE154:
 3808 00a6 00BF     	 .section .text.tcp_keepalive,"ax",%progbits
 3809              	 .align 2
 3810              	 .global tcp_keepalive
 3811              	 .thumb
 3812              	 .thumb_func
 3814              	tcp_keepalive:
 3815              	.LFB155:
2068:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2069:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /**
2070:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Send keepalive packets to keep a connection active although
2071:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * no data is sent over it.
2072:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
2073:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Called by tcp_slowtmr()
2074:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
2075:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb the tcp_pcb for which to send a keepalive packet
2076:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
2077:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** err_t
2078:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_keepalive(struct tcp_pcb *pcb)
2079:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 3816              	 .loc 1 2079 0
 3817              	 .cfi_startproc
 3818              	 
 3819              	 
 3820 0000 90B5     	 push {r4,r7,lr}
 3821              	.LCFI113:
 3822              	 .cfi_def_cfa_offset 12
 3823              	 .cfi_offset 4,-12
 3824              	 .cfi_offset 7,-8
 3825              	 .cfi_offset 14,-4
 3826 0002 87B0     	 sub sp,sp,#28
 3827              	.LCFI114:
 3828              	 .cfi_def_cfa_offset 40
 3829 0004 00AF     	 add r7,sp,#0
 3830              	.LCFI115:
 3831              	 .cfi_def_cfa_register 7
 3832 0006 7860     	 str r0,[r7,#4]
2080:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   err_t err;
2081:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct pbuf *p;
2082:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 3833              	 .loc 1 2082 0
 3834 0008 0023     	 movs r3,#0
 3835 000a FB75     	 strb r3,[r7,#23]
2083:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2084:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_keepalive: invalid pcb", pcb != NULL);
2085:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2086:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: sending KEEPALIVE probe to "));
2087:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   ip_addr_debug_print_val(TCP_DEBUG, pcb->remote_ip);
2088:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_DEBUGF(TCP_DEBUG, ("\n"));
2089:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2090:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent
2091:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                           tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));
2092:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2093:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt - 1));
 3836              	 .loc 1 2093 0
 3837 000c FB7D     	 ldrb r3,[r7,#23]
 3838 000e 9CB2     	 uxth r4,r3
 3839 0010 7B68     	 ldr r3,[r7,#4]
 3840 0012 1B6D     	 ldr r3,[r3,#80]
 3841 0014 013B     	 subs r3,r3,#1
 3842 0016 1846     	 mov r0,r3
 3843 0018 FFF7FEFF 	 bl lwip_htonl
 3844 001c 0346     	 mov r3,r0
 3845 001e 7868     	 ldr r0,[r7,#4]
 3846 0020 2146     	 mov r1,r4
 3847 0022 0022     	 movs r2,#0
 3848 0024 FFF7FEFF 	 bl tcp_output_alloc_header
 3849 0028 3861     	 str r0,[r7,#16]
2094:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (p == NULL) {
 3850              	 .loc 1 2094 0
 3851 002a 3B69     	 ldr r3,[r7,#16]
 3852 002c 002B     	 cmp r3,#0
 3853 002e 01D1     	 bne .L206
2095:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_DEBUG,
2096:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                 ("tcp_keepalive: could not allocate memory for pbuf\n"));
2097:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return ERR_MEM;
 3854              	 .loc 1 2097 0
 3855 0030 FF23     	 movs r3,#255
 3856 0032 0FE0     	 b .L207
 3857              	.L206:
2098:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
2099:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   tcp_output_fill_options(pcb, p, 0, optlen);
 3858              	 .loc 1 2099 0
 3859 0034 FB7D     	 ldrb r3,[r7,#23]
 3860 0036 7868     	 ldr r0,[r7,#4]
 3861 0038 3969     	 ldr r1,[r7,#16]
 3862 003a 0022     	 movs r2,#0
 3863 003c FFF7FEFF 	 bl tcp_output_fill_options
2100:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 3864              	 .loc 1 2100 0
 3865 0040 7A68     	 ldr r2,[r7,#4]
 3866 0042 7B68     	 ldr r3,[r7,#4]
 3867 0044 0433     	 adds r3,r3,#4
 3868 0046 7868     	 ldr r0,[r7,#4]
 3869 0048 3969     	 ldr r1,[r7,#16]
 3870 004a FFF7FEFF 	 bl tcp_output_control_segment
 3871 004e 0346     	 mov r3,r0
 3872 0050 FB73     	 strb r3,[r7,#15]
2101:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2102:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F" err %d.\n",
2103:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                           pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
2104:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   return err;
 3873              	 .loc 1 2104 0
 3874 0052 FB7B     	 ldrb r3,[r7,#15]
 3875              	.L207:
 3876 0054 5BB2     	 sxtb r3,r3
2105:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 3877              	 .loc 1 2105 0
 3878 0056 1846     	 mov r0,r3
 3879 0058 1C37     	 adds r7,r7,#28
 3880              	.LCFI116:
 3881              	 .cfi_def_cfa_offset 12
 3882 005a BD46     	 mov sp,r7
 3883              	.LCFI117:
 3884              	 .cfi_def_cfa_register 13
 3885              	 
 3886 005c 90BD     	 pop {r4,r7,pc}
 3887              	 .cfi_endproc
 3888              	.LFE155:
 3890 005e 00BF     	 .section .text.tcp_zero_window_probe,"ax",%progbits
 3891              	 .align 2
 3892              	 .global tcp_zero_window_probe
 3893              	 .thumb
 3894              	 .thumb_func
 3896              	tcp_zero_window_probe:
 3897              	.LFB156:
2106:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2107:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** /**
2108:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Send persist timer zero-window probes to keep a connection active
2109:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * when a window update is lost.
2110:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
2111:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * Called by tcp_slowtmr()
2112:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  *
2113:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  * @param pcb the tcp_pcb for which to send a zero-window probe packet
2114:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****  */
2115:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** err_t
2116:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** tcp_zero_window_probe(struct tcp_pcb *pcb)
2117:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** {
 3898              	 .loc 1 2117 0
 3899              	 .cfi_startproc
 3900              	 
 3901              	 
 3902 0000 90B5     	 push {r4,r7,lr}
 3903              	.LCFI118:
 3904              	 .cfi_def_cfa_offset 12
 3905              	 .cfi_offset 4,-12
 3906              	 .cfi_offset 7,-8
 3907              	 .cfi_offset 14,-4
 3908 0002 8BB0     	 sub sp,sp,#44
 3909              	.LCFI119:
 3910              	 .cfi_def_cfa_offset 56
 3911 0004 00AF     	 add r7,sp,#0
 3912              	.LCFI120:
 3913              	 .cfi_def_cfa_register 7
 3914 0006 7860     	 str r0,[r7,#4]
2118:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   err_t err;
2119:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct pbuf *p;
2120:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct tcp_hdr *tcphdr;
2121:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   struct tcp_seg *seg;
2122:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u16_t len;
2123:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u8_t is_fin;
2124:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u32_t snd_nxt;
2125:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 3915              	 .loc 1 2125 0
 3916 0008 0023     	 movs r3,#0
 3917 000a 87F82730 	 strb r3,[r7,#39]
2126:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2127:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_ASSERT("tcp_zero_window_probe: invalid pcb", pcb != NULL);
2128:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2129:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: sending ZERO WINDOW probe to "));
2130:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   ip_addr_debug_print_val(TCP_DEBUG, pcb->remote_ip);
2131:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_DEBUGF(TCP_DEBUG, ("\n"));
2132:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2133:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_DEBUGF(TCP_DEBUG,
2134:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****               ("tcp_zero_window_probe: tcp_ticks %"U32_F
2135:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
2136:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));
2137:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2138:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* Only consider unsent, persist timer should be off when there is data in-flight */
2139:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   seg = pcb->unsent;
 3918              	 .loc 1 2139 0
 3919 000e 7B68     	 ldr r3,[r7,#4]
 3920 0010 DB6E     	 ldr r3,[r3,#108]
 3921 0012 3B62     	 str r3,[r7,#32]
2140:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (seg == NULL) {
 3922              	 .loc 1 2140 0
 3923 0014 3B6A     	 ldr r3,[r7,#32]
 3924 0016 002B     	 cmp r3,#0
 3925 0018 01D1     	 bne .L209
2141:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* Not expected, persist timer should be off when the send buffer is empty */
2142:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return ERR_OK;
 3926              	 .loc 1 2142 0
 3927 001a 0023     	 movs r3,#0
 3928 001c 86E0     	 b .L210
 3929              	.L209:
2143:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
2144:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2145:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* increment probe count. NOTE: we record probe even if it fails
2146:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      to actually transmit due to an error. This ensures memory exhaustion/
2147:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      routing problem doesn't leave a zero-window pcb as an indefinite zombie.
2148:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****      RTO mechanism has similar behavior, see pcb->nrtx */
2149:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (pcb->persist_probe < 0xFF) {
 3930              	 .loc 1 2149 0
 3931 001e 7B68     	 ldr r3,[r7,#4]
 3932 0020 93F89A30 	 ldrb r3,[r3,#154]
 3933 0024 FF2B     	 cmp r3,#255
 3934 0026 07D0     	 beq .L211
2150:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     ++pcb->persist_probe;
 3935              	 .loc 1 2150 0
 3936 0028 7B68     	 ldr r3,[r7,#4]
 3937 002a 93F89A30 	 ldrb r3,[r3,#154]
 3938 002e 0133     	 adds r3,r3,#1
 3939 0030 DAB2     	 uxtb r2,r3
 3940 0032 7B68     	 ldr r3,[r7,#4]
 3941 0034 83F89A20 	 strb r2,[r3,#154]
 3942              	.L211:
2151:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
2152:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2153:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 3943              	 .loc 1 2153 0
 3944 0038 3B6A     	 ldr r3,[r7,#32]
 3945 003a DB68     	 ldr r3,[r3,#12]
 3946 003c 9B89     	 ldrh r3,[r3,#12]
 3947 003e 9BB2     	 uxth r3,r3
 3948 0040 1846     	 mov r0,r3
 3949 0042 FFF7FEFF 	 bl lwip_htons
 3950 0046 0346     	 mov r3,r0
 3951 0048 DBB2     	 uxtb r3,r3
 3952 004a 03F00103 	 and r3,r3,#1
 3953 004e 002B     	 cmp r3,#0
 3954 0050 05D0     	 beq .L212
 3955              	 .loc 1 2153 0 is_stmt 0 discriminator 1
 3956 0052 3B6A     	 ldr r3,[r7,#32]
 3957 0054 1B89     	 ldrh r3,[r3,#8]
 3958 0056 002B     	 cmp r3,#0
 3959 0058 01D1     	 bne .L212
 3960              	 .loc 1 2153 0 discriminator 3
 3961 005a 0123     	 movs r3,#1
 3962 005c 00E0     	 b .L213
 3963              	.L212:
 3964              	 .loc 1 2153 0 discriminator 4
 3965 005e 0023     	 movs r3,#0
 3966              	.L213:
 3967              	 .loc 1 2153 0 discriminator 6
 3968 0060 FB77     	 strb r3,[r7,#31]
2154:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* we want to send one seqno: either FIN or data (no options) */
2155:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   len = is_fin ? 0 : 1;
 3969              	 .loc 1 2155 0 is_stmt 1 discriminator 6
 3970 0062 FB7F     	 ldrb r3,[r7,#31]
 3971 0064 002B     	 cmp r3,#0
 3972 0066 0CBF     	 ite eq
 3973 0068 0123     	 moveq r3,#1
 3974 006a 0023     	 movne r3,#0
 3975 006c DBB2     	 uxtb r3,r3
 3976 006e BB83     	 strh r3,[r7,#28]
2156:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2157:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   p = tcp_output_alloc_header(pcb, optlen, len, seg->tcphdr->seqno);
 3977              	 .loc 1 2157 0 discriminator 6
 3978 0070 97F82730 	 ldrb r3,[r7,#39]
 3979 0074 99B2     	 uxth r1,r3
 3980 0076 3B6A     	 ldr r3,[r7,#32]
 3981 0078 DB68     	 ldr r3,[r3,#12]
 3982 007a 5B68     	 ldr r3,[r3,#4]
 3983 007c BA8B     	 ldrh r2,[r7,#28]
 3984 007e 7868     	 ldr r0,[r7,#4]
 3985 0080 FFF7FEFF 	 bl tcp_output_alloc_header
 3986 0084 B861     	 str r0,[r7,#24]
2158:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (p == NULL) {
 3987              	 .loc 1 2158 0 discriminator 6
 3988 0086 BB69     	 ldr r3,[r7,#24]
 3989 0088 002B     	 cmp r3,#0
 3990 008a 01D1     	 bne .L214
2159:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
2160:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     return ERR_MEM;
 3991              	 .loc 1 2160 0
 3992 008c FF23     	 movs r3,#255
 3993 008e 4DE0     	 b .L210
 3994              	.L214:
2161:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
2162:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   tcphdr = (struct tcp_hdr *)p->payload;
 3995              	 .loc 1 2162 0
 3996 0090 BB69     	 ldr r3,[r7,#24]
 3997 0092 5B68     	 ldr r3,[r3,#4]
 3998 0094 7B61     	 str r3,[r7,#20]
2163:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2164:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (is_fin) {
 3999              	 .loc 1 2164 0
 4000 0096 FB7F     	 ldrb r3,[r7,#31]
 4001 0098 002B     	 cmp r3,#0
 4002 009a 12D0     	 beq .L215
2165:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* FIN segment, no data */
2166:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 4003              	 .loc 1 2166 0
 4004 009c 7B69     	 ldr r3,[r7,#20]
 4005 009e 9B89     	 ldrh r3,[r3,#12]
 4006 00a0 9BB2     	 uxth r3,r3
 4007 00a2 9BB2     	 uxth r3,r3
 4008 00a4 23F47C53 	 bic r3,r3,#16128
 4009 00a8 9CB2     	 uxth r4,r3
 4010 00aa 1120     	 movs r0,#17
 4011 00ac FFF7FEFF 	 bl lwip_htons
 4012 00b0 0346     	 mov r3,r0
 4013 00b2 9BB2     	 uxth r3,r3
 4014 00b4 2246     	 mov r2,r4
 4015 00b6 1343     	 orrs r3,r3,r2
 4016 00b8 9BB2     	 uxth r3,r3
 4017 00ba 9AB2     	 uxth r2,r3
 4018 00bc 7B69     	 ldr r3,[r7,#20]
 4019 00be 9A81     	 strh r2,[r3,#12]
 4020 00c0 11E0     	 b .L216
 4021              	.L215:
 4022              	.LBB15:
2167:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   } else {
2168:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* Data segment, copy in one byte from the head of the unacked queue */
2169:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     char *d = ((char *)p->payload + TCP_HLEN);
 4023              	 .loc 1 2169 0
 4024 00c2 BB69     	 ldr r3,[r7,#24]
 4025 00c4 5B68     	 ldr r3,[r3,#4]
 4026 00c6 1433     	 adds r3,r3,#20
 4027 00c8 3B61     	 str r3,[r7,#16]
2170:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     /* Depending on whether the segment has already been sent (unacked) or not
2171:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****        (unsent), seg->p->payload points to the IP header or TCP header.
2172:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****        Ensure we copy the first TCP data byte: */
2173:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 4028              	 .loc 1 2173 0
 4029 00ca 3B6A     	 ldr r3,[r7,#32]
 4030 00cc 5968     	 ldr r1,[r3,#4]
 4031 00ce 3B6A     	 ldr r3,[r7,#32]
 4032 00d0 5B68     	 ldr r3,[r3,#4]
 4033 00d2 1A89     	 ldrh r2,[r3,#8]
 4034 00d4 3B6A     	 ldr r3,[r7,#32]
 4035 00d6 1B89     	 ldrh r3,[r3,#8]
 4036 00d8 D31A     	 subs r3,r2,r3
 4037 00da 9BB2     	 uxth r3,r3
 4038 00dc 0846     	 mov r0,r1
 4039 00de 3969     	 ldr r1,[r7,#16]
 4040 00e0 0122     	 movs r2,#1
 4041 00e2 FFF7FEFF 	 bl pbuf_copy_partial
 4042              	.L216:
 4043              	.LBE15:
2174:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
2175:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2176:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   /* The byte may be acknowledged without the window being opened. */
2177:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + 1;
 4044              	 .loc 1 2177 0
 4045 00e6 3B6A     	 ldr r3,[r7,#32]
 4046 00e8 DB68     	 ldr r3,[r3,#12]
 4047 00ea 5B68     	 ldr r3,[r3,#4]
 4048 00ec 1846     	 mov r0,r3
 4049 00ee FFF7FEFF 	 bl lwip_htonl
 4050 00f2 0346     	 mov r3,r0
 4051 00f4 0133     	 adds r3,r3,#1
 4052 00f6 FB60     	 str r3,[r7,#12]
2178:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 4053              	 .loc 1 2178 0
 4054 00f8 7B68     	 ldr r3,[r7,#4]
 4055 00fa 1A6D     	 ldr r2,[r3,#80]
 4056 00fc FB68     	 ldr r3,[r7,#12]
 4057 00fe D31A     	 subs r3,r2,r3
 4058 0100 002B     	 cmp r3,#0
 4059 0102 02DA     	 bge .L217
2179:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****     pcb->snd_nxt = snd_nxt;
 4060              	 .loc 1 2179 0
 4061 0104 7B68     	 ldr r3,[r7,#4]
 4062 0106 FA68     	 ldr r2,[r7,#12]
 4063 0108 1A65     	 str r2,[r3,#80]
 4064              	.L217:
2180:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   }
2181:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   tcp_output_fill_options(pcb, p, 0, optlen);
 4065              	 .loc 1 2181 0
 4066 010a 97F82730 	 ldrb r3,[r7,#39]
 4067 010e 7868     	 ldr r0,[r7,#4]
 4068 0110 B969     	 ldr r1,[r7,#24]
 4069 0112 0022     	 movs r2,#0
 4070 0114 FFF7FEFF 	 bl tcp_output_fill_options
2182:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2183:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 4071              	 .loc 1 2183 0
 4072 0118 7A68     	 ldr r2,[r7,#4]
 4073 011a 7B68     	 ldr r3,[r7,#4]
 4074 011c 0433     	 adds r3,r3,#4
 4075 011e 7868     	 ldr r0,[r7,#4]
 4076 0120 B969     	 ldr r1,[r7,#24]
 4077 0122 FFF7FEFF 	 bl tcp_output_control_segment
 4078 0126 0346     	 mov r3,r0
 4079 0128 FB72     	 strb r3,[r7,#11]
2184:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** 
2185:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
2186:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                           " ackno %"U32_F" err %d.\n",
2187:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****                           pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
2188:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c ****   return err;
 4080              	 .loc 1 2188 0
 4081 012a FB7A     	 ldrb r3,[r7,#11]
 4082              	.L210:
 4083 012c 5BB2     	 sxtb r3,r3
2189:../Dave/Generated/ETH_LWIP/lwip/core/tcp_out.c **** }
 4084              	 .loc 1 2189 0
 4085 012e 1846     	 mov r0,r3
 4086 0130 2C37     	 adds r7,r7,#44
 4087              	.LCFI121:
 4088              	 .cfi_def_cfa_offset 12
 4089 0132 BD46     	 mov sp,r7
 4090              	.LCFI122:
 4091              	 .cfi_def_cfa_register 13
 4092              	 
 4093 0134 90BD     	 pop {r4,r7,pc}
 4094              	 .cfi_endproc
 4095              	.LFE156:
 4097 0136 00BF     	 .text
 4098              	.Letext0:
 4099              	 .file 2 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 4100              	 .file 3 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 4101              	 .file 4 "C:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/ScpiRelax/Dave/Generated/ETH_LWIP/lwip/include/lwip/arch.h"
 4102              	 .file 5 "C:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/ScpiRelax/Dave/Generated/ETH_LWIP/lwip/include/lwip/tcpbase.h"
 4103              	 .file 6 "C:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/ScpiRelax/Dave/Generated/ETH_LWIP/lwip/include/lwip/err.h"
 4104              	 .file 7 "C:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/ScpiRelax/Dave/Generated/ETH_LWIP/lwip/include/lwip/pbuf.h"
 4105              	 .file 8 "C:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/ScpiRelax/Dave/Generated/ETH_LWIP/lwip/include/lwip/ip4_addr.h"
 4106              	 .file 9 "C:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/ScpiRelax/Dave/Generated/ETH_LWIP/lwip/include/lwip/ip_addr.h"
 4107              	 .file 10 "C:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/ScpiRelax/Dave/Generated/ETH_LWIP/lwip/include/lwip/memp.h"
 4108              	 .file 11 "C:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/ScpiRelax/Dave/Generated/ETH_LWIP/lwip/include/lwip/netif.h"
 4109              	 .file 12 "C:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/ScpiRelax/Dave/Generated/ETH_LWIP/lwip/include/lwip/tcp.h"
 4110              	 .file 13 "C:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/ScpiRelax/Dave/Generated/ETH_LWIP/lwip/include/lwip/priv/tcp_priv.h"
 4111              	 .file 14 "C:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/ScpiRelax/Dave/Generated/ETH_LWIP/lwip/include/lwip/prot/tcp.h"
 4112              	 .file 15 "C:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/ScpiRelax/Libraries/CMSIS/Include/cmsis_gcc.h"
 4113              	 .file 16 "C:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/ScpiRelax/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tcp_out.c
    {standard input}:20     .text.tcp_route:00000000 $t
    {standard input}:24     .text.tcp_route:00000000 tcp_route
    {standard input}:81     .text.tcp_create_segment:00000000 $t
    {standard input}:85     .text.tcp_create_segment:00000000 tcp_create_segment
    {standard input}:245    .text.tcp_pbuf_prealloc:00000000 $t
    {standard input}:249    .text.tcp_pbuf_prealloc:00000000 tcp_pbuf_prealloc
    {standard input}:369    .text.tcp_write_checks:00000000 $t
    {standard input}:373    .text.tcp_write_checks:00000000 tcp_write_checks
    {standard input}:483    .text.tcp_write:00000000 $t
    {standard input}:488    .text.tcp_write:00000000 tcp_write
    {standard input}:1272   .text.tcp_split_unsent_seg:00000000 $t
    {standard input}:1277   .text.tcp_split_unsent_seg:00000000 tcp_split_unsent_seg
    {standard input}:1597   .text.tcp_send_fin:00000000 $t
    {standard input}:1602   .text.tcp_send_fin:00000000 tcp_send_fin
    {standard input}:1707   .text.tcp_enqueue_flags:00000000 tcp_enqueue_flags
    {standard input}:1702   .text.tcp_enqueue_flags:00000000 $t
    {standard input}:1904   .text.tcp_output:00000000 $t
    {standard input}:1909   .text.tcp_output:00000000 tcp_output
    {standard input}:3688   .text.tcp_send_empty_ack:00000000 tcp_send_empty_ack
    {standard input}:2530   .text.tcp_output_segment:00000000 tcp_output_segment
    {standard input}:2330   .text.tcp_output:0000028c $d
    {standard input}:2333   .text.tcp_output:00000290 $t
    {standard input}:2473   .text.tcp_output_segment_busy:00000000 $t
    {standard input}:2477   .text.tcp_output_segment_busy:00000000 tcp_output_segment_busy
    {standard input}:2526   .text.tcp_output_segment:00000000 $t
    {standard input}:2731   .text.tcp_output_segment:0000013c $d
    {standard input}:2736   .text.tcp_rexmit_rto_prepare:00000000 $t
    {standard input}:2741   .text.tcp_rexmit_rto_prepare:00000000 tcp_rexmit_rto_prepare
    {standard input}:2882   .text.tcp_rexmit_rto_commit:00000000 $t
    {standard input}:2887   .text.tcp_rexmit_rto_commit:00000000 tcp_rexmit_rto_commit
    {standard input}:2934   .text.tcp_rexmit_rto:00000000 $t
    {standard input}:2939   .text.tcp_rexmit_rto:00000000 tcp_rexmit_rto
    {standard input}:2980   .text.tcp_rexmit:00000000 $t
    {standard input}:2985   .text.tcp_rexmit:00000000 tcp_rexmit
    {standard input}:3122   .text.tcp_rexmit_fast:00000000 $t
    {standard input}:3127   .text.tcp_rexmit_fast:00000000 tcp_rexmit_fast
    {standard input}:3232   .text.tcp_output_alloc_header_common:00000000 $t
    {standard input}:3236   .text.tcp_output_alloc_header_common:00000000 tcp_output_alloc_header_common
    {standard input}:3360   .text.tcp_output_alloc_header:00000000 $t
    {standard input}:3364   .text.tcp_output_alloc_header:00000000 tcp_output_alloc_header
    {standard input}:3439   .text.tcp_output_fill_options:00000000 $t
    {standard input}:3443   .text.tcp_output_fill_options:00000000 tcp_output_fill_options
    {standard input}:3496   .text.tcp_output_control_segment:00000000 $t
    {standard input}:3500   .text.tcp_output_control_segment:00000000 tcp_output_control_segment
    {standard input}:3596   .text.tcp_rst:00000000 $t
    {standard input}:3601   .text.tcp_rst:00000000 tcp_rst
    {standard input}:3683   .text.tcp_send_empty_ack:00000000 $t
    {standard input}:3809   .text.tcp_keepalive:00000000 $t
    {standard input}:3814   .text.tcp_keepalive:00000000 tcp_keepalive
    {standard input}:3891   .text.tcp_zero_window_probe:00000000 $t
    {standard input}:3896   .text.tcp_zero_window_probe:00000000 tcp_zero_window_probe
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
netif_get_by_index
ip4_route
memp_malloc
pbuf_free
pbuf_add_header
tcp_seg_free
lwip_htons
lwip_htonl
pbuf_alloc
memcpy
pbuf_clen
pbuf_cat
tcp_segs_free
pbuf_copy_partial
pbuf_realloc
tcp_input_pcb
tcp_eff_send_mss_netif
ip4_output_if
tcp_ticks
